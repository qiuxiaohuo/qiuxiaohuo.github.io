<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Fortran 中的 KIND</title>
    <url>/Fortran%20%E4%B8%AD%E7%9A%84%20KIND/</url>
    <content><![CDATA[<p><code>KIND</code>
并不直接对应变量所占用的字节数，在不同的编译器与系统中可能有不同的对应关系，例如最常见的系统有：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REAl</span>(<span class="keyword">KIND</span>=<span class="number">4</span>)  :: xs   <span class="comment">! 4 byte ieee float</span></span><br><span class="line"><span class="keyword">REAl</span>(<span class="keyword">KIND</span>=<span class="number">8</span>)  :: xd   <span class="comment">! 8 byte ieee float</span></span><br><span class="line"><span class="keyword">REAl</span>(<span class="keyword">KIND</span>=<span class="number">16</span>) :: xq   <span class="comment">! 16 byte ieee float</span></span><br></pre></td></tr></table></figure>
<p>而有些编译器可能是：</p>
<span id="more"></span>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REAL</span>(<span class="keyword">KIND</span>=<span class="number">1</span>) :: XS   <span class="comment">! 4 BYTE FLOAT</span></span><br><span class="line"><span class="keyword">REAL</span>(<span class="keyword">KIND</span>=<span class="number">2</span>) :: XD   <span class="comment">! 8 BYTE FLOAT</span></span><br><span class="line"><span class="keyword">REAL</span>(<span class="keyword">KIND</span>=<span class="number">3</span>) :: XQ   <span class="comment">! 16 BYTE FLOAT</span></span><br></pre></td></tr></table></figure>
<p>所以，为了提高代码的可移植性，一般不直接给 integer 或 real
变量类型赋予确定的字节长度，而是使用内置函数<code>SELECTED_REAL_KIND</code>
and <code>SELECTED_INT_KIND</code> 从当前编译器中获取 <code>KIND</code>
的数值。例如，我想声明一个 15 位的 real 变量，首先调用内置函数：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!&gt; Double precision real numbers, 15 digits, range 10⁻³⁰⁷ to 10³⁰⁷-1; 64 bits</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: dp = <span class="built_in">selected_real_kind</span>(<span class="number">15</span>, <span class="number">307</span>)</span><br></pre></td></tr></table></figure>
<p>然后在程序中声明变量：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span>(dp) :: a, b, c</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=dp) :: a, b, c <span class="comment">! another equivalent statement</span></span><br><span class="line">a = <span class="number">1.0_dp</span></span><br><span class="line">b = <span class="number">3.5_dp</span></span><br><span class="line">c = <span class="number">1.34e8_dp</span></span><br></pre></td></tr></table></figure>
<p>注意，这里的浮点数常数后面还加上了参量 <code>KIND</code>
的后缀，每次写个数都这么搞似乎太麻烦了些，不知道不写是不是也<sub>行</sub>啊~~~？anyway，可以在
module 中统一定义参量 <code>KIND</code> ，然后在其它程序中引用：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!&gt; Numerical storage size parameters for real and integer values</span></span><br><span class="line"><span class="keyword">module</span> kind_parameter</span><br><span class="line">   <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">   <span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">!&gt; Single precision real numbers, 6 digits, range 10⁻³⁷ to 10³⁷-1; 32 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: sp = <span class="built_in">selected_real_kind</span>(<span class="number">6</span>, <span class="number">37</span>)</span><br><span class="line">   <span class="comment">!&gt; Double precision real numbers, 15 digits, range 10⁻³⁰⁷ to 10³⁰⁷-1; 64 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: dp = <span class="built_in">selected_real_kind</span>(<span class="number">15</span>, <span class="number">307</span>)</span><br><span class="line">   <span class="comment">!&gt; Quadruple precision real numbers, 33 digits, range 10⁻⁴⁹³¹ to 10⁴⁹³¹-1; 128 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: qp = <span class="built_in">selected_real_kind</span>(<span class="number">33</span>, <span class="number">4931</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">!&gt; Char length for integers, range -2⁷ to 2⁷-1; 8 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: i1 = <span class="built_in">selected_int_kind</span>(<span class="number">2</span>)</span><br><span class="line">   <span class="comment">!&gt; Short length for integers, range -2¹⁵ to 2¹⁵-1; 16 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: i2 = <span class="built_in">selected_int_kind</span>(<span class="number">4</span>)</span><br><span class="line">   <span class="comment">!&gt; Length of default integers, range -2³¹ to 2³¹-1; 32 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: i4 = <span class="built_in">selected_int_kind</span>(<span class="number">9</span>)</span><br><span class="line">   <span class="comment">!&gt; Long length for integers, range -2⁶³ to 2⁶³-1; 64 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: i8 = <span class="built_in">selected_int_kind</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> kind_parameter</span><br></pre></td></tr></table></figure>
<p>如果不是跨系统使用自己的代码，直接在 Windows 环境下用
<code>real(8)</code> 就省事多了。</p>
<p>我似乎明白了为什么之前看到过别人的 Fortran 代码，连 0.0，1.0，…，9.0
都要用变量名定义。我使用的编程语言主要是 MATLAB（如果 MATLAB
可以被称为一门编程语言的话），对数据类型只关注整数，浮点数，字符这种大的类别的区分，对于这些数据占系统多少字节并不关心，但是
Fortran 中的变量还可以体现占用字节的信息。</p>
<p><strong>主要参考文档</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMjAwOTMwMDkwMTM3L2h0dHBzOi8vc3RldmVsaW9uZWwuY29tL2RyZm9ydHJhbi8yMDE3LzAzLzI3L2RvY3Rvci1mb3J0cmFuLWluLWl0LXRha2VzLWFsbC1raW5kcy8=">Doctor
Fortran in “It Takes All KINDs”<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODM4MzEwL2ZvcnRyYW4tOTAta2luZC1wYXJhbWV0ZXI=">Fortran
90 kind parameter<i class="fa fa-external-link-alt"></i></span></p>
<p>在看帖子时看到别人写的查询自己机器 <code>KIND</code> 变量并生成相应的
Fortran 源码的代码，<code>kindfinder.f90</code></p>
]]></content>
  </entry>
  <entry>
    <title>Markdown 添加注记文本</title>
    <url>/Markdown%20%E4%BD%BF%E7%94%A8%20html%20%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>在写文档的时候, 我有时会有这样的需求:</p>
<ul>
<li>标记一段重要的文本；</li>
<li>这些文本可以归属为: 笔记 (note) , 警告 (warning) , 定义等等</li>
</ul>
<p>我就很想要一个彩色的框框, 把这段文字给标注一下. 在 <span
class="math inline">\(\LaTeX\)</span>​​​ 中, 一般是用命令
<code>\mdframed</code> 实现. 然而在 Markdown 的标准语法中,
并没有注记文本这一功能.</p>
<span id="more"></span>
<hr />
<p>一些特殊的 Markdown 解析器可以做到, 比如在 Github Markdown
解析器中插入下段标记:</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/github-admonition-20230928143727151.png"
alt="image-20230928143727151" />
<figcaption aria-hidden="true">image-20230928143727151</figcaption>
</figure>
<hr />
<p>注记文本的功能也有人向 Typora 官方提出过, 不过 Typora
认为这一功能并不是必要的, 反而还会破坏 Markdown 语法的简洁性. 在 Github
上的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cG9yYS90eXBvcmEtaXNzdWVzL2xhYmVscy9tYXJrZG93biUyMGV4dGVuc2lvbj9wYWdlPTImcT1pcyUzQW9wZW4rbGFiZWwlM0ElMjJtYXJrZG93bitleHRlbnNpb24lMjI=">issue<i class="fa fa-external-link-alt"></i></span>是这样说的:</p>
<blockquote>
<p>This seems too far way from most markdown engines. We want keep
markdown in typora simple, no extra learning costs if one already knows
how to write markdown. So, we are less likely to add syntax support for
this</p>
</blockquote>
<p>一种替代的方法是是用 emoji <span class="github-emoji"
data-alias="tada" style=""
data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span>.
这个是 stackflow 上提供的权宜之计. 比如说, 我想写一段笔记:</p>
<blockquote>
<p><span class="github-emoji" data-alias="notebook" style=""
data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8">📓</span>
<strong>笔记</strong></p>
<p>这是一段笔记.</p>
</blockquote>
<p>还可以吧, 要是引用框的颜色可以变变就更好了. 不然 Typora
的文档总显得灰头土脸的, 放到 hexo 博客上的文章也是单一的白色.
这时可以使用 html 标签 <code>&lt;div&gt; &lt;/div&gt;</code>
来添加引用文本的背景色, 可是需要添加很长一段代码, 在 Typora
中不太实用:</p>
<div style="background-color:lightblue;padding:20px;">
<h4>
Warning
</h4>
<p>
London is the capital city of England. It is the most populous city in
the United Kingdom, with a metropolitan area of over 13 million
inhabitants.
</p>
</div>
<p>但是这个颜色吧… 综上, 还是使用 emoji 的方式, 在 Typora
中表示段落文字的强调.</p>
<hr />
<p>在写 hexo 博客的时候, 可以使用 tag 插件实现这一功能,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [summary] %&#125;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>变量说明如下:</p>
<ul>
<li><code>[class]</code> : <em>Optional parameter.</em> Supported
values: default | primary | success | info | warning | danger.</li>
<li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon
in note.</li>
<li><code>[summary]</code> : <em>Optional parameter.</em> Optional
summary of the note.</li>
</ul>
<p>效果图为</p>
<figure>
<img
src="C:\Users\qiutian\AppData\Roaming\Typora\typora-user-images\image-20240406093726500.png"
alt="image-20240406093726500" />
<figcaption aria-hidden="true">image-20240406093726500</figcaption>
</figure>
<h2 id="除此之外">除此之外</h2>
<p>探索 Markdown 段落标记文字的时候, 发现它可以插入 html 标签,
来实现一些之前没想到过的功能. 更多内容可以参考<span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LnR5cG9yYS5pby9IVE1MLyNjb21tZW50cw==">官方文档<i class="fa fa-external-link-alt"></i></span>, 以及 html
<span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9odG1sL2RlZmF1bHQuYXNw">教学网站<i class="fa fa-external-link-alt"></i></span>.</p>
<h3 id="键盘标签-kbd">键盘标签 <code>&lt;kbd&gt;</code></h3>
<p>该标签可以插入在行内. 比如, 我想表示 VSCode 中「打开设置」快捷键:
<kbd>Ctrl</kbd>+<kbd>,</kbd>.</p>
<h3 id="总结标签-summary">总结标签 <code>&lt;summary&gt;</code></h3>
<details>
<summary>
I have keys but no locks. I have space but no room. You can enter but
can't leave. What am I?
</summary>
<pre><code> A keyboard. &lt;/details&gt;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Vim 快捷指令</title>
    <url>/Vim%20%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="为什么会用-vim">为什么会用 Vim</h2>
<p>因为 Vim 提供了一种不太一样的文本编辑器哲学.
它认为代码主要的工作是修改代码, 所以提供了大量的键盘指令操作,
方便使用者来修改 ta 们的代码.<span id="more"></span></p>
<h2 id="vim-的四种模式">Vim 的四种模式</h2>
<ul>
<li>Normal mode: 普通模式, 移动光标或使用命令修改文本</li>
<li>Visual mode: 浏览模式, 选择文本</li>
<li>Insert mode: 插入模式, 编辑文本</li>
<li>Command mode: 命令模式, 执行命令</li>
</ul>
<h3 id="插入模式">插入模式</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>i</code></td>
<td>在光标后编辑</td>
</tr>
<tr class="even">
<td><code>I</code></td>
<td>在光标所在行<strong>起始</strong>编辑</td>
</tr>
<tr class="odd">
<td><code>a</code></td>
<td>在光标<strong>前</strong>编辑</td>
</tr>
<tr class="even">
<td><code>A</code></td>
<td>在光标所在行<strong>末尾</strong>编辑</td>
</tr>
<tr class="odd">
<td><code>o</code></td>
<td>在光标所在行<strong>下方</strong>增添新行并编辑</td>
</tr>
<tr class="even">
<td><code>O</code></td>
<td>在光标所在行<strong>上方</strong>增添新行并编辑</td>
</tr>
</tbody>
</table>
<h3 id="浏览模式">浏览模式</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>v</code></td>
<td>从光标所在<strong>处</strong>开始,
按<strong>字符</strong>选择文本</td>
</tr>
<tr class="even">
<td><code>V</code></td>
<td>从光标所在<strong>行</strong>开始,
按<strong>行</strong>选择文本</td>
</tr>
<tr class="odd">
<td><code>ctrl+v</code></td>
<td>从光标所在<strong>列</strong>开始,
按<strong>列</strong>选择文本</td>
</tr>
</tbody>
</table>
<h3 id="命令模式">命令模式</h3>
<ul>
<li><code>:q</code> 退出</li>
<li><code>:w</code> 保存</li>
<li><code>:wq</code> 保存并退出</li>
<li><code>:e &#123;文件名&#125;</code> 打开文件并编辑</li>
<li><code>:ls</code> 展示打开的缓存区</li>
<li><code>:help &#123;命令&#125;</code> 打开帮助, 例如
<ul>
<li><code>:help :w</code> 打开关于命令 <code>:w</code> 的帮助</li>
<li><code>:help w</code> 打开关于命令 <code>w</code> 的帮助</li>
</ul></li>
</ul>
<h2 id="导航">导航</h2>
<h3 id="移动屏幕">移动屏幕</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>zt</code></td>
<td>移动屏幕, 使得光标在窗口顶端</td>
</tr>
<tr class="even">
<td><code>zt</code></td>
<td>移动屏幕, 使得光标在窗口顶端</td>
</tr>
<tr class="odd">
<td><code>zz</code></td>
<td>移动屏幕, 使得光标在窗口中部</td>
</tr>
<tr class="even">
<td><code>zb</code></td>
<td>移动屏幕, 使得光标在窗口底部</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>H</code></td>
<td>移动光标至屏幕顶端</td>
</tr>
<tr class="even">
<td><code>M</code></td>
<td>移动光标至屏幕中部</td>
</tr>
<tr class="odd">
<td><code>L</code></td>
<td>移动光标至屏幕底部</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>gg</code></td>
<td>移动光标至文件起始处</td>
</tr>
<tr class="even">
<td><code>G</code></td>
<td>移动光标至文件末尾处</td>
</tr>
</tbody>
</table>
<p><code>&#123;行号&#125;gg</code>, <code>&#123;行号&#125;G</code>, <code>:&#123;行号&#125;</code>
移动光标至行{行号}</p>
<h3 id="单词">单词</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>w</code></td>
<td>将光标移动到前一个单词的起始处</td>
</tr>
<tr class="even">
<td><code>e</code></td>
<td>将光标移动到当前单词的末尾处; <br>若已经在末尾,
则移动到前一个单词的末尾处</td>
</tr>
<tr class="odd">
<td><code>b</code></td>
<td>将光标移动到后一个单词的起始处</td>
</tr>
<tr class="even">
<td><code>ge</code></td>
<td>将光标移动到后一个单词的末尾处</td>
</tr>
</tbody>
</table>
<h3 id="行">行</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>^</code></td>
<td>将光标移动到所在行第一个字符处</td>
</tr>
<tr class="even">
<td><code>0</code></td>
<td>将光标移动到行首</td>
</tr>
<tr class="odd">
<td><code>$</code></td>
<td>将光标移动到行尾</td>
</tr>
</tbody>
</table>
<h3 id="搜索">搜索</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>f&#123;字符&#125;</code></td>
<td>在当前行<strong>向前</strong>搜索并跳转至字符 char 处</td>
</tr>
<tr class="even">
<td><code>F&#123;字符&#125;</code></td>
<td>在当前行<strong>向后</strong>搜索并跳转至字符 char 处</td>
</tr>
<tr class="odd">
<td><code>t&#123;字符&#125;</code></td>
<td>在当前行<strong>向前</strong>搜索并跳转到字符 char 后</td>
</tr>
<tr class="even">
<td><code>T&#123;字符&#125;</code></td>
<td>在当前行<strong>向后</strong>搜索并跳转到字符 char 前</td>
</tr>
</tbody>
</table>
<p>使用 <code>,</code> / <code>;</code> 搜索 后/前 一个字符</p>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/&#123;正则表达式&#125;</code></td>
<td>在文档中搜索{正则表达式}</td>
</tr>
</tbody>
</table>
<p>使用 <code>N</code> / <code>n</code> 搜索 后/前 一个{正则表达式}</p>
<h2 id="编辑文档">编辑文档</h2>
<h3 id="删除和替换">删除和替换</h3>
<ul>
<li><code>d&#123;导航命令&#125;</code> 删除 {导航命令}
<ul>
<li>e.g. <code>dw</code> 删除单词, <code>d$</code>
删除光标处至行尾的内容, <br><code>d0</code> 删除光标处至行首的内容</li>
</ul></li>
<li><code>c&#123;导航命令&#125;</code> 替换 {导航命令}
<ul>
<li>e.g. <code>cw</code> 可以看作执行删除单词命令后再执行命令
<code>i</code></li>
</ul></li>
<li><code>x</code> 删除字符 (等价于 <code>dl</code>)</li>
<li><code>s</code> 替换字符 (等价于 <code>cl</code>)</li>
</ul>
<h3 id="复制和粘贴">复制和粘贴</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>y␣</code></td>
<td>复制光标所在处字符</td>
</tr>
<tr class="even">
<td><code>yy</code></td>
<td>复制光标所在行</td>
</tr>
<tr class="odd">
<td><code>yw</code></td>
<td>复制光标所在单词</td>
</tr>
<tr class="even">
<td><code>y$</code></td>
<td>复制光标处至行尾的内容</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>p</code></td>
<td>在光标后粘贴</td>
</tr>
<tr class="even">
<td><code>P</code></td>
<td>在光标前粘贴</td>
</tr>
</tbody>
</table>
<h3 id="撤销和重现">撤销和重现</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>u</code></td>
<td>撤销上一次操作</td>
</tr>
<tr class="even">
<td><code>Ctrl+r</code></td>
<td>重现下一次操作</td>
</tr>
</tbody>
</table>
<h3 id="计数">计数</h3>
<p>在此处仅举一些命令作为例子, 其它可类推</p>
<ul>
<li><code>3w</code> 向前移动 3 个单词</li>
<li><code>5j</code> 向下移动 5 行</li>
<li><code>7dw</code> 删除 7 个单词</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Git 相关</title>
    <url>/Git-%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="git-阅读材料">Git 阅读材料</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3Yy">Pro Git<i class="fa fa-external-link-alt"></i></span>
看到所有的网站都推荐阅读这一本书，当作手册来查；</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9taXNzaW5nLmNzYWlsLm1pdC5lZHUvMjAyMC92ZXJzaW9uLWNvbnRyb2wv">Missing
CS<i class="fa fa-external-link-alt"></i></span> 介绍了 Git 的数据模型，方便理解 Git
不那么友好的指令操作，很惊讶作者可以把 Git 讲得那么清楚；
<ul>
<li>btw，该网站同样推荐了许多 Git 的阅读材料，比如下一条：</li>
</ul></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQv">Git commit<i class="fa fa-external-link-alt"></i></span> 介绍撰写 Commit
信息的好的实践方案</li>
</ul>
<span id="more"></span>
<h2 id="git-commit-七准则">Git commit 七准则</h2>
<p>这里引用 <span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQv">Git commit<i class="fa fa-external-link-alt"></i></span>
里的文字：</p>
<blockquote class="blockquote-center">
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI3NlcGFyYXRl">Separate subject from
body with a blank line<i class="fa fa-external-link-alt"></i></span> 将主题与正文用空白行分隔</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI2xpbWl0LTUw">Limit the subject
line to 50 characters<i class="fa fa-external-link-alt"></i></span> 主题限制在 50 个字符之内</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI2NhcGl0YWxpemU=">Capitalize the
subject line<i class="fa fa-external-link-alt"></i></span> 主题首字符大写</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI2VuZA==">Do not end the subject
line with a period<i class="fa fa-external-link-alt"></i></span> 主题结尾不要写句号</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI2ltcGVyYXRpdmU=">Use the imperative
mood in the subject line<i class="fa fa-external-link-alt"></i></span> 主题使用祈使语气</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI3dyYXAtNzI=">Wrap the body at 72
characters<i class="fa fa-external-link-alt"></i></span> 正文每一行不超过 72 个字符</li>
<li><a href="https://cbea.ms/git-commit/#why-not-how">Use the body to
explain <em>what</em> and <em>why</em> vs. <em>how</em></a>
使用正文说明是什么，为什么，怎么做</li>
</ol>

</blockquote>
<h2 id="github-clone-失败">Github clone 失败</h2>
<p>使用 Github 克隆某一个库的时候，报错如下：</p>
<blockquote>
<p>git clone fatal unable to acces</p>
</blockquote>
<p>使用如下解决方案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>结果不行，后来浏览到一篇帖子，说是 Git
端口和本机系统代理的端口不一致造成的。打开
Clash，查看我的笔记本的代理端口为：7890。然后设置 Git 的端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>注意，第二条是 <code>http://127.0.0.1:7890</code> ，不是
<code>https://127.0.0.1:7890</code></p>
<h2 id="git-相关命令">Git 相关命令</h2>
<p><code>git init</code> 初始化 git 仓库。在当前目录下会生成一个
<code>.git/</code> 目录</p>
<p><code>git branch &lt;newbranch&gt;</code> 创建一个新的分支（但 head
指针仍然指向旧分支）</p>
<p><code>git checkout &lt;branchname&gt;</code> 将 head
指针移到某一个分支上</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 使用 snippets 插入代码注释</title>
    <url>/VSCode%20%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>突然发现用 snippets 写注释也非常好用啊，比如写 Fortran 的 function 或
subroutine 的头部注释：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">! name      : symSchur2</span></span><br><span class="line"><span class="comment">! remark    : get Schur decomposition for 2x2 matrix</span></span><br><span class="line"><span class="comment">!</span></span><br><span class="line"><span class="comment">! version   : 1.0</span></span><br><span class="line"><span class="comment">! date      : 2023-09-06 13:34:25</span></span><br><span class="line"><span class="comment">! author    : Junsong Qiu</span></span><br><span class="line"><span class="comment">!-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> symSchur2(A,c,s)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> symSchur2</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>直接在 Fortran 对应的 snippets 设置文件
<code>FortranFreeForm.json</code> 中加入如下片段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Head comments for subroutines&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hc&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;!-----------------------------------------------------------------------------&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! name      : $1&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! remark    : $2&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;!&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! version   : 1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! date      : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE  $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! author    : Junsong Qiu&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;!-----------------------------------------------------------------------------&quot;</span></span><br><span class="line">		<span class="punctuation">]</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，变量 <code>$1</code> <code>$2</code> 在插入 snippets
时会自动要求你插入新的内容。时间部分可以用 VSCode 内置的变量添加。</p>
]]></content>
  </entry>
  <entry>
    <title>创作文档管理</title>
    <url>/%E5%88%9B%E4%BD%9C%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>我过去的文档管理方式太过粗放，以至我感到自己似乎一直是在原地踏步。这是因为我在用多个平台（知乎，Hexo+NexT
博客，Zotero 等），用多种方式（MATLAB 实时脚本，LaTeX，Markdown
等）写文档，这些文档缺少一个「地图」索引，所以我的知识库相互是分割独立的，仿佛一盘散沙，没办法攒出某种结构出来。所以我希望建立一个文档管理的规则，按照这个规则，我可以系统地将所有创作的文档相互关联。<span id="more"></span></p>
<p>我创作的文档类型有：</p>
<ol type="1">
<li><strong>Markdown（md） 文档</strong>
用来写一些效率提升的奇技淫巧，记录软件的配置过程等等，还有专业相关的一些小问题，如果对排版要求不高的话，我也会用
md 来写</li>
<li><strong>LaTeX 文档</strong>
写专业相关的文档，篇幅会很长，并且有大量公式</li>
<li><strong>MATLAB 脚本</strong> MATLAB
实时脚本本身也具有文档的功能，类似的还有 Mathematica 的
Notebook。这些文档是用来计算某一类小问题。含有多个文件与函数的 matlab
程序并不包含在内，这可以用 Github 管理</li>
<li><strong>Zotero 文献整理</strong>
主要和阅读的论文资料相关，该文档依赖于文献</li>
</ol>
<p>以上所有文档，都可以转换为 md 文档进行索引：</p>
<ul>
<li>LaTeX 可以使用 Pandoc 转换为 md 文档，转换的效率还是可以的</li>
<li>MATLAB 实时脚本可以导出 md 文档</li>
<li>Zotero 中的笔记也可以导出 md 文档</li>
</ul>
<p>，那么，如何定义 md 文档与源文档之间的关系呢？我们做出如下规定：</p>
<ul>
<li><strong>源文档必须进行版本控制，确定发行版本号</strong></li>
<li><strong>md 文档需要标识源文档，但源文档不需要给出指向 md
文档的标识</strong></li>
<li><strong>对于 LaTeX
文档，所有内容上的修改应在源文档中做出，然后通过版本控制系统上传修改，再将新版本的文档转化为
md</strong></li>
</ul>
<h2 id="md-文档标识规则">md 文档标识规则</h2>
<p>在 md 文档中，使用 html 标签<code>&lt;!--注释内容--&gt;</code>
进行注释，这样在静态网站上看不到该标签中的内容。标注内容的格式为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文档名称--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档仓库路径--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档版本号--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="文档仓库和版本控制">文档仓库和版本控制</h2>
<p>文档任务工作基本上都是线性的，不需要太多 branch
工作，并且文档私密性较高，所以使用 SVN 进行版本控制。</p>
<p>创建文档的仓库目录如下：</p>
<ul>
<li><code>LaTeXdocs/</code></li>
<li><code>MATLAB/</code></li>
<li><code>Mathematica/</code></li>
</ul>
<h2 id="zotero-文档管理">Zotero 文档管理</h2>
<p>Zotero 的文档管理相对比较复杂，因为 Zotero
本身就是一个文档集成器，可以方便地在原文献基础上进行注释与引用。但是我更希望
Zotero
是作为一个文献数据库，我可以方便地找到我的引用来源，但是我自己对知识的理解与创造则与文献库相区分。然而
Zotero 的数据不太方便版本控制，因为 Zotero
的数据集成方式是与软件绑定在一起的，你不需要控制文件在本地怎么存储。但是每一次操作，比如在文档中截个图，画个线，都会变更文件，所以
Zotero 的数据库更新很快，更适合云同步。</p>
<p>所以，如果整理的文献有值得放在个人文档库中的，那么就<strong>在文档的开头添加参考文献</strong>，不需要与
Zotero 自带的笔记系统相关联。</p>
<h2 id="总结">总结</h2>
<p>我制定的文档管理规则为：</p>
<ul>
<li><strong>Markdown 文档</strong> 在 <code>Blog/source</code>
下编辑，上传至网络博客</li>
<li><strong>LaTeX 文档</strong> 创建 SVN 仓库
<code>LaTeXdocs/</code>，发布文件版本号，并将 release 版本的文档使用
Pandoc 整理为 md 文档，在 md 文档首部添加注释行说明转换 LaTeX
文档的信息</li>
<li><strong>Mathematica 文档</strong> 创建 SVN 仓库
<code>Mathematica/</code>，发布文件版本号，并将 release 版本的文档导出为
md 文档，在 md 文档首部添加注释行说明 Mathematica文档的信息</li>
<li><strong>MATLAB 文档</strong> 创建 SVN 仓库
<code>MATLAB/</code>，发布文件版本号，并将 release 版本的文档导出为 md
文档，在 md 文档首部添加注释行说明 MATLAB 文档的信息</li>
<li><strong>Zotero 文档</strong> 使用坚果云进行同步，主要用 Zotero
存放科研的参考源数据。在 Zotero
中撰写关于文献的笔记。如果该笔记值得放到博客中，就导出为 md
文档，并在文档开头指明参考文献</li>
</ul>
]]></content>
      <tags>
        <tag>文档管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT + Github：搭建博客</title>
    <url>/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>首先我们先理清一下这三者的关系：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuLw==">Hexo<i class="fa fa-external-link-alt"></i></span>
本身是自动生成博客网页的<strong>框架</strong>代码，它不需要我们自己编写网页（例如
<code>.css</code>，<code>.js</code> ），而是修改
<code>_config.yml</code>
文件提供的参量，自动生成静态网页，可以在本机浏览；</li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy8=">NexT<i class="fa fa-external-link-alt"></i></span> 是 Hexo
的主题插件，本身依赖于 Hexo，提供额外的主题。它同样也提供
<code>_config.yml</code> 文件供我们配置；</li>
<li>使用 Github 将生成的静态网页推送到互联网当中。<span id="more"></span></li>
</ul>
<div class="note info"><p>新版本的 NexT 可以在博客根目录下配置 <code>_config.next.yml</code>
文件，这可以避免在使用 Github 更新 NexT
时与，本地的配置文件发生冲突，同时也不再用区别 Hexo 和 NexT
名称相同的配置文件。</p>
</div>
<h2 id="安装-hexo">安装 Hexo</h2>
<p>Hexo 的官方配置文档在<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">这里<i class="fa fa-external-link-alt"></i></span>。</p>
<p>首先安装一些必备的工具：<code>Node.js</code>；<code>Git</code>。</p>
<p>然后使用 <code>npm</code> 安装 Hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="初始化博客本地文件夹">初始化博客本地文件夹</h2>
<p>我们现在需要在本机的某一文件夹下初始化博客，例如想将博客文件放在
<code>\Blog</code> 目录下，在该文件夹中打开命令行，运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>运行上述命令之后，在 <code>\Blog</code>
文件夹下会生成如下子目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<div class="note info"><p>第一次使用 Hexo 命令时，可能会报关于 PowerShell 不能信任 Hexo
脚本的错误，并在界面中指向<span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL3Bvd2Vyc2hlbGwvbW9kdWxlL21pY3Jvc29mdC5wb3dlcnNoZWxsLmNvcmUvYWJvdXQvYWJvdXRfZXhlY3V0aW9uX3BvbGljaWVzP3ZpZXc9cG93ZXJzaGVsbC03LjM=">网址<i class="fa fa-external-link-alt"></i></span>。直接把执行策略改成
<code>Bypass</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy Bypass</span><br></pre></td></tr></table></figure>
</div>
<h2 id="配置博客">配置博客</h2>
<p>详细的配置步骤可见 Hexo 和 NexT 官方文档，不过更推荐看 NexT <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL2dldHRpbmctc3RhcnRlZC8=">的文档<i class="fa fa-external-link-alt"></i></span>，因为
NexT 的文档中既包含了 Hexo
的配置，同时一直在更新当中。这里列举了一些在教程之外的配置。</p>
<h3 id="自定义菜单栏内容">自定义菜单栏内容</h3>
<p>NexT 提供的菜单栏内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<p>我希望加入额外的标签页，用来记录点滴日常，新建标签如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nichijou:</span> <span class="string">/nichijou/</span> <span class="string">||</span> <span class="string">fa-regular</span> <span class="string">fa-sun</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>fa-regular fa-sun</code> 是来自 <span class="exturl" data-url="aHR0cHM6Ly9mb250YXdlc29tZS5jb20v">font awesome<i class="fa fa-external-link-alt"></i></span>
的图标。这时我们还需要配置语言，使得 NexT 能够识别关键词，在
<code>./theme/next/language</code> 目录下找到 <code>zh-CN.yml</code>，在
<code>menu</code> 关键词下添加如下翻译词对：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add user defined translation pair</span></span><br><span class="line"><span class="attr">nichijou:</span> <span class="string">日常</span></span><br></pre></td></tr></table></figure>
<p>在修改完配置文件之后，我们还需要生成博客 page 页面对应的
<code>.md</code> 文档，使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page nichijou</span><br></pre></td></tr></table></figure>
<p>之后会在 <code>./source</code> 目录下生成同名目录
<code>nichijou/</code>，同时在该目录中生成 <code>index.md</code>
文件。这样在点击博客菜单栏标题时，就会显示 <code>index.md</code>
的内容。</p>
<h3 id="公式显示">公式显示</h3>
<p>按照默认设置，博客显示的公式是 LaTeX 代码。因此需要修改
<code>_config.next.yml</code> 关于 <code>math</code> 部分的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="知识协议">知识协议</h3>
<p>配置的协议为 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzQuMC9kZWVkLnpoLWhhbnM=">cc
by-sa<i class="fa fa-external-link-alt"></i></span>，可以共享、修改、用于商业目的，但是必须在引用时指明来源，并且使用相同的协议。</p>
<h2 id="撰写博客的工作流程">撰写博客的工作流程</h2>
<h3 id="新建博客文档">新建博客文档</h3>
<p>新建文档的命令是 <code>new</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>可选参数 <code>[layout]</code>：默认是 <code>post</code>，可以选择为
<code>draft</code>，这时会在 <code>\source\_drafts</code>
目录下生成待发表的博客文档，并且没有时间戳；</li>
<li>文档题目
<code>&lt;title&gt;</code>：可以<strong>不添加后缀</strong>，默认生成
<code>&lt;title&gt;.md</code>
文档。如果题目中没有空格，也可以不用加双引号。</li>
</ul>
<p>例如新建文档：<a
href="https://qiuxiaohuo.github.io/2023/09/20/mytest/">测试我的第一篇博客文档</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new 测试我的第一篇博客文档</span><br></pre></td></tr></table></figure>
<p>这样就可以在 <code>\source</code> 目录下找到对应的
<code>测试我的第一篇博客文档.md</code> 文档了。</p>
<p>如果不想立即发表博客文档，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;博客草稿&quot;</span><br></pre></td></tr></table></figure>
<p>这时在生成网站文件时会自动忽略该文档。如果该草稿已经完成，则使用如下命令进行发表，hexo
会将该文档转移到 <code>\source\_posts</code> 目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish post &quot;博客草稿&quot;</span><br></pre></td></tr></table></figure>
<p>此外还可以在 <code>\scaffold</code> 目录下自定义模板文件，具体详见
hexo <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mvd3JpdGluZy5odG1s">写作<i class="fa fa-external-link-alt"></i></span>
文档。</p>
<h3 id="生成网站文件">生成网站文件</h3>
<p>首先先清理一下原来的站点文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>或者简写为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br></pre></td></tr></table></figure>
<p>然后生成静态文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>或简写为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>后面还可以加一点组合命令，比如 <code>-d</code>
表示生成完静态站点之后直接推送到 Github 上去，它与如下命令是等价的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy -g</span><br></pre></td></tr></table></figure>
<p>上个命令意思是在 <code>deploy</code> 之前先
<code>generate</code>。如果想在本机中查看网页生成的效果，可以运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>在配置完成之后，上传一篇博客文档的工作流程可以总结为：</p>
<ol type="1">
<li>在 目录中生成 <code>博客文档.md</code>
文件：<code>hexo new &lt;博客文档名称&gt;</code>；</li>
<li>编写 <code>博客文档.md</code> 文档 (可以不在 Hexo 生成的 .md
文件中编写，完成后将文档内容复制到该文件中)；</li>
<li>清除生成的静态文件：<code>hexo cl</code>；</li>
<li>重新生成静态文件：<code>hexo g</code>；</li>
<li>查看生成网页的效果，若不满意，则返回第 2
步：<code>hexo s</code>；</li>
<li>上传到
Github，博客的内容最终展示在互联网上：<code>hexo d</code></li>
</ol>
<h2 id="一些博客插件">一些博客插件</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL3RhZy1wbHVnaW5zL25vdGU=">NexT
主题下使用 note 标记<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何撰写设计日志</title>
    <url>/%E5%A6%82%E4%BD%95%E6%92%B0%E5%86%99%E8%AE%BE%E8%AE%A1%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>这段文字来自 MIT 公开课 <span class="exturl" data-url="aHR0cHM6Ly9vY3cubWl0LmVkdS9jb3Vyc2VzLzEtMDUwLXNvbGlkLW1lY2hhbmljcy1mYWxsLTIwMDQvcGFnZXMvc3lsbGFidXMv">1.050<i class="fa fa-external-link-alt"></i></span>，我想我可以按照教授提供的方式尝试一下写设计日志。简要地翻译一下：<span id="more"></span></p>
<blockquote><p>这本日志被用来记录你的工作过程。它的内容呢，既不是被反复润色的展稿，也不是对出现在你脑海中的想法与字词完完全全的记录。它是一份关于你思维过程的「流水账」，足够详尽，可以使你在隔一段时间后，重建当时的推理，猜想与分析过程。请用墨水手写这份日志。如果你想法改变了，或者发现犯了个错误，不要擦掉重写，而是在你不想保留的内容上画条横线。</p>
<p>将你的姓名，邮箱，还有手机号写在日志显眼的地方上，如果丢失的话，你就可以把它找回来。将前几页留白，一边进行记录，一边添加页码，一边添加目录。</p>
<p>在设计的最后，使用一到两页纸总结你的工作——例如，一张标注尺寸的草图；解释哪些参数为什么那么重要；重述设计要求；关于重要约束的笔记。</p>
<p>请记住：</p>
<p><strong>过程和结果伯仲难分；手段和目的同等重要。</strong></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>工作站的数据存储方案</title>
    <url>/%E5%B7%A5%E4%BD%9C%E7%AB%99%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>现在我的工作站数据分配空间如下 (省略了其它系统盘的存储空间数据)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">laptop@qxh-Precision-7920-Tower /repos&gt; <span class="built_in">df</span> -h</span><br><span class="line">文件系统        大小  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sdb8       234G   42G  180G   19% /</span><br><span class="line">/dev/sdc3       916G   58G  813G    7% /home</span><br><span class="line">/dev/sda3       3.9T  705G  3.0T   19% /repos</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>大约 1T 的空间分配给 <code>/home</code> 路径,
也就是用户目录下的存储空间. 此外, 我还将 4T 的移动硬盘空间分配在
<code>/repos</code> 目录下, 目前是用来存放 svn git 以及 pt 做种资源.</p>
<p>工作站目前有两个用户, 一个是在主机上使用的 <code>qxh</code>,
另一个使用远程连接登录用的 <code>laptop</code>. 这两个用户对
<code>/repos</code> 都有读写执行权限.</p>
<p>我在自己的笔记本上使用用户 <code>laptop</code> 远程连接到工作站,
在工作站上也会 checkout 仓库中的文件进行开发, 这样的话,
我会在不同的用户中拉取同样的数据, 这样做会不会很冗余呢?</p>
<p>或者, 我现在先不需要考虑存储空间优化的事情, 先这样做,
等出现问题再来解决. 这样才能更好地理解解决问题的方案.</p>
<p>所以, 我现在空间管理的方案是:</p>
<ol type="1">
<li>自己开发的代码存放在 <code>/repos/svn</code> 或者
<code>/repos/git</code> 目录下,
会使用不同的用户拉取同一仓库的内容进行开发.</li>
<li>课题组的 svn 文件直接存放在 <code>/repos/gsvn</code> 目录下,
用户直接可以在该目录下进行开发.</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>配置 Typora 上传图片到网络图床</title>
    <url>/%E9%85%8D%E7%BD%AE-Typora-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E7%BD%91%E7%BB%9C%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>如果在 markdown 文档插入本地路径中的图片，那么移动 markdown
文档同时还必须考虑图片路径，否则图片总是无法正确显示。而配置网络中的图床，在
markdown
中只需要插入图片对应的网络链接即可，这在写网络博客很方便。图床一共需要配置三个位置：</p>
<span id="more"></span>
<ul>
<li>Github：设置图床仓库 <code>picgo-bed</code></li>
<li>PicGo：配置图床</li>
<li>Typora：偏好设置中图片选项选择使用 picgo-bed(app) 上传图片</li>
</ul>
<h2 id="github-设置">Github 设置</h2>
<p>Github 设置公共仓库，同时生成一个 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==">token<i class="fa fa-external-link-alt"></i></span> 用于 picgo
操作仓库。注意生成时只需要勾选 repo 选项即可，如图所示</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/image-20230908204919952.png" alt="choose-repo-only" style="zoom:50%;" /></p>
<p>如果设置 token 有效时长为有限的，那么需要记住 token
失效的时间，否则超出期限之后无法上传图片。</p>
<h2 id="picgo-设置">PicGo 设置</h2>
<p>我的设置如下，具体可参考 PicGo
手册：https://picgo.github.io/PicGo-Doc/zh/guide/</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/image-20230908205208599.png"
alt="image-20230908205208599" />
<figcaption aria-hidden="true">image-20230908205208599</figcaption>
</figure>
<blockquote>
<p><span class="github-emoji" data-alias="warning" style=""
data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span>
注意修改 “设定分支名” 选项中默认值 maste 为 github 主分支名称
“main”，</p>
</blockquote>
<p>为了增加上传图片的可读性，我还设置了如下功能</p>
<ul>
<li>上传图片前重命名</li>
<li>对图片加上时间戳</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/%E6%B5%8B%E8%AF%95%20picgo%20%E6%94%B9%E5%90%8D%E5%AD%97%E5%8A%9F%E8%83%BD.png"
alt="测试picgo改名字功能" />
<figcaption aria-hidden="true">测试picgo改名字功能</figcaption>
</figure>
<p>这样上传到 github 中得到的就是改过名字的图片了，可读性会强很多</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/github%20%E6%98%BE%E7%A4%BA%E6%94%B9%E8%BF%87%E5%90%8D%E5%AD%97%E7%9A%84%E5%9B%BE%E7%89%87%E5%90%8D%E7%A7%B0.png"
alt="github仓库截图" />
<figcaption aria-hidden="true">github仓库截图</figcaption>
</figure>
<h2 id="typora-配置">Typora 配置</h2>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/Typora%20%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE.png"
alt="typora 上传图片设置" />
<figcaption aria-hidden="true">typora 上传图片设置</figcaption>
</figure>
]]></content>
      <tags>
        <tag>typora</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux + apache2 配置 https 协议下的 SVN 仓库</title>
    <url>/Linux/Linux-%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E7%9A%84-SVN-%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>在 Windows 环境下，因为有 Tortoise SVN 和 Visual SVN Server
的存在，SVN 的操作难度降低了不少。但在 Linux
环境下，为了让用户更好地了解 SVN
的工作原理，<del>从而体验自立更生的快乐和自闭，</del>SVN
的种种操作，从建仓到创建用户到配置网络到 checkout 到 commit 到
update，全都是用命令行实现的。虽然一些编译器集成了版本控制的功能，但是要建立
SVN 仓库，据作者有限的知识，应该只能通过命令行创建。本文介绍的是如何在
Linux 环境下使用 apache2 配置 https 协议下的 SVN 仓库。</p>
<p>主要的参考文档是：<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLnVidW50dS5jb20vY29tbXVuaXR5L1N1YnZlcnNpb24=">Subversion<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9yYmdlZWsud29yZHByZXNzLmNvbS8yMDEyLzA5LzA5L3N2bi1zZXJ2ZXItb24tdWJ1bnR1LXdpdGgtaHR0cHMtYWNjZXNzLw==">ssl
配置<i class="fa fa-external-link-alt"></i></span> <span id="more"></span></p>
<h2 id="创建-apache2-用户-www-data">创建 apache2 用户 www-data</h2>
<p>apache2
是与网络相关的服务器，如果我们希望能在同一局域网下的不同设备操作同一个
SVN 仓库，就必须要配置它。首先我们需要创建一个与 SVN 相关的 group，和
apache2 的用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加组 subversion</span></span><br><span class="line">$ sudo addgroup subversion</span><br><span class="line"><span class="comment"># 在组 subversion 中添加用户 www-data (apache2 用户) 和 laptop</span></span><br><span class="line">$ sudo adduser www-data subversion</span><br><span class="line">$ sudo adduser laptop subversion</span><br></pre></td></tr></table></figure>
<p>创建的 <code>group</code> 以及所属用户可以查看
<code>/etc/group</code> 文件获知：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/group | grep subversion</span><br><span class="line">subversion<span class="github-emoji" alias="x" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">&#x274c;</span>1002:laptop,www-data</span><br></pre></td></tr></table></figure>
<h2 id="创建-svn-仓库">创建 SVN 仓库</h2>
<p>如果我们希望在 <code>/repos/svn</code> 创建一个关于 MATLAB
脚本的仓库，我们可以运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo svnadmin create /repos/svn/MATLAB</span><br></pre></td></tr></table></figure>
<p>塔嗒！一个 SVN
仓库就创建好了，是不是很简单？我们先接着往下做吧。因为我们是用
<code>sudo</code> 命令创建的仓库，所以该仓库所属用户为
<code>root</code>，如果我们想要读写执行该文档中的数据，每次都要通过
<code>sudo</code> 来操作，否则会遇到 <code>permission denied</code>
错误。我们将文件夹的用户修改为 <code>www-data</code>，组修改为
<code>subversion</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R www:data /repos/svn/MATLAB</span><br></pre></td></tr></table></figure>
<p>命令中的选项 <code>-R</code>
表示递归修改指定目录下的所有子文件夹以及文件所属用户和组。修改完之后，我们还需要修改
SVN 仓库的权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R g+rws /repos/svn/MATLAB</span><br></pre></td></tr></table></figure>
<p>命令表示，对文件夹 <code>MATLAB</code>
所属的用户<code>g</code>递归<code>-R</code>添加<code>+</code>读写执行<code>rws</code>权限。</p>
<h2 id="创建-svn-用户">创建 SVN 用户</h2>
<p>SVN 用户名以及密码存放在 <code>/etc/subversion/passwd</code>
文件中，第一次创建用户时使用命令 <code>htpasswd -c</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo htpasswd -c /etc/subversion/passwd laptop</span><br></pre></td></tr></table></figure>
<p>运行该命令之后，会要求输入用户密码并确认，输入的密码会加密保存在
<code>passwd</code> 中。</p>
<div class="note warning"><p><code>-c</code> 会覆盖原来的 <code>passwd</code> 文件！</p>
</div>
<p>如果继续添加用户，则运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo htpasswd /etc/subversion/passwd another_laptop</span><br></pre></td></tr></table></figure>
<p>或者重置原用户的密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo htpasswd /etc/subversion/passwd laptop</span><br></pre></td></tr></table></figure>
<h2 id="本地-checkout-svn-仓库">本地 checkout SVN 仓库</h2>
<p>现在，如果只需要在本地操作 SVN 的话，那么就可以通过
<code>file:///</code> 获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，命令中有三个反斜杠！</span></span><br><span class="line">svn co file:///repos/svn/MATLAB MATLAB</span><br><span class="line"><span class="comment"># 或者使用 localhost，此时命令有两个反斜杠</span></span><br><span class="line">svn co file://localhost/repos/svn/MATLAB myproject</span><br></pre></td></tr></table></figure>
<div class="note info"><p>checkout 本地的 SVN 仓库不需要用户名和密码。</p>
</div>
<h2 id="使用-webdav-获取-svn-仓库">使用 WebDAV 获取 SVN 仓库</h2>
<p>许多教程中要求安装的是libapache2-svn，但是对于新版本 Ubuntu
系统，安装 <span class="exturl" data-url="aHR0cHM6Ly9sYXVuY2hwYWQubmV0L3VidW50dS9iaW9uaWMvK3BhY2thZ2UvbGliYXBhY2hlMi1tb2Qtc3Zu">libapache2-mod-svn<i class="fa fa-external-link-alt"></i></span>
。</p>
<p>我们首先配置文件
<code>/etc/apache2/mods-available/dav_svn.conf</code>，其用途是配置
apache2 和 subversion 关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Location /svn&gt;</span><br><span class="line">   DAV svn</span><br><span class="line">   SVNParentPath /repos/svn</span><br><span class="line">   SVNListParentPath On</span><br><span class="line">   AuthType Basic</span><br><span class="line">   AuthName <span class="string">&quot;Subversion Repository&quot;</span></span><br><span class="line">   AuthUserFile /etc/subversion/passwd</span><br><span class="line">   Require valid-user</span><br><span class="line">&lt;/Location&gt;</span><br></pre></td></tr></table></figure>
<p>一些对于该文件的注释：</p>
<ul>
<li><code>Location</code> 中的路径 <code>/svn</code> 表示在 checkout SVN
仓库时，URL 的链接目录。该目录可以不等同于 SVN
仓库在服务器本地的存储路径。具体来说，如果按照如上配置文件，那么
checkout 的 SVN 路径应该是
<code>http://&lt;ip&gt;/svn/&lt;reposName&gt;</code>，不是<del><code>http://&lt;ip&gt;/repos/svn/&lt;reposName&gt;</code></del></li>
<li><code>SVNParentPath</code> 写入 SVN 仓库的上一级目录</li>
</ul>
<p>配置完成之后，需要重启 apache2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure>
<p>此时就可以使用 <code>http</code> 协议拉取 SVN 仓库了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">svn co http://hostname/svn/MATLAB --username laptop</span><br></pre></td></tr></table></figure>
<h2 id="配置-https-协议">配置 https 协议</h2>
<p>http
协议客户端与服务器之间的通讯是明文的，为了对通讯进行加密，我们使用 https
协议，其中多出的「s」表示 ssl。</p>
<p>首先我们需要打开 apache2 关于 ssl 的模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo a2enmod ssl</span><br></pre></td></tr></table></figure>
<p>然后我们需要生成自签名证书与密钥。创建目录
<code>/etc/apache2/ssl</code> ，运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo openssl req -new -x509 -days 365 -nodes -out /etc/apache2/ssl/apache.pem -keyout /etc/apache2/ssl/apache.key</span><br></pre></td></tr></table></figure>
<p>这时在目录 <code>/etc/apache2/ssl</code> 目录下会生成证书
<code>apache.pem</code> 和密钥 <code>apache.key</code>
两个文件。我们需要修改文件
<code>/etc/apache2/sites-available/default-ssl</code>
中自签名证书和密钥的路径为刚刚生成的两个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SSLCertificateFile /etc/apache2/ssl/apache.pem</span><br><span class="line">SSLCertificateKeyFile /etc/apache2/ssl/apache.key</span><br></pre></td></tr></table></figure>
<p>在之后我们还要修改 <code>/etc/apache2/ports.conf</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Listen 80</span><br><span class="line"></span><br><span class="line">&lt;IfModule ssl_module&gt;</span><br><span class="line">        NameVirtualHost *:443</span><br><span class="line">        Listen 443</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_gnutls.c&gt;</span><br><span class="line">        NameVirtualHost *:443</span><br><span class="line">        Listen 443</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>配置完这些文件之后，我们需要开启 apache2 虚拟主机 ssl（英文是：Enable
an apache2 virtual host on Debian-based OSes.）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo a2ensite default-ssl</span><br></pre></td></tr></table></figure>
<p>以及重启 apache2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure>
<p>这时，如果一切顺利的话，我们就可以通过 https 访问 SVN 仓库了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">svn co https://hostname/svn/MATLAB</span><br></pre></td></tr></table></figure>
<h2 id="防火墙允许-https">防火墙允许 https</h2>
<p>此时，我们在同一局域网下的客户端，因为服务器防火墙的阻拦，还是不可以
checkout SVN repos，这时需要在服务器中运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow https</span><br></pre></td></tr></table></figure>
<p>就能够允许客户端通过 https 协议访问 SVN 了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>svn</tag>
        <tag>apache2</tag>
        <tag>https</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 环境下快速打开 MATLAB 命令行</title>
    <url>/Linux/Linux-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80-MATLAB-%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<p>在 Ubuntu 22.04 中安装 MATLAB 之后，使用命令行运行 MATLAB 报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">laptop@qxh-Precision-7920-Tower:~$ matlab</span><br><span class="line">matlab：未找到命令</span><br></pre></td></tr></table></figure>
<p>这样每次运行 MATLAB，总是要到路径
<code>/usr/local/MATLAB/R2024a/bin</code> 下运行 <code>matlab</code>
脚本，并且再切换到原来的目录，很不方便。一种解决方案是使用
<code>alias</code> 命令，定义一条短语替代长的字符串命令：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Creates aliases -- words that are replaced by a <span class="built_in">command</span> string.</span><br><span class="line"> Aliases expire with the current shell session unless defined <span class="keyword">in</span> the shell<span class="string">&#x27;s configuration file, e.g. ~/.bashrc.</span></span><br></pre></td></tr></table></figure>
<p>根据 MATLAB 在工作站的安装目录，我定义的 <code>alias</code> 为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> matlab=<span class="string">&quot;/usr/local/MATLAB/R2024a/bin/matlab -nodesktop -nodisplay&quot;</span></span><br></pre></td></tr></table></figure>
<p>命令中 <code>-nodesktop</code> <code>-nodisplay</code> 表示不运行
MATLAB GUI 界面（不得不吐槽 MATLAB 在 Ubuntu 下的 GUI
太丑了）。运行这一行命令之后，如果运行
<code>alias</code>，就会发现我们定义的短语已经加载到当前的 bash
当中了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">laptop@qxh-Precision-7920-Tower:~$ <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">alias</span> alert=<span class="string">&#x27;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#x27;</span>\<span class="string">&#x27;&#x27;</span>s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//<span class="string">&#x27;\&#x27;</span><span class="string">&#x27;)&quot;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> matlab=<span class="string">&#x27;/usr/local/MATLAB/R2024a/bin/matlab -nodesktop -nodisplay&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此外还会看到许多我们并没有直接定义的
<code>alias</code>，这是因为它们是在 bash 配置文件
<code>~/.bashrc</code> 中预定义的，每次运行 bash
时都会将这些命令加载进来，所以，如果希望下一次运行 bash 可以直接运行
matlab，还需要将定义的 <code>alias</code> 加载到 <code>~/.bashrc</code>
中。</p>
<p>编辑完 bash 配置文件之后，运行 <code>source</code> 命令重新加载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>就可以了。</p>
<p>此外，如果脚本配置文件中定义了如下语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f ~/.bash_aliases ]; <span class="keyword">then</span></span><br><span class="line">	. ~/.bash_aliases</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>那么可以在外部文件中 <code>.bash_aliases</code> 写入自定义的
<code>aliases</code> 。</p>
<blockquote>
<p><strong>可能遇到的问题</strong></p>
<p>执行 <code>source ~/.bashrc</code>如果报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bashrc (line 6): &#x27;case&#x27; builtin not inside of switch block</span><br><span class="line">case $- in</span><br><span class="line">^</span><br><span class="line">from sourcing file .bashrc</span><br><span class="line">source: Error while reading file “.bashrc”</span><br></pre></td></tr></table></figure>
<p>那么这可能是因为在 Fish 环境下执行的，退出 Fish 之后就可以了。参考 <span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy8xMzkwMDAwL215LWJhc2hyYy1oYXMtYS10eXBvLWFuZC1pLWRvLW5vdC1rbm93LWhvdy10by1maXgtaXQ=">my
.bashrc has a typo and I do not know how to fix it<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>Linux</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 环境下安装 LaTeX</title>
    <url>/Linux/Ubuntu%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%20LaTeX/</url>
    <content><![CDATA[<p>如果想懒省事且有充足的安装空间的话，可以直接安装完全体版
<code>texlive-full</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install texlive-full</span><br></pre></td></tr></table></figure>
<p>这大概会占用 6 GB 的空间，但是好处是在未来写 <code>tex</code>
文档时，不会加载了奇奇怪怪的宏包之后编译出现 bug。<span id="more"></span></p>
<p>另外可以安装低配版的宏包，可是在 VSCode 编译时会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Recipe terminated with fatal error: spawn xelatex ENOENT</span><br></pre></td></tr></table></figure>
<p>查看网上的问题贴，这应该是因为找不到 <code>xelatex</code>
的安装路径。但如果装的是低配版的 texlive，我根本就不知道 Ubuntu
这货把它装在哪里了…</p>
<p>安装完 <code>texlive-full</code> 之后还有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I can&#x27;t find the format file `xelatex.fmt&#x27;!</span><br></pre></td></tr></table></figure>
<p>stackflow 上有相关的<span class="exturl" data-url="aHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIzMTY0L2ktY2FudC1maW5kLXRoZS1mb3JtYXQtZmlsZS14ZWxhdGV4LWZtdA==">帖子<i class="fa fa-external-link-alt"></i></span>，尝试最高赞的解决方案：</p>
<blockquote>
<p>try to run <code>sudo fmtutil-sys --all</code> which should create
all missing format files.</p>
</blockquote>
<p>没有奏效。第二个解决方案是重新安装 <code>xetex</code></p>
<blockquote>
<p>If you installed TeX from the repositories of your Linux system, you
could reinstall the xetex package from a repository.</p>
<ul>
<li>Redhat/Fedora: <code>sudo yum reinstall texlive-xetex</code></li>
<li>Debian/Ubuntu:
<code>sudo apt-get install --reinstall texlive-xetex</code></li>
</ul>
</blockquote>
<p>It works!</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux 快捷键索引</title>
    <url>/Linux/tmux-%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>tmux 之于命令窗口有点类似于浏览器之于网页, 可在 tmux
命令环境中操纵多个命令行窗口.<span id="more"></span></p>
<blockquote>
<p>注: tmux 的快捷键操作一般需要先按下 <kbd>Ctrl</kbd> +<kbd>b</kbd>.
文档中列出的快捷键清单默认没有写出这一组合键, 如不需要按下
<kbd>Ctrl</kbd> +<kbd>b</kbd>, 会在按键操作中特别说明.</p>
</blockquote>
<h2 id="面板-pano-操作">面板 (pano) 操作</h2>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><kbd>%</kbd></td>
<td>左右分裂当前面板</td>
</tr>
<tr class="even">
<td><kbd>“</kbd></td>
<td>上下分裂当前面板</td>
</tr>
<tr class="odd">
<td><kbd>方向键</kbd></td>
<td>导航面板</td>
</tr>
<tr class="even">
<td><kbd>Ctrl</kbd>+<kbd>d</kbd> (不按 <code>c-b</code>)</td>
<td>关闭当前面板</td>
</tr>
<tr class="odd">
<td><kbd>z</kbd></td>
<td>将 pano 放大为全屏, <br />再按一次缩小为原来的尺寸</td>
</tr>
<tr class="even">
<td><kbd>Ctrl</kbd>+<kbd>方向键</kbd></td>
<td>按照方向键方向调整 pano 尺寸</td>
</tr>
</tbody>
</table>
<h2 id="窗口-window-操作">窗口 (window) 操作</h2>
<table>
<colgroup>
<col style="width: 59%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><kbd>c</kbd></td>
<td>创建新窗口</td>
</tr>
<tr class="even">
<td><kbd>Ctrl</kbd>+<kbd>d</kbd> (不按 <code>c-b</code>)</td>
<td>关闭当前窗口</td>
</tr>
<tr class="odd">
<td><kbd>,</kbd></td>
<td>重命名当前窗口</td>
</tr>
<tr class="even">
<td><kbd>p</kbd></td>
<td>打开前一个窗口</td>
</tr>
<tr class="odd">
<td><kbd>n</kbd></td>
<td>打开后一个窗口</td>
</tr>
<tr class="even">
<td><kbd>num</kbd></td>
<td>打开编号 <kbd>num</kbd> 窗口</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>函数范数: 等价类的引入</title>
    <url>/math/%E5%87%BD%E6%95%B0%E8%8C%83%E6%95%B0-%E7%AD%89%E4%BB%B7%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<p>定义某一空间 <span class="math inline">\(V\)</span> 上的范数,
就是确定该空间上某一个非负实值映射 <span class="math inline">\(\| \cdot
\|\)</span>, 且该映射满足如下条件:</p>
<ol type="1">
<li>对任意的 <span class="math inline">\(v \in V\)</span>, <span
class="math inline">\(\| v \| \geq 0\)</span> 成立, 当且仅当 <span
class="math inline">\(v = 0\)</span> 时 <span class="math inline">\(\| v
\| = 0\)</span>;</li>
<li>对任意的 <span class="math inline">\(c \in \mathbb{R}\)</span> 和
<span class="math inline">\(v \in V\)</span>, <span
class="math inline">\(\|cv\| = |c| \|v\|\)</span>;</li>
<li>对任意的 <span class="math inline">\(u, v \in V\)</span>, 不等式
<span class="math inline">\(\|u+v\| \leq \|u\| + \|v\|\)</span>
成立.</li>
</ol>
<p>我现在想处理的是, 当空间的概念从有限维的向量空间,
拓展到无穷维的函数空间上时, 条件 1 中 <span class="math inline">\(v =
0\)</span> 的定义也需要加以推广, 以适应这个条件中 <span
class="math inline">\(v=0\)</span> 与 <span class="math inline">\(\|v\|
= 0\)</span> 的等价性. <span id="more"></span>我们以函数的 <span
class="math inline">\(1-\)</span>范数 <span class="math display">\[
\begin{equation}
  \|\cdot\| = \int|\cdot| \mathrm{d} \Omega
\end{equation}
\]</span> 以及定义在 <span class="math inline">\(\Omega = [-1,
1]\)</span> 上的两个函数 <span class="math inline">\(f(x)\)</span>,
<span class="math inline">\(g(x)\)</span> <span class="math display">\[
\begin{equation}
  f(x) = \begin{cases}
    1 \quad x \geq 0 \\
    0 \quad x &lt; 0
  \end{cases} \quad \quad
  g(x) = \begin{cases}
    1 \quad x &gt; 0 \\
    0 \quad x \leq 0
  \end{cases}
\end{equation}
\]</span> 为例. 函数 <span class="math inline">\(f-g\)</span> 的范数为
<span class="math display">\[
\begin{equation}
  \|f-g\| = \int_{-1}^{1} |f-g| \mathrm{d}x = 0,
\end{equation}
\]</span> 根据范数成立的条件 1, 则应该有 <span
class="math inline">\(f-g=0\)</span>, 或者等价的 <span
class="math inline">\(f=g\)</span>. 可是, 函数 <span
class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(g(x)\)</span> 在 <span
class="math inline">\(x=0\)</span> 处并不相等, 如果用数学味比较浓的表达,
那就是</p>
<div class="note success no-icon"><p>函数 <span class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(g(x)\)</span> 在区间 <span
class="math inline">\([-1,1]\)</span> 上并不是<strong>逐点</strong>
(pointwise) 相等的.</p>
</div>
<p>为了调和这一概念上的矛盾, 我们有 2 个思路: 1) 修改范数的定义; 2)
修改函数相等的定义.</p>
<p>对于第 1 个思路, 我们可以验证, 如果函数的范数定义为 <span
class="math display">\[
\|\cdot\| = \max_{-1 \leq x \leq 1} |\cdot|,
\]</span> 那么 <span class="math inline">\(\|f-g\|\)</span> 等价于 <span
class="math inline">\(f\)</span>, <span class="math inline">\(g\)</span>
逐点相等. 这实际是函数的 <span
class="math inline">\(\infty-\)</span>范数.</p>
<p>至于思路 2, 我们需要引入<strong>等价类</strong>的概念. 首先我们定义
<span class="math inline">\(V\)</span> 的子空间 <span
class="math inline">\(V^0\)</span> <span class="math display">\[
\begin{equation}
    V^0 = \{ v^0 \mid \| v^0 \|=0 \}.
\end{equation}
\]</span> 那么, 对任意 <span class="math inline">\(v \in V\)</span>,
<strong><span class="math inline">\(v\)</span> 与所有其它的函数 <span
class="math inline">\(v+v^0\)</span>, <span class="math inline">\(v^0
\in V^0\)</span> 共同组成同一个等价类</strong>.</p>
<p>这样, 我们重新定义相等 "<span class="math inline">\(=\)</span>"
的概念为</p>
<div class="note success no-icon"><p><span class="math inline">\(f=g\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(f\)</span> 与 <span
class="math inline">\(g\)</span> 属于同一个等价类, 即 <span
class="math inline">\(f = g+v^0\)</span>, <span
class="math inline">\(v^0 \in V^0\)</span>.</p>
</div>
<p>在上述相等的意义下, <span class="math inline">\(f\)</span> 与 <span
class="math inline">\(g\)</span> 并不一定是逐点相等的,
但只相差一个范数为 0 的函数 <span class="math inline">\(v^0\)</span>.
因此,</p>
<div class="note success no-icon"><p><span class="math inline">\(f=g\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(f = g+v^0\)</span>, <span
class="math inline">\(v^0 \in V^0\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(\| f-g \| = 0\)</span>.</p>
</div>
<p>这样我们就保证了范数定义中条件 1 的等价性.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>泛函分析</tag>
      </tags>
  </entry>
  <entry>
    <title>常微分方程唯一性定理的证明</title>
    <url>/math/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%94%AF%E4%B8%80%E6%80%A7%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<div class="note success no-icon"><h4 id="常微分方程的唯一性定理">常微分方程的唯一性定理</h4>
<p>对于如下常微分方程: <span class="math display">\[
\left\{
\begin{aligned}
  &amp;\dot{x} = f(t,x)\\
  &amp;x(0) = x_0
\end{aligned}
\right.
\]</span> 如果 <span class="math inline">\(f(t,x)\)</span> 关于 <span
class="math inline">\(x\)</span>​ <strong>Lipschitz 连续</strong>,
那么方程的解唯一.</p>
</div>
<span id="more"></span>
<p>Lipschitz 连续的必要性可以在方程证明中看到,
所以我们在证明过程中再提出 Lipschitz 条件的具体形式.</p>
<p>首先假设, 存在 <span class="math inline">\(x_1\)</span>, <span
class="math inline">\(x_2\)</span>
两个解满足命题中给出的微分方程和初值条件, 那么有 <span
class="math display">\[
\begin{aligned}
  x_1(t) = x_0 + \int_0^t f(s,x_1(s)) \mathrm{d} s\\
  x_2(t) = x_0 + \int_0^t f(s,x_2(s)) \mathrm{d} s
\end{aligned}
\]</span></p>
<p>两式相减, 两端取绝对值得到</p>
<p><span class="math display">\[
\vert x_1(t) - x_2(t) \vert = \int_0^t \vert  f(s,x_1(s)) - f(s,x_2(s))
\vert  \mathrm{d} s
\]</span></p>
<p>我们希望能得到对方程左端项的估计, 而 Lipschitz 条件要求, 对任意的
<span class="math inline">\(x,y\in \mathbb{R}_n\)</span>:</p>
<p><span class="math display">\[
\vert f(t,x) -f(t,y)  \vert \leq L |x-y|
\]</span></p>
<p><span class="math inline">\(L\)</span> 是 Lipschitz 常数, 不依赖于
<span class="math inline">\(x,y,t\)</span>. 这样我们就得到了关于 <span
class="math inline">\(r(t) = |x_1(t) - x_2(t)|\)</span> 的积分不等式:
<span class="math display">\[
r(t) \leq L \int_{0}^{t} r(s) \mathrm{d} s
\]</span></p>
<p>上述不等式又称 Gronwall 不等式, 是对 <span
class="math inline">\(r(t)\)</span> 最坏情况的指数估计. 如果我们有</p>
<p><span class="math display">\[
f(t) \leq C_0 + \int_0^t f(s) g(s) \mathrm{d} s, \quad C_0 \geq 0, f(t),
g(t) \geq 0
\]</span></p>
<p>那么 <span class="math display">\[
f(t) \leq C_0 e^{\int_0^t g(s) \mathrm{d} s}
\]</span></p>
<p>在我们的证明中, <span class="math inline">\(C_0 = 0\)</span>, 所以
<span class="math display">\[
0 \leq r(t) \leq 0
\]</span></p>
<p>这就得到 <span class="math inline">\(r(t) \equiv 0\)</span>, 所以
<span class="math inline">\(x_1(t) \equiv x_2(t)\)</span>.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>常微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title>数学相关文档中不同类型的等号释义</title>
    <url>/math/%E6%95%B0%E5%AD%A6%E6%96%87%E6%A1%A3%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AD%89%E5%8F%B7%E9%87%8A%E4%B9%89/</url>
    <content><![CDATA[<p>我在数学相关文档的编写中，对三种特殊的等号作如下释义：</p>
<h2 id="恒等于-equiv">恒等于 <span
class="math inline">\(\equiv\)</span></h2>
<p>LaTeX 表达式：<code>\equiv</code></p>
<p>用在分析语言当中，左侧为函数，右侧为常数，表示等号左侧的函数在定义域上的取值恒等于右侧的常数。例如</p>
<blockquote>
<p>三角恒等式 <span class="math display">\[
\cos^2 x + \sin^2 x \equiv 1
\]</span></p>
</blockquote>
<span id="more"></span>
<h2 id="定义-triangleq">定义 <span
class="math inline">\(\triangleq\)</span></h2>
<p>LaTeX 表达式：<code>\triangleq</code></p>
<p>定义新的符号，左右两侧表达式中会出现新的符号，并总能通过已定义的符号表示出来，例如</p>
<blockquote>
<p>已知物体质量 <span class="math inline">\(m\)</span>，加速度 <span
class="math inline">\(a\)</span>，我们定义作用在物体上的力 <span
class="math inline">\(F\)</span> 为 <span class="math display">\[
F \triangleq ma
\]</span></p>
</blockquote>
<p>符号 <span class="math inline">\(\triangleq\)</span>
是左右对称的，所以 <span class="math inline">\(\triangleq\)</span>
左侧不一定总是为新定义的变量，例如</p>
<blockquote>
<p>材料中的应变 <span class="math inline">\(\varepsilon\)</span>
是弹性应变 <span class="math inline">\(e\)</span> 与本征应变 <span
class="math inline">\(\mu\)</span> 之和： <span class="math display">\[
\varepsilon \triangleq e + \mu
\]</span></p>
</blockquote>
<h2 id="赋值">赋值 <span class="math inline">\(:=\)</span>​</h2>
<p>LaTeX 表达式：<code>\coloneqq</code> （依赖宏包
<code>mathtools</code>）</p>
<p>在旧的文档中我用来定义变量，与 Computational Inelasticity
中的符号一致。现在我用符号 <span class="math inline">\(:=\)</span>
进行赋值，左侧为变量名。右侧为具体值，例如</p>
<blockquote>
<p>取测试函数（test function）为常数，也即 <span
class="math inline">\(v_{i,j}(y) := v_{i,j}\)</span></p>
</blockquote>
<h2 id="参考文档">参考文档</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xODIxMDEvYXBwcm9wcmlhdGUtbm90YXRpb24tZXF1aXYtdmVyc3Vz">Appropriate
Notation: ≡ versus :=<i class="fa fa-external-link-alt"></i></span> 给出了为什么我用 <span
class="math inline">\(\triangleq\)</span> 取代 <span
class="math inline">\(:=\)</span> 作为定义符号的原因</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1YWxzX3NpZ24=">Equal sign<i class="fa fa-external-link-alt"></i></span>
给出了等号的历史来源，以及所有可能见到的表示左右两端存在某种关系的符号，比如
<span class="math inline">\(\approx\)</span>，<span
class="math inline">\(\cong\)</span> ……</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xMDU4NTk2L2luLXBsYWluLWxhbmd1YWdlLXdoYXRzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tdHdvLXRoaW5ncy10aGF0LWFyZS1lcXVpdmFsZW50">In
plain language, what's the difference between two things that are
'equivalent', 'equal', and 'identical'?<i class="fa fa-external-link-alt"></i></span> 给出了 <span
class="math inline">\(\equiv\)</span> 在数论中的含义</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>逻辑命题</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑命题视角下的极限 连续与一致连续</title>
    <url>/math/%E9%80%BB%E8%BE%91%E5%91%BD%E9%A2%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%9E%81%E9%99%90-%E8%BF%9E%E7%BB%AD%E4%B8%8E%E4%B8%80%E8%87%B4%E8%BF%9E%E7%BB%AD/</url>
    <content><![CDATA[<h3 id="极限的定义-以及否定形式">极限的定义, 以及否定形式</h3>
<p>关于序列 <span class="math inline">\(\{a_n\}\)</span>
的极限命题为:</p>
<blockquote>
<p>对任意的 <span class="math inline">\(\varepsilon &gt; 0\)</span>,
存在 <span class="math inline">\(N \in \mathbb{N}\)</span>, 当 <span
class="math inline">\(n&gt;N\)</span> 时, <span
class="math inline">\(|a_n - a| &lt; \varepsilon\)</span></p>
</blockquote>
<p>我们用<strong>含参数的陈述</strong>表示上述命题的后半段:</p>
<p><span class="math display">\[
S(N, \varepsilon): n &gt; N \Rightarrow |a_n - a| &lt; \varepsilon
\]</span></p>
<span id="more"></span>
<p>当给定 <span class="math inline">\((N, \varepsilon)\)</span> 时,
就可以确定该命题的真伪.
极限定义就是对上述含参数的陈述添加量词进行修饰:</p>
<p><span class="math display">\[
a_n \rightarrow a \Leftrightarrow \forall \varepsilon &gt; 0, \exists N
\in \mathbb{N} \quad n &gt; N \Rightarrow |a_n - a| &lt; \varepsilon
\]</span></p>
<p>注意, <span class="math inline">\(\forall \varepsilon &gt;0\)</span>
 与 <span class="math inline">\(\exists N \in \mathbb{N}\)</span>
不能交换顺序, 也即含量词陈述的命题, 量词的顺序不能随意改变, 例如,
如果修改成</p>
<p><span class="math display">\[
\exists N \in \mathbb{N}, \forall \varepsilon &gt; 0 \quad n &gt; N
\Rightarrow |a_n - a| &lt; \varepsilon
\]</span></p>
<p>那么只有常数序列才能存在极限, 这样的定义就是平凡的了.</p>
<p>注意到, 含量词的命题可以等价为:</p>
<ul>
<li><p><span class="math inline">\(\forall x \in X \quad S(x)
\Longleftrightarrow \bigwedge_{x \in X} S(x)\)</span>;</p></li>
<li><p><span class="math inline">\(\exists x \in X \quad S(x)
\Longleftrightarrow \bigvee_{x \in X} S(x)\)</span>.</p></li>
</ul>
<p>式中, <span class="math inline">\(\wedge\)</span> 表示命题关系“与”
(AND), <span class="math inline">\(\vee\)</span> 表示命题关系“或”(OR).
当否定含量词的命题时, 根据 de Morgan 定律: <span class="math display">\[
(B~\cup~C)^{\prime} = B^{\prime}~\cap~C^{\prime}\\
(B~\cap~C)^{\prime} = B^{\prime}~\cup~C^{\prime}
\]</span></p>
<ul>
<li><p><span class="math inline">\(\sim(\forall x \in X \quad S(x))
\Longleftrightarrow \bigvee_{x \in X}\sim S(x) \Longleftrightarrow
\exists x \in X \quad \sim S(x)\)</span>;</p></li>
<li><p><span class="math inline">\(\sim(\exists x \in X \quad S(x))
\Longleftrightarrow \bigwedge_{x \in X} \sim S(x)\Longleftrightarrow
\forall x \in X \quad \sim S(x)\)</span>.</p></li>
</ul>
<p>注意到, 含参数陈述命题的取值集合 <span
class="math inline">\(X\)</span> 不会发生改变 (比如取该集合的补集).
由此我们可以得到极限命题的否定形式:</p>
<p><span class="math display">\[
\exists \varepsilon &gt; 0, \forall N \in \mathbb{N} \quad n &gt; N
\wedge |a_n - a| \geq \varepsilon
\]</span></p>
<p>该命题后半部分可以合并为:</p>
<p><span class="math display">\[
\exists \varepsilon &gt; 0, \forall N \in \mathbb{N} \quad |a_N - a|
\geq \varepsilon
\]</span></p>
<h3 id="连续与一致连续">连续与一致连续</h3>
<p>我们用逻辑语言定义一致连续: 给定函数 <span class="math inline">\(f: A
\mapsto \mathbb{R}^m\)</span>, 定义域 <span class="math inline">\(A
\subset \mathbb{R}^n\)</span> :</p>
<p><span class="math display">\[
\forall \varepsilon &gt; 0, \textcolor{red}{\exists \delta &gt; 0},
\forall y \in A, \forall x \in A \quad \|x-y\|\leq\delta \Rightarrow
\|f(x) - f(y)\| \leq \varepsilon
\]</span></p>
<p>而函数 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(A\)</span> 上连续的定义为</p>
<p><span class="math display">\[
\forall \varepsilon &gt; 0, \forall y \in A, \textcolor{red}{\exists
\delta &gt; 0}, \forall x \in A \quad \|x-y\|\leq\delta \Rightarrow
\|f(x) - f(y)\| \leq \varepsilon
\]</span></p>
<p>第二个定义中, 存在量词变量 <span
class="math inline">\(\delta\)</span> 的选择依赖于之前全称量词变量 <span
class="math inline">\(y\)</span>,
这一点改变使得第一个定义和第二个定义并不是等价的
(虽然看起来只是命题叙述的顺序发生了变化). 事实上,
第一个命题蕴含第二个命题:</p>
<p><span class="math display">\[
f~\text{一致连续} \Rightarrow f~\text{连续}
\]</span></p>
<p>证明上述问题是乏味的, 甚至像是在玩弄文字游戏, 我们不妨做一点别的事情,
比如, 将定义连续的命题中的存在量词 <span class="math inline">\(\exists
\delta &gt; 0\)</span> 继续后移:</p>
<p><span class="math display">\[
\forall \varepsilon &gt; 0, \forall y \in A, \forall x \in A,
\textcolor{red}{\exists \delta &gt; 0} \quad \|x-y\|\leq\delta
\Rightarrow \|f(x) - f(y)\| \leq \varepsilon
\]</span></p>
<p>该命题本身就构成了重言式, 也就是说, 该命题一直为 true. 证明过程如下:
对任意给定的 <span class="math inline">\(\varepsilon, x, y\)</span>, 取
<span class="math inline">\(\delta &gt; \|x-y\|\)</span>, 根据蕴含命题
<span class="math inline">\(p \Rightarrow q\)</span> 的真值表, 若 <span
class="math inline">\(p\)</span> 为 false, 则 <span
class="math inline">\(p \Rightarrow q\)</span> 恒为 true, 无论 <span
class="math inline">\(q\)</span> 怎样取值. 因此, <span
class="math inline">\(\|x-y\|\leq\delta \Rightarrow \|f(x) - f(y)\| \leq
\varepsilon\)</span> 恒为 true.</p>
<p>假如我们将第三个定义称为”弱连续”, 那么, 根据上述论证,
所有的函数都是”弱连续”的, 因此, “弱连续“
就不能够将某一类函数与其它函数区分开. “弱连续“ 的定义是平凡的.</p>
<p>现在, 如果我们将存在量词移到命题的最前端:</p>
<p><span class="math display">\[
\textcolor{red}{\exists \delta &gt; 0}, \forall \varepsilon &gt; 0,
\forall y \in A, \forall x \in A \quad \|x-y\|\leq\delta \Rightarrow
\|f(x) - f(y)\| \leq \varepsilon
\]</span></p>
<p>并称满足这个定义的函数为”强一致收敛”函数, 可以看到,
“强一致收敛“函数只能是常值函数, 因此也是一致收敛函数.综上,
我们有上述关于连续性命题的强弱关系: <span class="math display">\[
f~\text{强一致连续} \Rightarrow f~\text{一致连续} \Rightarrow
f~\text{连续} \Rightarrow f~\text{弱连续}
\]</span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>逻辑命题</tag>
        <tag>分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Voigt 表示方法</title>
    <url>/mechanics/Voigt-%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="voigt-映射定义">Voigt 映射定义</h2>
<p>二阶张量 <span class="math inline">\(\mathbf{A}\)</span> 在 <span
class="math inline">\(\mathbb{R}^3\)</span> 空间的基底下可以表示为矩阵
<span class="math inline">\(\{A_{ij}\} \in \mathbb{R}^3 \times
\mathbb{R}^3\)</span>. 如果张量 <span
class="math inline">\(\mathbf{A}\)</span> 为对称张量, 那么矩阵 <span
class="math inline">\(\{A_{ij}\}\)</span> 同样为对称矩阵,
因此只需要一个向量 <span class="math inline">\(\mathrm{vec}~A \in
\mathbb{R}^6\)</span>, 就可以完全保存二阶对称张量 <span
class="math inline">\(\mathbf{A}\)</span> 的信息. 我们定义 Voigt 映射
<span class="math inline">\([\cdot]: \mathbb{R}^3 \times \mathbb{R}^3
\mapsto \mathbb{R}^6\)</span> <span class="math display">\[
\begin{aligned}[]
[A]: ~
&amp;[A]_{1} = A_{11}, \quad
[A]_{2} = A_{22}, \quad
[A]_{3} = A_{33}, \quad \\
&amp;[A]_{4} = A_{23}, \quad
[A]_{5} = A_{13}, \quad
[A]_{6} = A_{12}  \quad \\
\end{aligned}
\]</span> 对于四阶张量, Voigt 映射会将该张量映射为一个 6x6 的矩阵.
如果该张量具有<strong>次对称性</strong>, 那么在 Voigt 映射下,
<strong>不会丢失掉该张量任何一个分量的信息</strong>. 特别的,
如果四阶张量还具有<strong>主对称性</strong>, 那么使用 Voigt
映射之后得到的矩阵是<strong>对称矩阵.</strong> <span id="more"></span></p>
<div class="note primary no-icon"><h4 id="四阶弹性模量张量-l_ijkl-的-voigt-表示">四阶弹性模量张量 <span
class="math inline">\(L_{ijkl}\)</span> 的 Voigt 表示</h4>
<p>对于各向同性材料, 四阶弹性模量张量 <span
class="math inline">\(L_{ijkl}\)</span> 可以用 Lame 系数表示为 <span
class="math display">\[
L_{ijkl} = \lambda \delta_{ij} \delta_{kl}
                       + \mu \delta_{ik} \delta_{jl}
                       + \mu \delta_{il} \delta_{jk},
\]</span> 式中的 Kronecker 记号可以用 Voigt 映射为矩阵 <span
class="math display">\[
[\delta_{ij}\delta_{kl}] = \begin{pmatrix}
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
      \end{pmatrix}, \quad
[\delta_{ik}\delta_{jl}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}, \quad
[\delta_{il}\delta_{jl}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}.
\]</span></p>
<p>所以 <span class="math inline">\(L_{ijkl}\)</span> 写成 <span
class="math display">\[
\begin{aligned}[]
[{L}_{ijkl}] &amp;= \lambda \begin{pmatrix}
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
      \end{pmatrix}
+ \mu \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}
+ \mu \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}  \\
&amp;= \begin{pmatrix}
      \lambda+2\mu &amp; \lambda &amp; \lambda &amp; 0 &amp; 0 &amp; 0
\\
      \lambda &amp; \lambda+2\mu &amp; \lambda &amp; 0 &amp; 0 &amp; 0
\\
      \lambda &amp; \lambda &amp; \lambda+2\mu &amp; 0 &amp; 0 &amp; 0
\\
      0 &amp; 0 &amp; 0 &amp; \mu &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; \mu &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \mu
    \end{pmatrix}
\end{aligned}
\]</span></p>
</div>
<h2 id="voigt-映射下的张量运算">Voigt 映射下的张量运算</h2>
<p>我们现在关心的是, 在 Voigt 映射下, 张量运算将会转变为怎样的矩阵运算?
在下文的例子中, 如果不特别说明, 我们默认四阶张量具有次对称性,
二阶张量具有对称性.</p>
<h3 id="张量的线性组合">张量的线性组合</h3>
<p>Voigt 映射是线性的，因此，对任意张量 <span class="math display">\[
[\lambda A + \mu B] = \lambda [A] + \mu [B]
\]</span></p>
<h3 id="张量的双点积运算">张量的双点积运算</h3>
<p>给定四阶张量 <span class="math inline">\(\mathbb{L}\)</span>,
二阶张量 <span class="math inline">\(\epsilon\)</span>,
双点积得到另一个二阶张量 <span class="math inline">\(\sigma\)</span> :
<span class="math display">\[
\sigma_{ij} = \mathbb{L} : \epsilon = L_{ijkl} \epsilon_{kl}
\]</span> 我们考虑张量分量 <span
class="math inline">\(\sigma_{11}\)</span>, 也是 Voigt 形式下向量 <span
class="math inline">\([\sigma]\)</span> 的第一个分量 <span
class="math inline">\([\sigma]_{1}\)</span> <span
class="math display">\[
\begin{aligned}
\sigma_{11} &amp;= [\sigma]_{1} = L_{11kl} \epsilon_{kl} \\
&amp;= L_{1111} \epsilon_{11} + L_{1122} \epsilon_{22} + L_{1133}
\epsilon_{33} \\
&amp;+ L_{1123} \epsilon_{23} + L_{1113} \epsilon_{13} + L_{1112}
\epsilon_{12} \\
&amp;+ L_{1132} \epsilon_{32} + L_{1131} \epsilon_{31} + L_{1121}
\epsilon_{21}
\end{aligned}
\]</span> 由于张量的对称性, 我们有 <span class="math display">\[
L_{1123} \epsilon_{23} = L_{1132} \epsilon_{32}, \quad
L_{1113} \epsilon_{13} = L_{1131} \epsilon_{31}, \quad
L_{1112} \epsilon_{12} = L_{1121} \epsilon_{21}
\]</span> 所以 <span class="math display">\[
\begin{aligned}[]
[\sigma]_{1} &amp;= L_{1111} \epsilon_{11} + L_{1122} \epsilon_{22} +
L_{1133} \epsilon_{33}
+ 2L_{1123} \epsilon_{23} + 2L_{1113} \epsilon_{13} + 2L_{1112}
\epsilon_{12} \\
&amp;= [\mathbb{L}]_{11} [\epsilon]_{1}  + [\mathbb{L}]_{12}
[\epsilon]_{2}  + [\mathbb{L}]_{13} [\epsilon]_{3}
+ 2[\mathbb{L}]_{14} [\epsilon]_{4} + 2[\mathbb{L}]_{15} [\epsilon]_{5}
+ 2[\mathbb{L}]_{16} [\epsilon]_{6}
\end{aligned}
\]</span> 因此在使用 Voigt 记法时, 四阶张量与二阶张量之间的双点积,
如果写成矩阵形式的话, 并不是 <span class="math display">\[
[\sigma] \neq [\mathbb{L}] [\epsilon],
\]</span> 而是 <span class="math display">\[
[\sigma] = [\mathbb{L}] [:] [\epsilon]
\]</span> 式中, <span class="math inline">\([:]\)</span>​ 定义为 6x6
常数矩阵: <span class="math display">\[
[:] := \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2
\end{pmatrix}
\]</span> 在本文中使用四阶和二阶张量的双点积举例,
同样也可以推广到四阶与四阶张量之间, 二阶与二阶张量之间的双点积运算.
例如, 二阶张量之间的点积写成矩阵形式为: <span class="math display">\[
\sigma : \epsilon = [\sigma][:][\epsilon]
\]</span></p>
<p>以及四阶张量之间的双点积运算: <span class="math display">\[
\mathbb{L} : \mathbb{I} = [\mathbb{L}] [:] [\mathbb{I}]
\]</span></p>
<div class="note primary no-icon"><h4 id="四阶单位张量的矩阵形式">四阶单位张量的矩阵形式</h4>
<p>对任意的四阶张量, 有 <span class="math display">\[
\mathbb{L} : \mathbb{I} = \mathbb{L}
\]</span> 两边作 Voigt 变换得到 <span class="math display">\[
[\mathbb{L}] [:] [\mathbb{I}] = [\mathbb{I}]
\]</span> 我们选取某个 <span class="math inline">\(\mathbb{L}\)</span>,
使得它在 Voigt 映射为 6x6 单位矩阵 <span
class="math inline">\([I]\)</span>​ <span class="math display">\[
[\mathbb{L}] := [I]
\]</span> 所以 <span class="math display">\[
[:] [\mathbb{I}] = [I]
\]</span> 也即 <span class="math display">\[
[\mathbb{I}] = [:]^{-1} = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0.5 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.5 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.5
\end{pmatrix}
\]</span></p>
</div>
<h3 id="四阶张量求逆">四阶张量求逆</h3>
<p>如果四阶张量 <span class="math inline">\(\mathbb{L}\)</span> <span
class="math inline">\(\mathbb{M}\)</span> 满足 <span
class="math display">\[
\mathbb{L} : \mathbb{M} = \mathbb{M} : \mathbb{L} = \mathbb{I}, \quad
\text{or} \quad
L_{ijkl} M_{klmn} = I_{ijmn}
\]</span> 那么称张量 <span class="math inline">\(\mathbb{M}\)</span>
为张量 <span class="math inline">\(\mathbb{L}\)</span> 的逆: <span
class="math display">\[
\mathbb{L}^{-1} \triangleq \mathbb{M}
\]</span> 在 Voigt 映射下, 有 <span class="math display">\[
[\mathbb{L}] [:] [\mathbb{M}] = [\mathbb{M}] [:] [\mathbb{L}] =
[\mathbb{I}]
\]</span> 所以 <span class="math display">\[
[\mathbb{M}] = [:]^{-1} [\mathbb{L}]^{-1} [\mathbb{I}] = ([:]
[\mathbb{L}] [:])^{-1}
\]</span></p>
<h3 id="张量的单点积运算">张量的单点积运算</h3>
<p>张量的单点积运算很难用 Voigt 记法写成规范的矩阵运算,
因此在这里只给出分量之间的关系. 给定两个二阶张量 <span
class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>
, 单点积运算得到另一个二阶张量 <span class="math inline">\(C\)</span>:
<span class="math display">\[
C_{ik} = A \cdot B = A_{ij} B_{jk}
\]</span> 我们考虑张量分量 <span class="math inline">\(C_{11}\)</span>,
也是 <span class="math inline">\([C]_1\)</span> : <span
class="math display">\[
C_{11} = A_{1j} B_{j1} = A_{11} B_{11} + A_{12} B_{21} + A_{13} B_{31}
\]</span> 再根据张量的对称性, 我们得到 <span class="math display">\[
\begin{aligned}[]
[C]_{1} = [A]_1 [B]_1 + [A]_5 [B]_5 + [A]_6 [B]_6\\
[C]_{2} = [A]_2 [B]_2 + [A]_4 [B]_4 + [A]_6 [B]_6\\
[C]_{3} = [A]_3 [B]_3 + [A]_4 [B]_4 + [A]_5 [B]_5
\end{aligned}
\]</span> 以及 <span class="math display">\[
\begin{aligned}[]
[C]_{4} = [A]_6 [B]_5 + [A]_2 [B]_4 + [A]_4 [B]_3\\
[C]_{5} = [A]_1 [B]_5 + [A]_6 [B]_4 + [A]_5 [B]_3\\
[C]_{6} = [A]_1 [B]_6 + [A]_6 [B]_2 + [A]_5 [B]_4
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>张量运算</tag>
      </tags>
  </entry>
  <entry>
    <title>使用有限元方法求解单胞方程</title>
    <url>/mechanics/%E4%BD%BF%E7%94%A8%E6%9C%89%E9%99%90%E5%85%83%E6%96%B9%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E5%BC%B9%E6%80%A7%E5%8D%95%E8%83%9E%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="单胞方程的-statement">单胞方程的 statement</h2>
<h3 id="单胞方程张量场-e_klmn-求解">单胞方程张量场 <span
class="math inline">\(E_{kl}^{(mn)}\)</span> 求解</h3>
<p>在三维情景, 线弹性条件下, 单胞方程的弱形式为: <span
class="math display">\[
\int_{Y} L_{ijkl} \frac{\partial H_k^{(mn)}}{\partial y_l}
\frac{\partial v_i}{\partial y_j} \mathrm{d} Y
= -\int_{Y} L_{ij(mn)} \frac{\partial v_i}{\partial y_j} \mathrm{d} Y.
\tag{1}
\]</span></p>
<p>场变量 <span class="math inline">\(H_k^{(mn)}\)</span>
满足周期性边界条件, <span id="more"></span>也即</p>
<p><span class="math display">\[
H_k^{(mn)}(y) = H_k^{(mn)}(y + kl).
\]</span></p>
<p>然而, 上述周期性边界条件只是提供了边界节点的约束条件,
还不能唯一确定解. Fish 书中提供两种定解的方式:</p>
<p><span class="math display">\[
(1) \quad H_k^{(mn)} := 0, \text{ on } \partial
\Theta^{\mathrm{vert}};\\
(2) \quad \int_{\Theta} H_k^{(mn)} \mathrm{d} \Theta := 0.
\]</span></p>
<div class="note info"><p>在单胞方程中, <span class="math inline">\((mn)\)</span>
是对称的自由指标, 使用 <span class="math inline">\(()\)</span> 标注指标
<span class="math inline">\(mn\)</span>
是因为该组指标表示单胞可能的变形模式 (对于三维问题共有 6 种模式,
每一种模式确定一组偏微分方程), 而不是一般意义下的 Euclidean
空间中的坐标分量.</p>
</div>
<p>求解出 <span class="math inline">\(H_{k}^{(mn)}\)</span> 后,
可得到均质化的弹性模量为: <span class="math display">\[
L_{ij(mn)}^{\mathrm{hom}} = \frac{1}{|Y|} \int_{Y} L_{ij(mn)} +
L_{ijkl}H_{k,l}^{(mn)} \mathrm{d} Y.
\tag{2}
\]</span></p>
<p>式中，<span class="math inline">\(H_{k,l}^{(mn)} = \frac{\partial
H_{k}^{(mn)}}{\partial y_l}\)</span>​ 。如果记 <span
class="math display">\[
E_{kl}^{(mn)} \triangleq I_{kl}^{(mn)} + H_{k,l}^{(mn)}
\]</span> 式中, <span
class="math inline">\(I_{kl}^{(mn)}=\frac{1}{2}(\delta_{km}\delta_{ln}+\delta_{kn}\delta_{lm})\)</span>.
式（2）可以表示为 <span class="math display">\[
L_{ij(mn)}^{\mathrm{hom}} = \frac{1}{|Y|} \int_{Y} L_{ijkl}E_{kl}^{(mn)}
\mathrm{d} Y.
\]</span></p>
<h3 id="reduced-order-单胞方程张量场-p_klmn-求解">Reduced Order
单胞方程张量场 <span class="math inline">\(P_{kl}^{mn}\)</span>
求解</h3>
<p>降阶多尺度的单胞方程弱形式为 <span class="math display">\[
\int_{Y} L_{ijkl}(y)  P_{kl}^{mn(\alpha)}(y) v_{i,j}(y) ~\mathrm{d}y
= \int_{Y} L_{ijmn}(y) \chi^{(\alpha)}(y) v_{i,j}(y) ~\mathrm{d}y
\quad \alpha=1,2, \ldots,N
\tag{3}
\]</span></p>
<p>方程（1）（3）的区别在于右端项的积分区域，以及正负号。式（3）右端对
partition
求和，可以得到式（1）的右端项（相差一个负号）。方程（3）的边界条件与（1）相同。</p>
<h2 id="单胞方程的有限元列式">单胞方程的有限元列式</h2>
<p>将单胞方程中的张量分量表示为矩阵形式:</p>
<p><span class="math display">\[
L_{ijkl}(y) \rightarrow [D](y), \quad
\frac{\partial v_i}{\partial y_j} \rightarrow [B][v], \quad
\frac{\partial H_k^{(mn)}}{\partial y_l} \rightarrow [B][u]^{(mn)},
\quad
L_{ij(mn)}(y) \rightarrow [D](y) [\varepsilon]^{(mn)}.
\]</span></p>
<p>式中, <span class="math inline">\(mn =
\{11,22,33,23,13,12\}\)</span>. 为方便表示向量分量, 我们使用 Voigt 映射
<span class="math inline">\((\cdot)\)</span> 将二元组 <span
class="math inline">\((mn)\)</span> 映射为一元有序数列 <span
class="math inline">\(\{ 1,2,3,4,5,6 \}\)</span>. <span
class="math inline">\([\varepsilon]^{(mn)}\)</span> 为 <span
class="math inline">\(6\times 1\)</span> 向量, 对应 <span
class="math inline">\((mn)\)</span> 分量为 1, 其它分量为 0. 例如, 当
<span class="math inline">\(mn=11\)</span> 时,
对应的有限元矩阵方程为:</p>
<p><span class="math display">\[
\int_{Y} [B]^{T} [D](y) [B] \mathrm{d} Y [u]^{(11)} = \int_{Y}
[B]^{T}[D](y) [\varepsilon]^{(11)} \mathrm{d} Y.
\]</span></p>
<p>式中, <span class="math inline">\([\varepsilon]^{(11)} =
[1,0,0,0,0,0]^{T}\)</span>. 记</p>
<p><span class="math display">\[
\int_{Y} [B]^{T} [D](y) [B] \mathrm{d} Y = [K], \quad
\int_{Y} [B]^{T}[D](y) [\varepsilon]^{(11)} \mathrm{d} Y = [f]^{(11)},
\]</span></p>
<p>则有线性方程组</p>
<p><span class="math display">\[
[K][u]^{(11)} = [f]^{(11)},
\]</span></p>
<p>以及周期性边界条件对边界节点的约束方程</p>
<p><span class="math display">\[
[C_{\mathrm{per}}][u]^{(11)} = [0]
\]</span></p>
<p>和单位平均应变导致的位移边界条件</p>
<p><span class="math display">\[
[C_{\mathrm{disp}}]^{(11)}[u]^{(11)} = [g].
\]</span></p>
<p>注意, 约束矩阵 <span
class="math inline">\([C_{\mathrm{per}}]\)</span> 与变形模式 <span
class="math inline">\(mn\)</span> 无关.</p>
<p>求解 6 组变形模式下的有限元方程, 得到 <span
class="math inline">\([u]^{(mn)}\)</span> 后,
再代入到均质化弹性张量方程中:</p>
<p><span class="math display">\[
[D^{\mathrm{hom}}] [\varepsilon]^{(mn)} = \frac{1}{|Y|} \int_{Y} [D](y)
[\varepsilon]^{(mn)} - [D](y)[B][u]^{(mn)} \mathrm{d} Y.
\]</span></p>
<p>若记</p>
<p><span class="math display">\[
[\overline{D}] = \frac{1}{|Y|} \int_{Y} [D](y)\mathrm{d} Y, \quad
[\sigma]^{(mn)} = \frac{1}{|Y|} \int_{Y} [D](y)[B] \mathrm{d}
Y~[u]^{(mn)},
\]</span></p>
<p>则有</p>
<p><span class="math display">\[
[D^{\mathrm{hom}}] = [\overline{D}] - [\sigma^{(11)}, \sigma^{(22)},
\sigma^{(33)}, \sigma^{(23)}, \sigma^{(13)}, \sigma^{(12)}].
\]</span></p>
<p>式中, <span class="math inline">\(\sigma^{(mn)}\)</span>
是由有限元求解的位移场 <span class="math inline">\(u^{(mn)}\)</span>
计算得到应力场, 再求体平均得到. 对于只有纤维和基体两相材料的单胞,
如果它们的体积分数分别为 <span class="math inline">\(c_{f}\)</span> 和
<span class="math inline">\(c_{m}\)</span>, 体平均材料矩阵 <span
class="math inline">\([\overline{D}]\)</span> 等于</p>
<p><span class="math display">\[
[\overline{D}] = \frac{1}{|Y|} \int_{Y} [D](y)\mathrm{d} Y = c_f [D_f] +
c_m [D_m].
\]</span></p>
<p>式中, <span class="math inline">\([D_f]\)</span> 和 <span
class="math inline">\([D_m]\)</span>
分别为纤维和基体材料的弹性模量矩阵.</p>
<h2 id="单胞方程的求解">单胞方程的求解</h2>
<p>使用有限元方法求解单胞方程需要解决如下问题:</p>
<ol type="1">
<li><strong>生成周期性边界的网格</strong>. 比如三维单胞问题, 左右, 前后,
上下面的网格节点要<strong>完全一致</strong>,
这样才能施加周期性边界条件</li>
<li><strong>施加周期性边界条件</strong>. 周期性边界条件包含两部分:
<ol type="1">
<li>对面主从节点之间的约束关系</li>
<li>用于施加单位平均应变和消除刚体位移的位移边界条件</li>
</ol></li>
<li><strong>有限元方程右端项的B矩阵</strong>.
单胞变分方程的线性泛函项包含 B 矩阵,
而常用有限元求解器没有与之对应的载荷边界条件</li>
</ol>
<h3 id="使用-gmsh-生成周期性网格">使用 Gmsh 生成周期性网格</h3>
<p>Gmsh 带有命令 <code>Periodic</code>,
可以将主面通过平移或旋转的方式与从面相关联,
由此划分网格时可以保证面与面的节点分布完全相同.</p>
<h3 id="施加周期性边界条件">施加周期性边界条件</h3>
<p>主从节点信息在 Gmsh 网格 <code>.msh</code> 文件中通过关键词
<code>$Periodic</code>进行标识:</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404072302633GmshPeriodic关键词解释.png"
alt="GmshPeriodic关键词解释" />
<figcaption aria-hidden="true">GmshPeriodic关键词解释</figcaption>
</figure>
<p>从 <code>.msh</code> 文件中获取关联节点以及所属 entity 的信息,
就可以构造周期性边界条件的约束方程了. 在 ABAQUS 中, 一般是通过 equation
关键词确定多个节点自由度之间的约束关系:</p>
<p><span class="math display">\[
A_1 u_i^1 + A_2 u_i^2 + \ldots + A_N u_i^N = 0.
\]</span></p>
<p>式中, <span class="math inline">\(u_i^n\)</span> 上标 <span
class="math inline">\(n\)</span> 表示节点编号, 下标 <span
class="math inline">\(i\)</span> 表示 <span
class="math inline">\(x,y,z\)</span> 三方向自由度编号.
约束方程的变量只能是节点自由度, 并且右端恒等于 0, 所以 equation
只能添加节点自由度的齐次约束. 若希望添加非齐次的约束方程,
那么就需要引入一个额外的<strong>参考节点</strong>,
并在该节点处施加一个非零的位移条件.</p>
<p>程序采用的方式可以避免设置额外的参考节点,
平均应变条件则通过单胞上特殊节点的位移边界条件来施加,
这可以通过以下推导得到. 以 <span class="math inline">\(x\)</span>
方向为法线方向的两个相对面为例, 我们有</p>
<p><span class="math display">\[
u_i^{1+} - u_i^{1-} = \overline{\varepsilon}_{i1}, \quad
\text{对任意面 1 上的主从节点对.}
\]</span></p>
<p>记单胞在 x 轴的顶点坐标 <span class="math inline">\((1,0,0)\)</span>
处的位移为 <span class="math inline">\(u_i^{x}\)</span>, 原点处位移为
<span class="math inline">\(u_i^o\)</span>, 于是有</p>
<p><span class="math display">\[
u_i^x - u_i^o = \overline{\varepsilon}_{i1}.
\]</span></p>
<p>所以,</p>
<p><span class="math display">\[
u_i^{1+} - u_i^{1-} = u_i^x - u_i^o, \quad
\text{对任意面 1 上的主从节点对}.
\]</span></p>
<p>整理得到面 1 上的周期性边界条件等价为</p>
<p><span class="math display">\[
\begin{aligned}
  u_i^{1+} - u_i^{1-} - u_i^x + u_i^o &amp;= 0, \quad \text{对任意面 1
上的主从节点对}; \\
  u_i^x - u_i^o &amp;= \overline{\varepsilon}_{i1}.
\end{aligned}
\]</span></p>
<p>综合其它面的边界条件, 我们得到最终的约束方程</p>
<p><span class="math display">\[
\begin{aligned}
  u_i^{k+} - u_i^{k-} - u_i^x + u_i^o &amp;= 0, \quad \text{对任意面 k
上的主从节点对}; \\
  u_i^x - u_i^o &amp;= \overline{\varepsilon}_{i1}; \\
  u_i^y - u_i^o &amp;= \overline{\varepsilon}_{i2}; \\
  u_i^z - u_i^o &amp;= \overline{\varepsilon}_{i3}.
\end{aligned}
\]</span></p>
<p>第一组方程是关于节点自由度的齐次方程,
且与施加在单胞的单位平均应变无关,
所以在程序实现时可以不用特别考虑边界条件的具体形式;
其它三组方程则通过在节点 <span class="math inline">\((0,0,0)\)</span>,
<span class="math inline">\((1,0,0)\)</span>, <span
class="math inline">\((0,1,0)\)</span>, <span
class="math inline">\((0,0,1)\)</span> 处施加位移边界条件实现.</p>
<p>在实现第一组约束方程时, 还需要注意剔除冗余的约束方程,
这是因为我们使用 Lagrange 乘子法求解含约束的有限元方程,
如果出现冗余的约束, 则会导致有限元最终得到的刚度矩阵奇异.
我们将用一个二维平面上的四边形单元说明这一点. 如图所示,
单元节点处的位移分别为 <span class="math inline">\(u_1\)</span>, <span
class="math inline">\(u_2\)</span>, <span
class="math inline">\(u_3\)</span>, <span
class="math inline">\(u_4\)</span></p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404072344350冗余方程示意图.png" alt="image-20240407234453219" style="zoom:33%;" /></p>
<p>沿 <span class="math inline">\(x\)</span> 方向的约束方程有</p>
<p><span class="math display">\[
u_4 - u_2 = u_3 - u_1,
\]</span></p>
<p>沿 <span class="math inline">\(y\)</span> 方向的约束方程为</p>
<p><span class="math display">\[
u_4 - u_3 = u_2 - u_1.
\]</span></p>
<p>但是, 这两个方程是等价的,
因此如果遍历每组对面上每一个顶点,每一条边的节点, 就会出现过约束的问题.
一种避免过约束的方式如图所示, 按顺序读取节点, 并设置约束方程,
跳过图中虚线表示边线上的节点和空心圆圈表示的顶点处的节点,
就可以保证按照周期性边界条件约束所有的节点,
并且不存在冗余的约束方程.</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404072348418顺序读取主从节点避免冗余约束.png"
alt="顺序读取主从节点避免冗余约束" />
<figcaption aria-hidden="true">顺序读取主从节点避免冗余约束</figcaption>
</figure>
<h2 id="有限元求解结果分析">有限元求解结果分析</h2>
<p>程序使用三种方式计算均质化材料矩阵:</p>
<ol type="1">
<li>求解线性位移边界条件下的单胞方程, 对计算结果进行体平均</li>
<li>求解周期性边界条件约束下的单胞方程, 对计算结果进行体平均</li>
<li>求解渐进展开得到的偏微分方程</li>
</ol>
<div class="note info"><ol type="1">
<li><p>方式 1,2 又称为 RVE 方法, 即计算单胞在平均应变下的应力场,
对体积积分得到平均应力, 再根据定义得到均质化的材料矩阵.</p></li>
<li><p>方式 2 使用周期性边界条件, 是对相对面上的主从节点施加约束关系,
再在角点处施加位移边界条件, 实现所谓的平均应变.</p></li>
<li><p>线性位移条件得到的结果应该略大于周期性边界条件的结果.</p></li>
<li><p>方式 3 求解新的偏微分方程, 固定单胞的角点等于去除宏观应变 <span
class="math inline">\(\varepsilon^c\)</span> 引入的位移量, 求解得到的
<span class="math inline">\(\chi\)</span>
可以看作是对体积积分得到的材料矩阵进行<strong>修正</strong>:</p></li>
</ol>
<p><span class="math display">\[
[D^{\mathrm{hom}}] = [\overline{D}] - [\sigma^{(11)}, \sigma^{(22)},
\sigma^{(33)}, \sigma^{(23)}, \sigma^{(13)}, \sigma^{(12)}]
\]</span></p>
</div>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>多尺度</tag>
        <tag>有限元</tag>
      </tags>
  </entry>
  <entry>
    <title>两点张量变形梯度</title>
    <url>/mechanics/%E4%B8%A4%E7%82%B9%E5%BC%A0%E9%87%8F%E5%8F%98%E5%BD%A2%E6%A2%AF%E5%BA%A6/</url>
    <content><![CDATA[<p>首先，连续体在初始时刻 <span class="math inline">\(t_0\)</span>
所占空间定义为参考构型 <span
class="math inline">\(\Omega_0\)</span>。在时刻 <span
class="math inline">\(t\)</span>，连续体从参考构型变形到当前构型<span
class="math inline">\(\Omega\)</span>。<span
class="math inline">\(\Omega_0\)</span> 与 <span
class="math inline">\(\Omega\)</span> 均为三维欧几里得向量空间 <span
class="math inline">\(E^3\)</span> 的子集。参考构型中点 <span
class="math inline">\(\boldsymbol{X}\)</span> 运动到当前构型点 <span
class="math inline">\(\boldsymbol{x}\)</span>，我们定义函数 <span
class="math inline">\(\chi(\boldsymbol{X},t): E^3\times\mathbb{R}
\mapsto E^3\)</span> 来描述连续体的运动: <span class="math display">\[
\boldsymbol{x} \triangleq \chi(\boldsymbol{X},t) =
\chi_{t}(\boldsymbol{X})
\]</span> 固定时刻 <span class="math inline">\(t\)</span>，对上式变量
<span class="math inline">\(\boldsymbol{X}\)</span> 微分，可得到微元
<span class="math inline">\(\mathrm{d}\boldsymbol{x}\)</span> 与 <span
class="math inline">\(\mathrm{d}\boldsymbol{X}\)</span> 之间的关系：
<span class="math display">\[
\mathrm{d} \boldsymbol{x} =
\frac{\partial{\chi}_t}{\partial{\boldsymbol{X}}} \cdot
\mathrm{d}\boldsymbol{X} =
\boldsymbol{F} \cdot \mathrm{d} \boldsymbol{X}
\]</span> 式中，变形梯度 <span
class="math inline">\(\boldsymbol{F}\)</span> 定义为 <span
class="math display">\[
\boldsymbol{F} \triangleq
\frac{\partial{\chi}_t}{\partial{\boldsymbol{X}}}
\]</span> <span id="more"></span>所以，变形梯度将参考构型点 <span
class="math inline">\(\boldsymbol{X}\)</span> 处的微元 <span
class="math inline">\(\mathrm{d} \boldsymbol{X}\)</span>
映射到当前构型点<span class="math inline">\(\boldsymbol{x}\)</span>
处的微元 <span class="math inline">\(\mathrm{d}
\boldsymbol{x}\)</span>。</p>
<p>为方便演算，我们希望将变形梯度 <span
class="math inline">\(\boldsymbol{F}\)</span>
写成分量形式。在将任意向量或张量写成分量形式之前，都必须要确定基底是什么。例如，对于一般的二阶张量
<span class="math inline">\(\boldsymbol{T}: E^3 \mapsto E^3\)</span>
，若使用张成 <span class="math inline">\(E^3\)</span> 的基底<span
class="math inline">\(\{ \boldsymbol{e}_i\}\)</span>，则张量 <span
class="math inline">\(\boldsymbol{T}\)</span> 的分量形式可以写成： <span
class="math display">\[
\boldsymbol{T} = T_{ij}~\boldsymbol{e}_i \otimes \boldsymbol{e}_j
\]</span> 对向量 <span class="math inline">\(\boldsymbol{v} = v_i
\boldsymbol{e}_i\)</span> 做点积运算得到 <span class="math display">\[
\boldsymbol{T} \cdot \boldsymbol{v} = T_{ij} \boldsymbol{e}_i \otimes
\boldsymbol{e}_j \cdot v_k \boldsymbol{e}_k
= T_{ij} v_j \boldsymbol{e}_i
\]</span> 变形梯度同样是二阶张量，但在点 <span
class="math inline">\(\boldsymbol{X}\)</span> 与点 <span
class="math inline">\(\boldsymbol{x}\)</span> 处，若使用不同的基底 <span
class="math inline">\(\{ \boldsymbol{E}_A\}\)</span>和 <span
class="math inline">\(\{ \boldsymbol{e}_i\}\)</span>
描述在该点处的微元： <span class="math display">\[
\mathrm{d}\boldsymbol{X} = \mathrm{d}X_A \boldsymbol{E}_A, \quad
\mathrm{d}\boldsymbol{x} = \mathrm{d}x_i
\boldsymbol{e}_i
\]</span> 那么 <span class="math inline">\(\boldsymbol{F}\)</span>
的分量形式为 <span class="math display">\[
\boldsymbol{F} = F_{iA} \boldsymbol{e}_i \otimes \boldsymbol{E}_A
\]</span> 与一般的二阶张量不同，变形梯度 <span
class="math inline">\(\boldsymbol{F}\)</span>
将两组<strong>不同原点</strong>的向量 <span
class="math inline">\(\mathrm{d} \boldsymbol{x}\)</span> 和 <span
class="math inline">\(\mathrm{d} \boldsymbol{X}\)</span>
联系起来，因此变形梯度又称为「两点张量」(two-point tensor)。</p>
<p>下面我们给出变形梯度的转置与逆。张量的转置 <span
class="math inline">\(\boldsymbol{F}^{\mathrm{T}}\)</span> 定义为 <span
class="math display">\[
(\boldsymbol{F} \cdot \boldsymbol{u}) \cdot \boldsymbol{v} =
\boldsymbol{u}\cdot (\boldsymbol{F}^{\mathrm{T}} \cdot
\boldsymbol{v})
\]</span> 写成分量形式可得 <span class="math display">\[
\begin{aligned}
(\boldsymbol{F} \cdot \boldsymbol{u}) \cdot \boldsymbol{v} = (F_{iA}
\boldsymbol{e}_i \otimes \boldsymbol{E}_A \cdot u_B
\boldsymbol{E}_B) \cdot v_j \boldsymbol{e}_j = F_{iA}u_Av_i\\
\boldsymbol{u}\cdot (\boldsymbol{F}^{\mathrm{T}} \cdot \boldsymbol{v})
=u_B
\boldsymbol{E}_B \cdot (F_{Ai}^{\mathrm{T}} \boldsymbol{E}_A \otimes
\boldsymbol{e}_i \cdot v_j \boldsymbol{e}_j) =
F_{Ai}^{\mathrm{T}} u_Av_i
\end{aligned}
\]</span> 若将分量记成矩阵形式，则有<span
class="math inline">\([F_{Ai}^{\mathrm{T}}] = [F_{Ai}]^T\)</span>.</p>
<p>接下来求解变形梯度的逆。根据反函数定理，若在点 <span
class="math inline">\(\boldsymbol{X}\)</span> 处的 Jacobian 行列式 <span
class="math inline">\(J = \det\boldsymbol{F} \neq
0\)</span>，则存在逆映射 <span
class="math inline">\(\chi_{t}^{-1}\)</span>，使得 <span
class="math inline">\(\boldsymbol{X} =
\chi_{t}^{-1}(\boldsymbol{x})\)</span>。对 <span
class="math inline">\(\chi_{t}^{-1}\)</span>​ 求微分可得： <span
class="math display">\[
\mathrm{d} \boldsymbol{X} =
\frac{\partial{\chi}_t^{-1}}{\partial{\boldsymbol{x}}} \cdot
\mathrm{d}\boldsymbol{x} =
\boldsymbol{F}^{-1} \cdot \mathrm{d} \boldsymbol{x}
\]</span> 由此可以得到变形梯度的逆。将 <span
class="math inline">\(\boldsymbol{F}^{-1}\)</span> 写成分量形式 <span
class="math display">\[
\boldsymbol{F}^{-1} = F_{Ai}^{-1} \boldsymbol{E}_A \otimes
\boldsymbol{e}_i
\]</span> 式中，<span class="math inline">\([F_{Ai}^{-1}] =
[F_{iA}]^{-1}\)</span>。根据变形梯度及其逆的分量形式，我们可以得到如下关系：
<span class="math display">\[
\boldsymbol{F}^{-1} \boldsymbol{F} = \boldsymbol{E}_A \otimes
\boldsymbol{E}_A = \boldsymbol{I}, \quad
\boldsymbol{F} \boldsymbol{F}^{-1} = \boldsymbol{e}_i \otimes
\boldsymbol{e}_i = \boldsymbol{i}
\]</span> 上式得到的单位张量 (identity tensor) 需要做出区分：前者 <span
class="math inline">\(\boldsymbol{I}\)</span>
是在参考构型下的单位张量，后者 <span
class="math inline">\(\boldsymbol{i}\)</span>
是在当前构型下的单位张量。</p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>连续介质力学</tag>
      </tags>
  </entry>
  <entry>
    <title>双相单胞问题 E P 张量的封闭解</title>
    <url>/mechanics/%E5%8F%8C%E7%9B%B8%E5%8D%95%E8%83%9E%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<p>参考文献：Fish,Practical multiscaling, chapter 4.3.5</p>
<p>给定单胞各个相的弹性模量 <span
class="math inline">\(\mathbb{L}^{(\alpha)},
\alpha=1,2,\ldots,N\)</span>，以及均质化之后的模量 <span
class="math inline">\(\mathbb{L}^c\)</span>，式（4.119a）和式（4.119b）给出关于
<span class="math inline">\(N\)</span> 个未知量 <span
class="math inline">\(E_{mn}^{kl(\alpha)}\)</span> 的 2
个方程，式（4.119c）和式（4.119d）给出关于 <span
class="math inline">\(N^2\)</span> 个未知量 <span
class="math inline">\(P_{mn}^{kl(\alpha\beta)}\)</span> 的 <span
class="math inline">\(2N\)</span> 个方程，<span
class="math inline">\(N\)</span> 为 Partition 的个数。当 <span
class="math inline">\(N=2\)</span>
时，也即单胞只分成两个分块，从方程的未知量个数来看，是可以得到封闭解的。<span id="more"></span></p>
<h2 id="e-张量的封闭解">E 张量的封闭解</h2>
<p>式（4.119a）和式（4.119b）展开后得到 <span class="math display">\[
\begin{aligned}
c^{(1)}\mathbb{L}^{(1)}:&amp;\mathbb{E}^{(1)} +
c^{(2)}\mathbb{L}^{(2)}:\mathbb{E}^{(2)} = \mathbb{L}^c\\
c^{(1)}&amp;\mathbb{E}^{(1)} + c^{(2)}\mathbb{E}^{(2)} = \mathbb{I}
\end{aligned}
\]</span> 第 2 式乘 <span
class="math inline">\(\mathbb{L}^{(2)}\)</span> 再与 1 式相减得到 <span
class="math display">\[
c^{(1)}(\mathbb{L}^{(1)}-\mathbb{L}^{(2)}):\mathbb{E}^{(1)}  =
\mathbb{L}^c - \mathbb{L}^{(2)}
\]</span> 所以 <span class="math inline">\(\mathbb{E}^{(1)}\)</span>
可以通过分块的弹性模量以及体积分数表示为 <span class="math display">\[
\mathbb{E}^{(1)} =
\frac{1}{c^{(1)}}(\mathbb{L}^{(1)}-\mathbb{L}^{(2)})^{-1} (\mathbb{L}^c
- \mathbb{L}^{(2)})
\]</span> 由于指标是对称的，所以有 <span class="math display">\[
\mathbb{E}^{(2)} =
\frac{1}{c^{(2)}}(\mathbb{L}^{(2)}-\mathbb{L}^{(1)})^{-1} (\mathbb{L}^c
- \mathbb{L}^{(1)})
\]</span> 至此，我们解析得到了 <span
class="math inline">\(\mathbb{E}^{(1)}\)</span>，<span
class="math inline">\(\mathbb{E}^{(2)}\)</span> 的表达式： <span
class="math display">\[
\left\{
\begin{aligned}
\mathbb{E}^{(1)} =
\frac{1}{c^{(1)}}(\mathbb{L}^{(1)}-\mathbb{L}^{(2)})^{-1} (\mathbb{L}^c
- \mathbb{L}^{(2)})\\
\mathbb{E}^{(2)} =
\frac{1}{c^{(2)}}(\mathbb{L}^{(2)}-\mathbb{L}^{(1)})^{-1} (\mathbb{L}^c
- \mathbb{L}^{(1)})
\end{aligned}
\right.
\tag{1}
\]</span></p>
<h2 id="p-张量的封闭解">P 张量的封闭解</h2>
<p>展开式（4.119c）和式（4.119d）的自由指标得到如下 4 个方程： <span
class="math display">\[
\begin{aligned}
\mathbb{P}^{(11)} + \mathbb{P}^{(12)} = \mathbb{I} - \mathbb{E}^{(1)}\\
\mathbb{P}^{(11)}:\mathbb{M}^{(1)} + \mathbb{P}^{(12)}:\mathbb{M}^{(2)}
= 0\\
\\
\mathbb{P}^{(21)} + \mathbb{P}^{(22)} = \mathbb{I} - \mathbb{E}^{(2)}\\
\mathbb{P}^{(21)}:\mathbb{M}^{(1)} + \mathbb{P}^{(22)}:\mathbb{M}^{(2)}
= 0
\end{aligned}
\]</span> 1 式左右两端乘 <span
class="math inline">\(\mathbb{M}^{(2)}\)</span>，再与 2 式相减得到 <span
class="math display">\[
\mathbb{P}^{(11)}:(\mathbb{M}^{(2)} - \mathbb{M}^{(1)})
= (\mathbb{I} - \mathbb{E}^{(1)}):\mathbb{M}^{(2)}
\]</span> 所以 <span class="math display">\[
\mathbb{P}^{(11)}
= (\mathbb{I} - \mathbb{E}^{(1)}):\mathbb{M}^{(2)}:(\mathbb{M}^{(2)} -
\mathbb{M}^{(1)})^{-1}
\]</span> 又因为 <span class="math display">\[
\mathbb{M}^{(2)}:(\mathbb{M}^{(2)} - \mathbb{M}^{(1)})^{-1}
= (\mathbb{L}^{(1)} - \mathbb{L}^{(2)})^{-1}:\mathbb{L}^{(1)}
\]</span> 所以有 <span class="math display">\[
\mathbb{P}^{(11)}
= (\mathbb{I} - \mathbb{E}^{(1)}):(\mathbb{L}^{(1)} -
\mathbb{L}^{(2)})^{-1}:\mathbb{L}^{(1)}
\]</span> 类似的，我们可以求解出 <span
class="math inline">\(\mathbb{P}^{(12)}\)</span>： <span
class="math display">\[
\mathbb{P}^{(12)}
= (\mathbb{I} - \mathbb{E}^{(1)}):(\mathbb{L}^{(2)} -
\mathbb{L}^{(1)})^{-1}:\mathbb{L}^{(2)}
\]</span> 交换对称指标之后，我们同样也可以得到 <span
class="math inline">\(\mathbb{P}^{(21)}\)</span>，<span
class="math inline">\(\mathbb{P}^{(22)}\)</span> 的封闭表达式： <span
class="math display">\[
\left\{
\begin{aligned}
\mathbb{P}^{(11)}
= (\mathbb{I} - \mathbb{E}^{(1)}):(\mathbb{L}^{(1)} -
\mathbb{L}^{(2)})^{-1}:\mathbb{L}^{(1)}\\
\mathbb{P}^{(12)}
= (\mathbb{I} - \mathbb{E}^{(1)}):(\mathbb{L}^{(2)} -
\mathbb{L}^{(1)})^{-1}:\mathbb{L}^{(2)}\\
\mathbb{P}^{(22)}
= (\mathbb{I} - \mathbb{E}^{(2)}):(\mathbb{L}^{(2)} -
\mathbb{L}^{(1)})^{-1}:\mathbb{L}^{(2)}\\
\mathbb{P}^{(21)}
= (\mathbb{I} - \mathbb{E}^{(2)}):(\mathbb{L}^{(1)} -
\mathbb{L}^{(2)})^{-1}:\mathbb{L}^{(1)}
\end{aligned}
\right.
\tag{2}
\]</span></p>
<h2 id="数值实现">数值实现</h2>
<p>这里我们将把张量形式的方程组转换为可用于数值计算的 Voigt
形式。我们以求解（2）为例。将 1 式左右两端进行 Voigt 变换得到： <span
class="math display">\[
[:][\mathbb{P}^{(11)}]
= [:]([\mathbb{I}] - [\mathbb{E}^{(1)}])~
[:][(\mathbb{L}^{(1)} - \mathbb{L}^{(2)})^{-1}]~
[:][\mathbb{L}^{(1)}]
\]</span> 而中间四阶张量逆的矩阵表示为 <span class="math display">\[
[(\mathbb{L}^{(1)} - \mathbb{L}^{(2)})^{-1}]
= [:]^{-1} [\mathbb{L}^{(1)} - \mathbb{L}^{(2)}]^{-1} [:]^{-1}
\]</span> 代入得到 <span class="math display">\[
[:][\mathbb{P}^{(11)}]
= ([:][\mathbb{I}] - [:][\mathbb{E}^{(1)}])~
[\mathbb{L}^{(1)} - \mathbb{L}^{(2)}]^{-1}~
[\mathbb{L}^{(1)}]
\]</span></p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>张量运算</tag>
        <tag>多尺度</tag>
        <tag>解析方法</tag>
      </tags>
  </entry>
  <entry>
    <title>四阶单位张量的定义</title>
    <url>/mechanics/%E5%9B%9B%E9%98%B6%E5%8D%95%E4%BD%8D%E5%BC%A0%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h2 id="四阶单位张量的不同定义方式">四阶单位张量的不同定义方式</h2>
<p>四阶单位张量可以表示为含有四个自由指标 Kronecker delta 记号的组合:
<span class="math inline">\(\delta_{ij} \delta_{kl}\)</span>. 不过,
与二阶单位张量不同的是, 改变指标的顺序, 会得到三种不同的四阶单位张量:
<span class="math display">\[
\delta_{ij} \delta_{kl} \triangleq {\mathcal{F}}_{iljk}
\triangleq{\mathcal{E}}_{ikjl} \triangleq {\mathcal{I}}_{ijkl}
\]</span></p>
<p>或者</p>
<p><span class="math display">\[
{\mathcal{I}}_{ijkl} \triangleq \delta_{ij} \delta_{kl} ,\quad
{\mathcal{E}}_{ijkl} \triangleq \delta_{ik} \delta_{jl} ,\quad
{\mathcal{F}}_{ijkl} \triangleq \delta_{il} \delta_{jk}
\tag{1}
\]</span></p>
<span id="more"></span>
<p>对于任意四阶张量 <span class="math inline">\(\mathbb{L}\)</span>,
在双点积 (<span class="math inline">\(A:B:=A_{\cdot mn} B_{mn\cdot
}\)</span>) 作用下, 张量 <span
class="math inline">\(\mathcal{E}\)</span> 满足:</p>
<p><span class="math display">\[
\mathcal{E}:\mathbb{L}=\delta_{ik} \delta_{jl} L_{klmn} = L_{ijmn},
\quad
\mathbb{L}:\mathcal{E}= L_{ijkl} \delta_{km} \delta_{ln}= L_{ijmn}
\]</span></p>
<p>除上述三种定义四阶单位张量的方式之外, 还可以定义如下四阶张量:</p>
<p><span class="math display">\[
\mathcal{L}_{ijkl}\triangleq\frac{1}{2}(\mathcal{F}_{ijkl}+\mathcal{E}_{ijkl})
= \frac{1}{2}(\delta_{il} \delta_{jk}+\delta_{ik} \delta_{jl})
\]</span></p>
<p>如果四阶张量的指标满足 <span class="math display">\[
\square_{ijkl} = \square_{jikl} = \square_{ijlk}
\]</span> 那么称张量 <span class="math inline">\(\square_{ijkl}\)</span>
具有次对称性. 具有次对称性的单位张量为 <span
class="math inline">\(\mathcal{L}_{ijkl}\)</span></p>
<p>在力学中, 我们一般将四阶单位张量 <span
class="math inline">\(\mathcal{I}_{ijkl}\)</span> 和 <span
class="math inline">\(\mathcal{L}_{ijkl}\)</span> 分别记作 <span
class="math display">\[
\mathcal{I}_{ijkl} \triangleq \mathbf{I} \otimes \mathbf{I}, \quad
\mathcal{L}_{ijkl} \triangleq \mathbb{I}
\]</span></p>
<h2 id="四阶单位张量的-voigt-矩阵形式">四阶单位张量的 Voigt
矩阵形式</h2>
<p>将式 (1) 定义的三种单位张量写成 Voigt 矩阵形式为 <span
class="math display">\[
[\mathcal{I}] = \begin{pmatrix}
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
      \end{pmatrix}, \quad
[\mathcal{E}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}, \quad
[\mathcal{F}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}.
\]</span></p>
<p>以及单位张量 <span class="math inline">\(\mathcal{L}_{ijkl}\)</span>
<span class="math display">\[
[\mathcal{L}] = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2}
    \end{pmatrix}
\]</span> 计算单位张量的 MATLAB 脚本见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpdXhpYW9odW8vZm91cnRoLW9yZGVyLWlkZW50aXR5LXRlbnNvcg==">Github<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>张量运算</tag>
      </tags>
  </entry>
  <entry>
    <title>单胞问题张量 E P 的解析关系</title>
    <url>/mechanics/%E5%8D%95%E8%83%9E%E9%97%AE%E9%A2%98%E5%BC%A0%E9%87%8F%20E%20P%20%E7%9A%84%E8%A7%A3%E6%9E%90%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>参考文献：Fish,Practical multiscaling, chapter 4.3.5</p>
<h2
id="示性函数在单胞分块上的积分运算">示性函数在单胞分块上的积分运算</h2>
<p>Reduced order 假设分块上的物理量是常值，为描述分块常值函数，我们定义
Partition <span class="math inline">\(Y^\alpha\)</span> 上的示性函数
<span
class="math inline">\(\chi^{(\alpha)}(y):Y\mapsto\mathbb{R}\)</span> ：
<span class="math display">\[
\chi^{(\alpha)}(y) \triangleq \begin{cases}
1, \quad y \in Y^{(\alpha)}\\
0, \quad y \notin Y^{(\alpha)}\\
\end{cases}
\]</span> <span id="more"></span>示性函数在单胞 <span
class="math inline">\(Y\)</span> 上的积分等于分块 <span
class="math inline">\(Y^{(\alpha)}\)</span> 的度量： <span
class="math display">\[
|Y^{(\alpha)}| \triangleq \int_{Y} \chi^{(\alpha)}(y) \mathrm{d} y
\equiv \int_{Y^{(\alpha)}} \mathrm{d} y
\]</span> 我们有如下结论： <span class="math display">\[
\int_{Y} \chi^{(\alpha)}(y) \chi^{(\beta)}(y) ~\mathrm{d}y
= \begin{cases}
|Y^{(\alpha)}|, \quad \alpha = \beta \\
0, \quad \quad \quad \alpha \neq \beta
\end{cases}
\]</span> 因此，对于两个分块常值的函数 <span
class="math inline">\(f(y)=\chi^{(\alpha)}(y)f^{(\alpha)}\)</span>，<span
class="math inline">\(g(y)=\chi^{(\alpha)}(y)g^{(\alpha)}\)</span>，它们的乘积在单胞上的积分为
<span class="math display">\[
\begin{aligned}
\int_{Y} f(y)g(y) ~\mathrm{d}y
&amp;= \int_{Y} \sum_{\alpha} \left( \chi^{(\alpha)}(y)f^{(\alpha)}
\right)
\sum_{\beta} \left( \chi^{(\beta)}(y)g^{(\beta)} \right) ~\mathrm{d}y \\
&amp;= \sum_{\alpha} f^{(\alpha)}g^{(\alpha)} \int_{Y}
\chi^{(\alpha)}(y) ~\mathrm{d}y
= \sum_{\alpha} |Y^{(\alpha)}| f^{(\alpha)}g^{(\alpha)}
\end{aligned}
\]</span></p>
<h2 id="张量-mathbbealpha-mathbblalpha-的关系">张量 <span
class="math inline">\(\mathbb{E}^{(\alpha)}\)</span> <span
class="math inline">\(\mathbb{L}^{(\alpha)}\)</span> 的关系</h2>
<p>单胞的弹性模量 <span class="math inline">\(L_{ijkl}(y)\)</span>
可以表示为： <span class="math display">\[
L_{ijkl}(y) = \sum_{\alpha} \chi^{(\alpha)}(y)L_{ijkl}^{(\alpha)}
\tag{1}
\]</span> 式中，<span class="math inline">\(L_{ijkl}^{(\alpha)}\)</span>
表示分块 <span class="math inline">\(Y^{(\alpha)}\)</span>
上的材料弹性模量，我们假设它总是均匀的，也即 <span
class="math inline">\(L_{ijkl}^{(\alpha)} \equiv
\mathrm{const}\)</span>。</p>
<p>宏观尺度的弹性张量 <span class="math inline">\(L_{ijkl}^c\)</span>
定义为： <span class="math display">\[
L_{ijkl}^c \triangleq \frac{1}{|Y|}\int_{Y} L_{ijmn}(y) E_{mn}^{kl}(y)
\mathrm{d} y
\]</span> 将式（1）代入得到 <span class="math display">\[
L_{ijkl}^c = \frac{1}{|Y|} \sum_{\alpha} L_{ijmn}^{(\alpha)} \int_{Y}
\chi^{(\alpha)}(y) E_{mn}^{kl}(y) ~\mathrm{d}y
\tag{2}
\]</span> 定义分块上的应变影响张量 <span
class="math inline">\(E_{mn}^{kl(\alpha)}\)</span> 为 <span
class="math display">\[
E_{mn}^{kl(\alpha)}
\triangleq \frac{1}{|Y^{(\alpha)}|}\int_{Y} \chi^{(\alpha)}(y)
E_{mn}^{kl}(y) ~\mathrm{d} y
\]</span> 以及分块 <span class="math inline">\(\alpha\)</span>
所占的体积分数 <span class="math inline">\(c^{(\alpha)}\)</span>： <span
class="math display">\[
c^{(\alpha)} \triangleq \frac{|Y^{(\alpha)}|}{|Y|}
\]</span> 那么，式（2）就可以表示为 <span class="math display">\[
L_{ijkl}^c = \sum_{\alpha}
c^{(\alpha)}L_{ijmn}^{(\alpha)}E_{mn}^{kl(\alpha)}
\tag{4.119a}
\]</span> 上式对任意的四阶张量 <span
class="math inline">\(L_{ijmn}^{(\alpha)}\)</span>
均成立，特别的，我们选取 <span class="math display">\[
L_{ijmn}^{(\alpha)} = I_{ij}^{mn},\quad 对任意分块 \alpha
\]</span> 式中，$I_{ij}^{kl} $ 为四阶单位张量。那么，式（3）有 <span
class="math display">\[
\sum_{\alpha}c^{(\alpha)}E_{ij}^{kl(\alpha)} = I_{ij}^{kl}
\tag{4.119b}
\]</span> ## 张量 <span
class="math inline">\(\mathbb{E}^{(\alpha)}\)</span> <span
class="math inline">\(\mathbb{P}^{(\alpha \beta)}\)</span>​ 的关系</p>
<p>Fish 的证明是从式（4.41）出发： <span class="math display">\[
\varepsilon_{i j}^{(\beta)}(x)
-\sum_{\alpha} P_{i j}^{k l(\beta \alpha)} \mu_{k l}^{(\alpha)}(x)
=E_{i j}^{k l(\beta)} \varepsilon_{k l}^c(x)
\tag{4.41}
\]</span> 并选取特别情景下的 <span class="math inline">\(\mu_{k
l}^{(\alpha)}(x)\)</span>，使得==分块上的应变与应力均相等（？！）==：
<span class="math display">\[
\begin{aligned}
&amp; \sigma_{i j}^{(\alpha)}:=\sigma_{i j}^c;  \alpha=1,2 \ldots N  \\
&amp; \varepsilon_{i j}^c=:\varepsilon_{i j}^{(\alpha)}=M_{i j k
l}^{(\alpha)} \sigma_{k l}^c+\mu_{i j}^{(\alpha)} ; \alpha=1,2 \ldots N
\\
&amp; \mu_{i j}^{(\alpha)}=\mu_{i j}^c-\left[M_{i j k l}^{(\alpha)}-M_{i
j k l}^c\right] \sigma_{k l}^c
\end{aligned}
\]</span> 然后将上式代入到式（4.41）中，得到 <span
class="math display">\[
\left[E_{i j}^{k l(\beta)}+\sum_{\alpha} P_{i j}^{k l(\beta
\alpha)}-I_{i j k l}\right] \varepsilon_{k l}^c
=\sum_{\alpha} P_{i j}^{k l(\beta \alpha)} M_{k l m n}^{(\alpha)}
\sigma_{m n}^c
\]</span> 再根据宏观应力应变的任意性，就得到 <span
class="math display">\[
\sum_{\beta} P_{kl}^{mn(\alpha\beta)}
+ E_{kl}^{mn(\alpha)}
- I_{kl}^{mn}
= 0, \quad \alpha=1,2,\ldots,N
\tag{4.119c}
\]</span> 和 <span class="math display">\[
\sum_{\beta} P_{ij}^{mn(\alpha\beta)} M_{mnkl}^{(\beta)}
= 0, \quad \alpha=1,2,\ldots,N
\tag{4.119d}
\]</span></p>
<hr />
<p>这里给出另一种推导 P E
张量之间关系的方法，不需要对本征应变做出奇怪的假设。张量场 <span
class="math inline">\(E_{ij}^{kl}\)</span> 与 <span
class="math inline">\(P_{ij}^{kl}\)</span> 分别满足如下微分方程:</p>
<p><span class="math display">\[
\begin{aligned}
\left\{ L_{ijkl}(y) E_{kl}^{mn} \right\}_{,y_j} &amp;= 0, \text{in}~ Y
\\
\left\{ L_{ijkl}(y) \left[ P_{kl}^{mn(\alpha)}(y) -
I_{kl}^{mn}\chi^{(\alpha)}(y) \right] \right\}_{,y_j} &amp;= 0,
\text{in}~ Y \quad \alpha=1,2, \ldots,N
\end{aligned}
\]</span> 我们将上述方程写成弱形式, 对任意满足周期性边界条件的函数 <span
class="math inline">\(v_i\)</span>, 有 <span class="math display">\[
\int_{Y} L_{ijkl}(y) E_{kl}^{mn}(y) v_{i,j}(y) ~\mathrm{d}y = 0
\tag{3}
\]</span> 以及 <span class="math display">\[
\int_{Y} L_{ijkl}(y) \left[ P_{kl}^{mn(\alpha)}(y) -
I_{kl}^{mn}\chi^{(\alpha)}(y) \right] v_{i,j}(y) ~\mathrm{d}y
= 0, \text{in}~ Y \quad \alpha=1,2, \ldots,N
\tag{4}
\]</span> 对式（4）Partition 求和, 得到 <span class="math display">\[
\int_{Y} L_{ijkl}(y) \left[
\sum_{\alpha}\left( P_{kl}^{mn(\alpha)}(y) \right) - I_{kl}^{mn}
\right] v_{i,j}(y) ~\mathrm{d}y
= 0
\tag{5}
\]</span> 式（3）与式（5）相加得到 <span class="math display">\[
\int_{Y} L_{ijkl}(y) \left[
\sum_{\alpha}\left( P_{kl}^{mn(\alpha)}(y) \right)
+ E_{kl}^{mn}(y) - I_{kl}^{mn}
\right] v_{i,j}(y) ~\mathrm{d}y
= 0
\tag{6}
\]</span> 如果选取 test function <span
class="math inline">\(v_i\)</span>​​ 使得每一个 Partition
上的应变都是均匀的, 也即 <span class="math display">\[
v_{i,j}(y) = \sum_{\alpha}\chi^{(\alpha)}(y)v_{i,j}^{(\alpha)}
\]</span> 那么应力分布也是分块均匀的： <span class="math display">\[
\sigma_{kl}(y) = L_{ijkl}(y) v_{i,j}(y) =
\sum_{\alpha}\chi^{(\alpha)}(y) L_{ijkl}^{(\alpha)} v_{i,j}^{(\alpha)} =
\sum_{\alpha}\chi^{(\alpha)}(y) \sigma_{kl}^{(\alpha)}
\]</span> 再代入式（1），那么式（6）就可以写为 <span
class="math display">\[
\sum_{\beta}\sigma_{kl}^{(\beta)}\int_{Y} \chi^{(\beta)}(y) \left[
\sum_{\alpha}\left( P_{kl}^{mn(\alpha)}(y) \right)
+ E_{kl}^{mn}(y) - I_{kl}^{mn}
\right] ~\mathrm{d}y = 0
\tag{7}
\]</span> 如果我们定义 <span class="math display">\[
P_{kl}^{mn(\beta \alpha)} \triangleq \frac{1}{|Y^{(\beta)}|}\int_{Y}
\chi^{(\beta)}(y) P_{kl}^{mn(\alpha)}(y) ~\mathrm{d}y
\]</span> 那么有 <span class="math display">\[
\begin{aligned}
\int_{Y} \chi^{(\beta)}(y)
\sum_{\alpha}\left( P_{kl}^{mn(\alpha)}(y) \right) ~\mathrm{d}y
&amp;= |Y^{(\beta)}|\sum_{\alpha} P_{kl}^{mn(\beta\alpha)}, \\
\int_{Y} \chi^{(\beta)}(y)
E_{kl}^{mn}(y) ~\mathrm{d}y
&amp;= |Y^{(\beta)}| E_{kl}^{mn(\beta)}, \\
\int_{Y} \chi^{(\beta)}(y)
I_{kl}^{mn} ~\mathrm{d}y
&amp;= |Y^{(\beta)}|I_{kl}^{mn}
\end{aligned}
\]</span> 将上式代入到式（7）当中，就会得到关于 <span
class="math inline">\(\sigma_{kl}^{(\beta)}\)</span> 的方程： <span
class="math display">\[
\sum_{\beta}\sigma_{kl}^{(\beta)} |Y^{(\beta)}| \left(
\sum_{\alpha} P_{kl}^{mn(\beta\alpha)}
+ E_{kl}^{mn(\beta)}
- I_{kl}^{mn}
\right) = 0
\]</span> 又因为 <span
class="math inline">\(\sigma_{kl}^{(\beta)}\)</span>
可以任意选取大小，所以上式关于 <span
class="math inline">\(\sigma_{kl}^{(\beta)}\)</span> 的系数都必须等于
0： <span class="math display">\[
\sum_{\alpha} P_{kl}^{mn(\beta\alpha)}
+ E_{kl}^{mn(\beta)}
- I_{kl}^{mn}
= 0, \quad \beta=1,2,\ldots,N
\tag{4.119c}
\]</span> 如果选取 test function <span
class="math inline">\(v_{i,j}\)</span>
为常应变，那么还可以得到如下结论： <span class="math display">\[
\sum_{\alpha} c^{(\alpha)}
\mathbb{L}^{(\alpha)}:(\mathbb{P}^{(\alpha\beta)} - \mathbb{I}) = 0,
\quad \beta=1,2,\ldots,N
\]</span></p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>张量运算</tag>
        <tag>多尺度</tag>
        <tag>解析方法</tag>
      </tags>
  </entry>
  <entry>
    <title>弹性力学方程的 Green 函数</title>
    <url>/mechanics/%E5%BC%B9%E6%80%A7%E5%8A%9B%E5%AD%A6%E6%96%B9%E7%A8%8B%E7%9A%84%20Green%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>如果将微分方程写成抽象的算子形式:</p>
<p><span class="math display">\[
L[u] + f = 0 \text{ on } \Omega
\]</span></p>
<p>特别的, 当函数 <span class="math inline">\(f\)</span> 为 Dirac 函数
<span class="math inline">\(\delta\)</span> 时, 微分方程的解 <span
class="math inline">\(G\)</span> 称为算子 <span
class="math inline">\(L\)</span> 的 Green 函数 (或者称为微分方程 <span
class="math inline">\(L\)</span> 的基本解): <span
class="math display">\[
L [G] + \delta = 0
\]</span></p>
<span id="more"></span>
<p>当微分方程右端项为一般的函数 <span class="math inline">\(f\)</span>
时, 此时微分方程的解 <span class="math inline">\(u\)</span> 可以表示为
Green 函数 <span class="math inline">\(G\)</span> 与 <span
class="math inline">\(f\)</span> 的卷积:</p>
<p><span class="math display">\[
u = G*f = \int_{-\infty}^{\infty} G(x-x^{\prime}) f(x^{\prime})
\mathrm{d} x^{\prime}
\]</span></p>
<p>对于含本征应变的控制方程:</p>
<p><span class="math display">\[
L_{ijkl}~u_{k,lj} - L_{ijkl}~\mu_{kl,j} = 0
\]</span></p>
<p>我们希望能够找到该方程的 Green 函数 <span
class="math inline">\(G\)</span>, 使得方程的解可以表示为 Green
函数与本征应变的卷积. 这需要借助于 Fourier 分析方法. 对方程进行 Fourier
变换, 得到</p>
<p><span class="math display">\[
L_{ijkl}\xi_{l}\xi_{j}~\hat{u}_{k} + i \xi_{j}L_{ijkl}~\hat{\mu}_{kl} =
0
\]</span></p>
<p>记 <span class="math inline">\(K_{ik}(\xi) \triangleq
L_{ijkl}\xi_{l}\xi_{j}\)</span>, <span class="math inline">\(X_i
\triangleq -i \xi_{j}L_{ijkl}~\hat{\mu}_{kl}\)</span>, 就得到关于 <span
class="math inline">\(\hat{u}_k\)</span> 的线性方程:</p>
<p><span class="math display">\[
K_{ik} \hat{u}_k = X_i
\]</span></p>
<p>如果 <span class="math inline">\(L_{ijkl}\)</span> 具有主对称性,
也就是说, <span class="math inline">\(L_{(ij)[kl]} =
L_{[kl](ij)}\)</span>, 那么矩阵 <span
class="math inline">\(K_{ik}(\xi)\)</span> 是对称矩阵. 例如,
当材料是各项同性时, 矩阵 <span class="math inline">\(K\)</span>
可以写成</p>
<p><span class="math display">\[
K = (\lambda + \mu)\begin{pmatrix}
\xi_1 \xi_1 &amp; \xi_1 \xi_2 &amp; \xi_1 \xi_3 \\
\xi_2 \xi_1 &amp; \xi_2 \xi_2 &amp; \xi_2 \xi_3 \\
\xi_3 \xi_1 &amp; \xi_3 \xi_2 &amp; \xi_3 \xi_3
\end{pmatrix}
+
\mu \xi^2 I, \quad \xi^2 = \xi_1^2 + \xi_2^2 + \xi_3^2
\]</span></p>
<p>若定义矩阵 <span class="math inline">\(K_{ik}(\xi)\)</span> 的
Adjugate 矩阵为 <span class="math inline">\(N_{ik}(\xi)\)</span>: <span
class="math display">\[
N_{ik}(\xi) \triangleq \mathrm{adj}(K_{ik}(\xi))
\]</span> 那么, 矩阵 <span class="math inline">\(K_{ik}(\xi)\)</span>
的逆可以表示为 <span class="math display">\[
K_{ik}^{-1}(\xi) = D^{-1}(\xi)N_{ik}(\xi)
\]</span></p>
<p>式中, <span class="math inline">\(D(\xi) \triangleq
\det(K_{ik}(\xi))\)</span>. 再应用 Fourier 逆变换, 就可以得到解 <span
class="math inline">\(u(x)\)</span>:</p>
<p><span class="math display">\[
\begin{align}
u_{i}(x) &amp;= \mathscr{F}^{-1} [\hat{u}_{i}(\xi)]
= \mathscr{F}^{-1}[D^{-1}(\xi)N_{ik}(\xi) X_k] \\
&amp;=  -i
\mathscr{F}^{-1}[L_{kjmn}~D^{-1}(\xi)N_{ik}(\xi)\xi_{j}~\hat{\mu}_{mn}]
\end{align}
\]</span></p>
<p>将 Fourier 变换的公式代入得到</p>
<p><span class="math display">\[
\begin{align}
u_{i}(x) &amp;= -i \int L_{kjmn}~D^{-1}(\xi)N_{ik}(\xi)\xi_{j} e^{i\xi
\cdot x} \mathrm{d} \xi
\int \mu_{mn}(x^{\prime}) e^{-i\xi \cdot x^{\prime}} \mathrm{d}
x^{\prime}\\
&amp;= - \frac{\partial}{\partial x_j}\int
L_{kjmn}~D^{-1}(\xi)N_{ik}(\xi) e^{i\xi \cdot x} \mathrm{d} \xi
\int \mu_{mn}(x^{\prime}) e^{-i\xi \cdot x^{\prime}} \mathrm{d}
x^{\prime}\\
&amp;= - \int L_{kjmn} \left(\frac{\partial}{\partial x_j}\int
D^{-1}(\xi)N_{ik}(\xi) e^{i\xi \cdot (x-x^{\prime})} \mathrm{d} \xi
\right)  \mu_{mn}(x^{\prime}) \mathrm{d} x^{\prime}
\end{align}
\]</span></p>
<p>定义 Green 函数为</p>
<p><span class="math display">\[
G_{ik}(x) \triangleq \int D^{-1}(\xi)N_{ik}(\xi) e^{i\xi \cdot x}
\mathrm{d} \xi
\]</span></p>
<p>则 <span class="math inline">\(u_i\)</span> 可以记作</p>
<p><span class="math display">\[
u_{i}(x) = -\int L_{jkmn} G_{ik,j}(x-x^{\prime}) \mu_{mn}(x^{\prime})
\mathrm{d} x^{\prime}
\]</span></p>
<p>式中, Green 函数下标 <span
class="math inline">\(\square_{,j}\)</span> 表示对变量 <span
class="math inline">\(x_j\)</span> 求偏导 (注意区别变量 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(x^{\prime}\)</span>). 或者将上式记为卷积的形式:
<span class="math display">\[
u_i = G_{ik} * \left( -L_{jkmn} \mu_{mn} \right)
\]</span> 对 Green 函数求二阶导数, 得到 <span class="math display">\[
G_{ij,kl}(x-x^{\prime}) = -\int D^{-1}(\xi)N_{ij}(\xi) \xi_k \xi_l
e^{i\xi \cdot (x-x^{\prime})} \mathrm{d} \xi
\]</span></p>
<p>方程两端乘 <span class="math inline">\(L_{jknl}\)</span>,
等式依旧成立, 得到</p>
<p><span class="math display">\[
\begin{align}
L_{jknl}G_{ij,kl}(x-x^{\prime}) &amp;= -\int D^{-1}(\xi)N_{ij}(\xi)
L_{jknl} \xi_k \xi_l e^{i\xi \cdot (x-x^{\prime})} \mathrm{d} \xi
\end{align}
\]</span></p>
<p>这样就凑出了之前的定义式 <span class="math inline">\(K_{ik}(\xi) :=
L_{ijkl}\xi_{l}\xi_{j}\)</span>, 所以有 <span class="math display">\[
\begin{align}
L_{jknl}G_{ij,kl}(x-x^{\prime})
&amp;= -\int D^{-1}(\xi)K_{jn}(\xi)N_{ij}(\xi)  e^{i\xi \cdot
(x-x^{\prime})} \mathrm{d} \xi = -\delta_{in}\int e^{i\xi \cdot
(x-x^{\prime})} \mathrm{d} \xi \\
&amp;= -\delta_{in} \delta(x-x^{\prime})
\end{align}
\]</span> 整理一下指标, 得到 <span class="math display">\[
L_{ijkl}G_{nk,lj}(x-x^{\prime}) + \delta_{in} \delta(x-x^{\prime}) = 0
\tag{1}
\]</span></p>
<p>在阐述 Green 函数的物理意义之前,
我们可以先观察一下上述方程自由指标的个数. 上述方程一共有两个自由指标
<span class="math inline">\(i\)</span>, <span
class="math inline">\(n\)</span>,
同时该方程的形式与以位移为变量的控制方程非常相似: <span
class="math display">\[
L_{ijkl}u_{k,lj} + f_i = 0
\]</span> 只是控制方程自由指标只有一个, <span
class="math inline">\(i\)</span>, 我们将控制方程的自由指标展开: <span
class="math display">\[
\left\{
\begin{aligned}
L_{1jkl}u_{k,lj} + f_1 = 0\\
L_{2jkl}u_{k,lj} + f_2 = 0\\
L_{3jkl}u_{k,lj} + f_3 = 0
\end{aligned}
\right.
\]</span> 如果固定指标 <span class="math inline">\(n=1\)</span>,
那么控制方程 (1) 为 <span class="math display">\[
\left\{
\begin{aligned}
L_{1jkl}G_{1k,lj}(x-x^{\prime}) + \delta_{11} \delta(x-x^{\prime}) = 0\\
L_{2jkl}G_{1k,lj}(x-x^{\prime}) + \delta_{21} \delta(x-x^{\prime}) = 0\\
L_{3jkl}G_{1k,lj}(x-x^{\prime}) + \delta_{31} \delta(x-x^{\prime}) = 0
\end{aligned}
\right.
\]</span> 因此该组控制方程的外力项为 <span class="math display">\[
{f} = \begin{pmatrix}
\delta(x-x^{\prime}) \\
0 \\
0
\end{pmatrix}
\]</span></p>
<p>所以, 函数 <span class="math inline">\(f\)</span> 表示作用在点 <span
class="math inline">\(x^{\prime}\)</span>, 方向为 <span
class="math inline">\((1,0,0)\)</span> 的单位集中力. 函数 <span
class="math inline">\(G_{1k}(x-x^\prime)\)</span> 表示在上述外力 <span
class="math inline">\(f\)</span> 作用下系统的位移响应.</p>
<p>综上, 可以得到 Green 函数 <span
class="math inline">\(G_{nk}(x-x^{\prime})\)</span> 的物理意义是:
作用在点 <span class="math inline">\(x^{\prime}\)</span> 上, <span
class="math inline">\(n\)</span> 方向的单位集中力所造成的点 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(k\)</span> 方向上的位移分量. 如果 <span
class="math inline">\(L_{ijkl}\)</span> 具有主对称性, 那么矩阵 <span
class="math inline">\(K\)</span> <span class="math inline">\(N\)</span>
是对称矩阵, 所以 <span class="math display">\[
G_{nk} = G_{kn}
\]</span> 所以, <span
class="math inline">\(G_{nk}(x-x^{\prime})\)</span> 同样也可以解释为:
作用在点 <span class="math inline">\(x^{\prime}\)</span> 上, <span
class="math inline">\(k\)</span> 方向的单位集中力所造成的点 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(n\)</span> 方向上的位移分量.
这恰好与互易原理的结论相同.</p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>弹性力学</tag>
        <tag>Green 函数</tag>
        <tag>Fourier 变换</tag>
      </tags>
  </entry>
  <entry>
    <title>多尺度 Reduced Order 推导</title>
    <url>/mechanics/%E5%A4%9A%E5%B0%BA%E5%BA%A6-Reduced-Order-%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h2 id="reduced-order-中函数-h_ikl-与细观力学-green-函数的关联">Reduced
Order 中函数 <span class="math inline">\(h_{i}^{kl}\)</span> 与细观力学
Green 函数的关联</h2>
<p>在多尺度的单胞问题中, 如果使用本征应变 <span
class="math inline">\(\mu^{\xi}(x)\)</span> 表征材料非弹性的影响,
那么本构方程为:</p>
<p><span class="math display">\[
\sigma^{\xi}(x) = L^{\xi}(x):\left(\varepsilon^{\xi}(x) -
\mu^{\xi}(x)\right)
\]</span></p>
<p>对位移变量进行渐近展开, 得到</p>
<p><span class="math display">\[
\text{ANSATZ}:u^{\xi}(x) = u^{c}(x) + \xi u^{(1)}(x,y) + O(\xi^2)
\]</span></p>
<span id="more"></span>
<p>依照上述 ANSATZ, 同样也可以得到应变,应力,本征应变的渐进展开式: <span
class="math display">\[
\begin{aligned}
\varepsilon^{\xi}(x) &amp;= \varepsilon^f(x,y) + \xi
\varepsilon^{(1)}(x,y) + O(\xi^2)\\
\sigma^{\xi}(x) &amp;= \sigma^{f}(x,y) + \xi \sigma^{(1)}(x,y) +
O(\xi^2)\\
\mu^{\xi}(x) &amp;= \mu^f(x,y) + \xi \mu^{(1)}(x,y) + O(\xi^2)
\end{aligned}
\]</span></p>
<p>通过应力平衡方程, 以及解的存在唯一条件,
可以得到渐进展开式中不同阶次项之间的关系. 其中, fine scale
上的变量之间的关系式为:</p>
<p><span class="math display">\[
\varepsilon^f = \underbrace{\nabla_x u^c}_{\equiv \varepsilon^c} +
\nabla_y u^{(1)}\\
\sigma^f = \mathbb{L}(y) : \left( \varepsilon^f - \mu^f \right)
\]</span></p>
<p>在多尺度中, 单胞内精细的位移场 <span
class="math inline">\(u^{(1)}\)</span> 是通过如下方式进行构造的:</p>
<p><span class="math display">\[
u_i^{(1)}(x,y) = \underbrace{\varepsilon_{kl}^c(x) H_i^{kl}(y) }_{(1)}
+ \underbrace{\int_{Y} \mu_{kl}^f(x,y^{\prime}) h_{i}^{kl}(y,y^{\prime})
\mathrm{d} y^{\prime}}_{(2)}
\]</span></p>
<p>式中, 第 (1) 项只考虑线弹性材料非均质在单胞内部产生的位移场
fluctuation; 第 (2) 项考虑单胞内非弹性的本征应变造成的位移场的扰动.</p>
<p>式 (2) 的构造来源于细观力学 (Mura1987),
由本征应变产生的位移可以写作本征应变与 Green 函数的卷积形式 <span
class="math display">\[
u_{i}(x) = -\int L_{mnkl} G_{in,m}(x-x^{\prime}) \mu_{kl}(x^{\prime})
\mathrm{d} x^{\prime}
\tag{3}
\]</span></p>
<p>观察式 (2) 与式 (3) 相同的部分, 可以得到</p>
<p><span class="math display">\[
h_{i}^{kl}(y,y^{\prime}) = -L_{mnkl} G_{in,m}(y-y^{\prime})
\tag{4}
\]</span></p>
<div class="note info"><p>在细观力学推导 Green 函数过程中, 弹性模量 <span
class="math inline">\(L_{mnkl}\)</span> 看作是常数, 并没有出现作为
Fourier 变换后的函数 <span
class="math inline">\(\hat{L}_{mnkl}\)</span>, 但是单胞问题中, <span
class="math inline">\(L_{mnkl}\)</span> 是分段常数. 我不确定式 (4) 中
<span class="math inline">\(L_{mnkl}\)</span> 是不是关于坐标 <span
class="math inline">\(y\)</span> 或 <span
class="math inline">\(y^{\prime}\)</span>​ 的函数.</p>
</div>
<h2 id="reduced-order-green-函数在-partition-上的积分">Reduced Order:
Green 函数在 Partition 上的积分</h2>
<p>在对非均质线弹性单胞问题渐进展开的推导中, 我们得到表征单胞上应变
fluctuation 的张量场 <span class="math inline">\(E_{ij}^{kl}: Y \mapsto
\mathcal{S}\)</span>, 现在我们将要推导表征分块 Partition
上的本征应变的影响张量 <span class="math inline">\(P_{ij}^{kl}:
Y^{(\alpha)} \mapsto \mathcal{S}\)</span>.</p>
<p>多尺度在单胞上 fine-scale 应力满足平衡方程以及边界条件: <span
class="math display">\[
\nabla_{y} \cdot \sigma^{f} = 0, \quad \sigma^{f} \cdot n \in -\#
\]</span></p>
<p>将渐进展开式, 本构方程, 以及关于 <span
class="math inline">\(u_{i}^{(1)}\)</span> 的表达式 (1), (2)
代入到平衡方程中得到</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) \left[ E_{kl}^{mn}(y) \varepsilon_{mn}^c(x) +
\int_{Y} \mu_{mn}^f(x,y^{\prime}) h_{(k,y_l)}^{mn}(y,y^{\prime})
\mathrm{d} y^{\prime} - \mu_{kl}^f(x,y) \right] \right\}_{,y_j} = 0
\]</span></p>
<p>线弹性部分的单胞方程为:</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) E_{kl}^{mn}(y) \right\}_{,y_j} = 0
\]</span></p>
<p>本征应变的单胞方程为</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) \left[ \int_{Y} \mu_{mn}^f(x,y^{\prime})
h_{(k,y_l)}^{mn}(y,y^{\prime}) \mathrm{d} y^{\prime} - \mu_{kl}^f(x,y)
\right] \right\}_{,y_j} = 0
\tag{5}
\]</span></p>
<p>将单胞分成若干个 partition: <span class="math inline">\(Y^{(1)},
Y^{(2)}, \ldots, Y^{(N)}\)</span>,并假设每一个 partition
上的本征应变是相同的, 每个 partition 上的本征应变为 <span
class="math inline">\(\mu_{mn}^{(1)}(x), \mu_{mn}^{(1)}(x), \ldots,
\mu_{mn}^{(N)}(x)\)</span>, 这样得到本征应变在单胞上的分段常值分布:</p>
<p><span class="math display">\[
\mu_{mn}^{f}(x,y) = \mu_{mn}^{(\alpha)}(x) \chi^{(\alpha)}(y) \quad
\text{(使用求和约定)}
\]</span></p>
<p>代入到本征应变单胞方程 (5) 中, 得到</p>
<p><span class="math display">\[
\mu_{mn}^{(\alpha)}(x)\left\{ L_{ijkl}(y) \left[ \int_{Y}
h_{(k,y_l)}^{mn}(y,y^{\prime}) \chi^{(\alpha)}(y^{\prime}) \mathrm{d}
y^{\prime} - I_{kl}^{mn}\chi^{(\alpha)}(y) \right] \right\}_{,y_j} = 0
\]</span></p>
<p>上式是关于 <span
class="math inline">\(\mu_{mn}^{(\alpha)}(x)\)</span> 的方程组,
且方程组系数独立于方程变量. 这样, 如果方程组的解空间为 <span
class="math inline">\(\mathbb{R}_N\)</span>, 也就是对任意 <span
class="math inline">\(\mu_{mn}^{(\alpha)}(x) \in \mathbb{R}_N\)</span>,
上述方程恒成立, 则必须要求方程组系数恒等于 0:</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) \left[ \int_{Y} h_{(k,y_l)}^{mn}(y,y^{\prime})
\chi^{(\alpha)}(y^{\prime}) \mathrm{d} y^{\prime} -
I_{kl}^{mn}\chi^{(\alpha)}(y) \right] \right\}_{,y_j} = 0, \quad  \alpha
= 1,2,\ldots,N
\]</span></p>
<p>将 Green 函数在 partition 上的积分定义为</p>
<p><span class="math display">\[
P_{kl}^{mn(\alpha)}(y) = \int_{Y} h_{(k,y_l)}^{mn}(y,y^{\prime})
\chi^{(\alpha)}(y^{\prime}) \mathrm{d} y^{\prime}
\]</span></p>
<p>这样就得到关于张量 <span
class="math inline">\(P_{kl}^{mn(\alpha)}\)</span> 的 <span
class="math inline">\(N\)</span> 个方程:</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) \left[ P_{kl}^{mn(\alpha)}(y) -
I_{kl}^{mn}\chi^{(\alpha)}(y) \right] \right\}_{,y_j} = 0, \text{in}~ Y
\quad \alpha=1,2, \ldots,N
\]</span></p>
<h2
id="多尺度得到的单胞应变场与本征应变的关系">多尺度得到的单胞应变场与本征应变的关系</h2>
<p>只考虑本征应变对 fine-scale 应变的影响, 我们有如下关系式:</p>
<p><span class="math display">\[
\varepsilon_{ij}^{f}(x,y) = \int_{Y} h_{(i,y_j)}^{kl}(y,y^{\prime})
\mu_{kl}^{f}(x,y^{\prime}) \mathrm{d} y^{\prime}
\]</span></p>
<p>将 reduced order 分块均匀假设代入上式, 就得到</p>
<p><span class="math display">\[
\varepsilon_{ij}^{f}(x,y) = P_{ij}^{kl(\alpha)}(y)
\mu_{kl}^{(\alpha)}(x)
\]</span></p>
<p>在每一个分块 <span class="math inline">\(Y^{(\alpha)}\)</span> 上对
<span class="math inline">\(\varepsilon^f\)</span> 进行积分平均, 得到
<span class="math display">\[
\varepsilon_{ij}^{(\beta)}(x) = \langle P_{ij}^{kl(\alpha)}(y)
\rangle_{Y^{(\beta)}} \mu_{kl}^{(\alpha)}(x)
= P_{ij}^{kl(\beta \alpha)} \mu_{kl}^{(\alpha)}(x)
\]</span></p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>多尺度</tag>
        <tag>Green 函数</tag>
        <tag>Reduced Order</tag>
      </tags>
  </entry>
  <entry>
    <title>推导非线性本构时用到的张量运算</title>
    <url>/mechanics/%E6%8E%A8%E5%AF%BC%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%AC%E6%9E%84%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E5%BC%A0%E9%87%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="二阶张量-deviatoric-分解">二阶张量 deviatoric 分解</h2>
<p>对于二阶张量 <span
class="math inline">\(\boldsymbol{\varepsilon}\)</span>,
总可以做如下分解: <span class="math display">\[
\boldsymbol{\varepsilon}= \underbrace{\frac{1}{3} \mathrm{tr}
\left[\boldsymbol{\varepsilon}\right] \mathbf{I}}
  _{:= {\boldsymbol{\varepsilon}}^\mathrm{vol}}
  + \underbrace{\boldsymbol{\varepsilon}- \frac{1}{3} \mathrm{tr}
\left[\boldsymbol{\varepsilon}\right] \mathbf{I}}
    _{:= {\boldsymbol{\varepsilon}}^\mathrm{dev}},
\]</span> deviatoric 分解的性质为:<span id="more"></span></p>
<ol type="1">
<li><p>算子 <span class="math inline">\({(\cdot)}^\mathrm{vol}\)</span>
和 <span class="math inline">\({(\cdot)}^\mathrm{dev}\)</span>
是线性算子, <em>i.e.</em> <span class="math display">\[
{(\lambda\boldsymbol{\varepsilon}_1 +
\mu\boldsymbol{\varepsilon}_2)}^\mathrm{vol}
    = \lambda{\boldsymbol{\varepsilon}}^\mathrm{vol}_1 +
\mu{\boldsymbol{\varepsilon}}^\mathrm{vol}_2, \quad
    {(\lambda\boldsymbol{\varepsilon}_1 +
\mu\boldsymbol{\varepsilon}_2)}^\mathrm{dev}
    = \lambda{\boldsymbol{\varepsilon}}^\mathrm{dev}_1 +
\mu{\boldsymbol{\varepsilon}}^\mathrm{dev}_2,
\]</span></p></li>
<li><p>偏张量的迹等于 0: <span class="math display">\[
\mathrm{tr} \left[{\boldsymbol{\varepsilon}}^\mathrm{dev}\right] =
\mathrm{tr} \left[\boldsymbol{\varepsilon}\right] - \frac{1}{3}
\mathrm{tr} \left[\boldsymbol{\varepsilon}\right] \mathrm{tr}
\left[\mathbf{I}\right] = 0;
\]</span></p></li>
<li><p>volumatric 部分和 deviatoric 部分双点积结果为 0: <span
class="math display">\[
{\boldsymbol{\sigma}}^\mathrm{dev} :
{\boldsymbol{\varepsilon}}^\mathrm{vol} = \frac{1}{3} \mathrm{tr}
\left[\boldsymbol{\varepsilon}\right] {\boldsymbol{\sigma}}^\mathrm{dev}
: \mathbf{I}
    = \frac{1}{3} \mathrm{tr} \left[\boldsymbol{\varepsilon}\right]
\mathrm{tr} \left[{\boldsymbol{\sigma}}^\mathrm{dev} \cdot
\mathbf{I}\right] = 0.
\]</span></p></li>
</ol>
<p>性质 2 使得在计算材料的应变能密度时,
能量可以分解为由静水压力引起的应变能, 和材料畸变导致的应变能: <span
class="math display">\[
\boldsymbol{\sigma}: \boldsymbol{\varepsilon}=
{\boldsymbol{\sigma}}^\mathrm{vol}:{\boldsymbol{\varepsilon}}^\mathrm{vol}
+
{\boldsymbol{\sigma}}^\mathrm{dev}:{\boldsymbol{\varepsilon}}^\mathrm{dev},
\]</span></p>
<h2 id="四阶单位张量">四阶单位张量</h2>
<p>四阶单位张量有三种, 写成分量形式为: <span class="math display">\[
\mathcal{A}_{ijkl} = \delta_{ij}\delta_{kl}, \quad
  \mathcal{B}_{ijkl} = \delta_{ik}\delta_{jl}, \quad
  \mathcal{C}_{ijkl} = \delta_{il}\delta_{jk}.
\]</span> 定义如下两种四阶张量符号: <span class="math display">\[
\{\mathbf{I}\otimes \mathbf{I}\}_{ijkl} = \mathcal{A}_{ijkl}, \quad
  \{\mathbb{I}\}_{ijkl}  = \frac{1}{2}(\mathcal{B}_{ijkl} +
\mathcal{C}_{ijkl}).
\]</span> 二阶对称张量 <span
class="math inline">\(\boldsymbol{\sigma}\)</span> 分别与四阶单位张量
<span class="math inline">\(\mathbf{I}\otimes \mathbf{I}\)</span>, <span
class="math inline">\(\mathbb{I}\)</span> 双点积的结果为 <span
class="math display">\[
\begin{gathered}
  \mathbf{I}\otimes \mathbf{I}:\boldsymbol{\sigma}=
\boldsymbol{\sigma}:\mathbf{I}\otimes \mathbf{I}= \delta_{ij}\delta_{kl}
\sigma_{kl}
  = \delta_{ij} \sigma_{kk}
  = \mathrm{tr} \left[\boldsymbol{\sigma}\right]\mathbf{I};\\
  \mathbb{I}:\boldsymbol{\sigma}= \boldsymbol{\sigma}:\mathbb{I}=
\frac{1}{2} (\delta_{ik}\delta_{jl}\sigma_{kl}
  + \delta_{il}\delta_{jk}\sigma_{kl}
    )
    = \frac{1}{2}(\sigma_{ij}+\sigma_{ji})
    = \boldsymbol{\sigma}.\end{gathered}
\]</span> 如果用 Voigt 记法将四阶单位张量表示为矩阵的形式, 那么 <span
class="math display">\[
[\mathbf{I}\otimes \mathbf{I}]= \begin{pmatrix}
    1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}, \quad
[\mathbb{I}] = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2}
    \end{pmatrix}.
    \label{eq:idtt_voigt}
\]</span></p>
<p><span class="math inline">\([\mathbb{I}]\)</span> 在 Voigt
记法中并不是 <span class="math inline">\(\mathbb{R}^{6 \times
6}\)</span> 的单位矩阵, 这是因为 Voigt 映射规则将张量 <span
class="math inline">\(\mathcal{B}\)</span> 和 <span
class="math inline">\(\mathcal{C}\)</span> 分别映射为 <span
class="math display">\[
[\mathcal{B}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}, \quad
    [\mathcal{C}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}.
\]</span></p>
<h2
id="各向同性弹性张量的不同表示方法">各向同性弹性张量的不同表示方法</h2>
<p>对于各向同性材料, 四阶弹性模量张量 <span
class="math inline">\(L_{ijkl}\)</span> 可以用 Lame 系数表示为 <span
class="math display">\[
L_{ijkl} \triangleq \lambda \delta_{ij} \delta_{kl}
                       + \mu \delta_{ik} \delta_{jl}
                       + \mu \delta_{il} \delta_{jk},
\]</span> 将上式写成张量形式 <span
class="math inline">\(\mathbb{L}\)</span> 为 <span
class="math display">\[
\mathbb{L} = \lambda \mathbf{I}\otimes \mathbf{I}+ 2\mu \mathbb{I}.
\]</span> 同样的, 我们也可以将 柔度张量写为 <span
class="math display">\[
\mathbb{M} = -\frac{\lambda}{2\mu(3\lambda + 2\mu)}
\mathbf{I}\otimes\mathbf{I}
+ \frac{1}{2\mu} \mathbb{I}
\]</span> 也可以用常数 <span class="math inline">\(K\)</span> 与 <span
class="math inline">\(\mu\)</span>, 将 <span
class="math inline">\(\mathbb{L}\)</span> 写成类似于二阶张量 deviatoric
分解的形式: <span class="math display">\[
\mathbb{L}:= K \mathbf{I}\otimes \mathbf{I}+ 2\mu \left(\mathbb{I}-
\frac{1}{3}\mathbf{I}\otimes \mathbf{I}\right).
\tag{1}
\]</span> 式中, <span class="math inline">\(K = \lambda +
\frac{2}{3}\mu\)</span>. 又因为 <span class="math display">\[
\begin{gathered}
    \mathbf{I}\otimes \mathbf{I}:
{\boldsymbol{\varepsilon}}^\mathrm{vol} =
3{\boldsymbol{\varepsilon}}^\mathrm{vol}, \quad
    \mathbf{I}\otimes \mathbf{I}:
{\boldsymbol{\varepsilon}}^\mathrm{dev} = 0,\\
    \left(\mathbb{I}- \frac{1}{3}\mathbf{I}\otimes \mathbf{I}\right) :
{\boldsymbol{\varepsilon}}^\mathrm{vol} = 0, \quad
    \left(\mathbb{I}- \frac{1}{3}\mathbf{I}\otimes \mathbf{I}\right) :
{\boldsymbol{\varepsilon}}^\mathrm{dev} =
{\boldsymbol{\varepsilon}}^\mathrm{dev},
  \end{gathered}
\]</span> 所以如果使用式 (1) 的表示方法, 对应变的 deviatoric
分解作双点积运算, 交叉项等于 0, 由此得到更紧凑的结果: <span
class="math display">\[
\begin{aligned}
    \mathbb{L}:({\boldsymbol{\varepsilon}}^\mathrm{vol} +
{\boldsymbol{\varepsilon}}^\mathrm{dev})
    &amp;= K \mathbf{I}\otimes \mathbf{I}:
{\boldsymbol{\varepsilon}}^\mathrm{vol}
     + 2\mu \left(\mathbb{I}- \frac{1}{3}\mathbf{I}\otimes
\mathbf{I}\right):{\boldsymbol{\varepsilon}}^\mathrm{dev} \\
    &amp;= 3K {\boldsymbol{\varepsilon}}^\mathrm{vol} + 2\mu
{\boldsymbol{\varepsilon}}^\mathrm{dev}.
  \end{aligned}
\]</span></p>
<h2 id="张量导数">张量导数</h2>
<p>二阶对称张量 <span class="math inline">\(\boldsymbol{\sigma}\)</span>
对自身的导数为 <span class="math display">\[
\frac{\partial\boldsymbol{\sigma}}{\partial\boldsymbol{\sigma}} =
\mathbb{I}.
\]</span> 张量的迹<span class="math inline">\(\mathrm{tr}
\left[\boldsymbol{\sigma}\right]\)</span> 对张量 <span
class="math inline">\(\boldsymbol{\sigma}\)</span> 的导数为 <span
class="math display">\[
\frac{\partial\mathrm{tr}
\left[\boldsymbol{\sigma}\right]}{\partial\boldsymbol{\sigma}}
  = \frac{\partial\sigma_{kk}}{\partial\sigma_{ij}}
  = \delta_{ij}
  = \mathbf{I}.
\]</span> 偏张量 <span
class="math inline">\({\boldsymbol{\sigma}}^\mathrm{dev}\)</span>
对张量<span class="math inline">\(\boldsymbol{\sigma}\)</span> 的导数为
<span class="math display">\[
\frac{\partial \boldsymbol{\sigma}^{\mathrm{dev}}}{\partial
\boldsymbol{\sigma}}=\frac{\partial\left(\boldsymbol{\sigma}-\frac{1}{3}
\operatorname{tr}[\sigma] \mathbf{I}\right)}{\partial
\boldsymbol{\sigma}}=\mathbb{I}-\frac{1}{3} \mathbf{I} \otimes
\mathbf{I}
\]</span> 若二阶张量的范数定义为张量的双点积 <span
class="math display">\[
\|\boldsymbol{\sigma}\|^2 := \mathrm{tr} \left[\boldsymbol{\sigma}\cdot
\boldsymbol{\sigma}\right] = \sigma_{ij}\sigma_{ij}.
\]</span> 那么张量范数的导数为 <span class="math display">\[
\frac{\partial\|\boldsymbol{\sigma}\|}{\partial\boldsymbol{\sigma}} =
\frac{1}{2\|\boldsymbol{\sigma}\|} (\mathbb{I}:\boldsymbol{\sigma}+
\boldsymbol{\sigma}:\mathbb{I})
  = \frac{\boldsymbol{\sigma}}{\|\boldsymbol{\sigma}\|} :=
\boldsymbol{n}_{\boldsymbol{\sigma}}.
\]</span> 注意到 <span class="math display">\[
{\boldsymbol{\sigma}}^\mathrm{dev}:\mathbf{I}\otimes \mathbf{I}=
\mathrm{tr} \left[{\boldsymbol{\sigma}}^\mathrm{dev}\right]\mathbf{I}=0,
\]</span> 因此 <span class="math display">\[
\frac{\partial\left\|\boldsymbol{\sigma}^{\mathrm{dev}}\right\|}{\partial
\boldsymbol{\sigma}}=\frac{\boldsymbol{\sigma}^{\mathrm{dev}}}{\left\|\boldsymbol{\sigma}^{\mathrm{dev}}\right\|}:
\frac{\partial \boldsymbol{\sigma}^{\mathrm{dev}}}{\partial
\boldsymbol{\sigma}}=\frac{\boldsymbol{\sigma}^{\mathrm{dev}}}{\left\|\boldsymbol{\sigma}^{\mathrm{dev}}\right\|}
.
\]</span> 张量法向 <span
class="math inline">\(\boldsymbol{n}_{\boldsymbol{\sigma}}\)</span>
对张量 <span class="math inline">\(\boldsymbol{\sigma}\)</span> 求导数,
得到 <span class="math display">\[
\frac{\partial\boldsymbol{n}_{\boldsymbol{\sigma}}}{\partial\boldsymbol{\sigma}}
= \frac{1}{\|\boldsymbol{\sigma}\|}
  (\mathbb{I}- \boldsymbol{n}_{\boldsymbol{\sigma}} \otimes
\boldsymbol{n}_{\boldsymbol{\sigma}}).
\]</span></p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>本构</tag>
        <tag>张量</tag>
        <tag>计算非弹性</tag>
      </tags>
  </entry>
  <entry>
    <title>本征应变与本征应力</title>
    <url>/mechanics/%E6%9C%AC%E5%BE%81%E5%BA%94%E5%8F%98%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%BA%94%E5%8A%9B/</url>
    <content><![CDATA[<p>将应变 <span class="math inline">\(\varepsilon\)</span> 分成弹性应变
<span class="math inline">\(e\)</span> 与本征应变 <span
class="math inline">\(\mu\)</span>(nonelastic strains, 比如热膨胀, 相变,
塑性应变等)</p>
<p><span class="math display">\[
\varepsilon = e+\mu
\]</span></p>
<p>应变 <span class="math inline">\(\varepsilon\)</span> 满足协调方程
<span class="math inline">\(\varepsilon_{ij} =
\frac{1}{2}(u_{i,j}+u_{j,i})\)</span>.<span id="more"></span></p>
<div class="note info"><p>本征应变可以是<strong>不协调的</strong>:</p>
<p><img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404100950833mura1.png" /></p>
<p><span class="citation"
data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F11864068%2Fitems%2FDJK3L7F3%22%5D%2C%22locator%22%3A%2215%22%7D%5D%2C%22properties%22%3A%7B%7D%7D"
data-ztype="zcitation">(<span
class="citation-item"><span class="exturl" data-url="em90ZXJvOi8vc2VsZWN0L2xpYnJhcnkvaXRlbXMvREpLM0w3RjM=">Mura,
1987, p. 15<i class="fa fa-external-link-alt"></i></span></span>)</span></p>
<p><img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404100950877mura2.png" />
<span class="citation"
data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F11864068%2Fitems%2FDJK3L7F3%22%5D%2C%22locator%22%3A%2221%22%7D%5D%2C%22properties%22%3A%7B%7D%7D"
data-ztype="zcitation">(<span
class="citation-item"><span class="exturl" data-url="em90ZXJvOi8vc2VsZWN0L2xpYnJhcnkvaXRlbXMvREpLM0w3RjM=">Mura,
1987, p. 21<i class="fa fa-external-link-alt"></i></span></span>)</span></p>
<p>详细介绍可以看 Mura 第 7 章 dislocations.</p>
</div>
<p>本征应变在自由体中 (i.e., 没有体力项, 且没有边界面上的约束)
中产生本征应力 <span class="math inline">\(\sigma\)</span>,
满足平衡方程, 胡克定律, 以及边界条件:</p>
<p><span class="math display">\[
\nabla \cdot \sigma = 0,\quad \sigma = L:e, \quad \sigma \cdot n = 0
\]</span></p>
<p>将上式与应变分解式结合, 得到关于位移场 <span
class="math inline">\(u_i\)</span> 的方程:</p>
<p><span class="math display">\[
L_{ijkl}~u_{k,lj} + \underbrace{(-L_{ijkl}~\mu_{kl,j})}_{:=X_i} = 0 \\
L_{ijkl}~u_{k,l}~n_j = L_{ijkl}~\mu_{kl}~n_j
\]</span></p>
<p>通过上式, 可以将本征应变 <span class="math inline">\(\mu\)</span>
在自由体中对位移场的扰动看作引入体力项 <span
class="math inline">\(-L_{ijkl}~\mu_{kl,j}\)</span> 和面力项 <span
class="math inline">\(L_{ijkl}~\mu_{kl}~n_j\)</span>.</p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>Eshelby 问题</tag>
        <tag>细观力学</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性计算中的增量步与迭代方法</title>
    <url>/mechanics/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%A2%9E%E9%87%8F%E6%AD%A5%E4%B8%8E%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>参考文献:</strong></p>
<p><strong>M.A.Crisfield, Non-linear Finite Element Analysis of Solids
and Structures.</strong></p>
<h2 id="算例简述">算例简述</h2>
<p>本算例是希望通过一个简单的一维系统，给出非线性计算过程中<strong>增量步</strong>的概念，这是线性与非线性有限元计算之间一个很大的区别。</p>
<p>我们准备分析的系统如图所示</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404160956053分析系统示意图.png" alt="分析系统示意图" style="zoom: 20%;" /></p>
<span id="more"></span>
<p>几何以及材料参数设置如下:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">L = <span class="number">2500</span>; <span class="comment">% initial truss length</span></span><br><span class="line">z =   <span class="number">25</span>; <span class="comment">% initial offset(no stress)</span></span><br><span class="line">E =  <span class="number">5e7</span>; <span class="comment">% Young&#x27;s modulus</span></span><br><span class="line">A =    <span class="number">1</span>; <span class="comment">% cross-section area</span></span><br><span class="line">d = <span class="built_in">sqrt</span>(L^<span class="number">2</span> - z^<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="系统-位移-外载-关系的解析求解">系统 位移-外载
关系的解析求解</h2>
<p>该系统外载 <span class="math inline">\(W\)</span> 与位移 <span
class="math inline">\(w\)</span>
之间的解析关系是可以得到的，我们将推导这一关系，并用来衡量之后数值算法的准确性。</p>
<p>杆原长为 <span class="math inline">\(L\)</span>，变形后杆长度 <span
class="math inline">\(l\)</span> 为： <span class="math display">\[
l=\sqrt{(z+w)^2 +d^2 }
\]</span> 杆的变形量 <span class="math inline">\(\Delta l\)</span> 为
<span class="math display">\[
\Delta l \triangleq l-L=\sqrt{(z+w)^2 +d^2 }-L
\]</span> 在我们的符号约定下，<span class="math inline">\(\Delta
l\)</span> 正值表示拉伸，负值表示压缩。根据定义，杆的应变为 <span
class="math display">\[
\varepsilon \triangleq \frac{\Delta l}{L}
=\frac{\sqrt{(z+w)^2 +d^2 }-L}{L}
=\sqrt{ {\left( \frac{w}{L} \right)}^2 +2\left( \frac{zw}{L^2 }
\right)+1 } - 1
\]</span> 若假设 <span class="math display">\[
L\gg z, L \gg w
\tag{1}
\]</span> 那么有如下近似关系： <span class="math display">\[
\varepsilon \approx \frac{z}{L^2}w+\frac{1}{2L^2}w^2
\]</span></p>
<p>根据受力示意图，系统内力 <span class="math inline">\(N\)</span> 和
<span class="math inline">\(P\)</span> 与外载 <span
class="math inline">\(W\)</span> 之间的平衡关系为： <span
class="math display">\[
W = N \sin\theta + P
\tag{2}
\]</span> 又因为假设的小量关系（1），所以 <span class="math inline">\(l
\approx L\)</span>，因此 <span class="math inline">\(\sin
\theta\)</span> 可以近似表示为 <span class="math display">\[
\sin \theta = \frac{z+w}{l} \approx \frac{z+w}{L}
\tag{3}
\]</span> 杆材料的本构关系将应变 <span
class="math inline">\(\varepsilon\)</span> 与杆的内力 <span
class="math inline">\(N\)</span> 联系起来： <span
class="math display">\[
N=EA\varepsilon =EA\left( \frac{z}{L^2}w+\frac{1}{2L^2}w^2 \right)
\tag{4}
\]</span> 根据弹簧的本构关系，弹簧力 <span
class="math inline">\(P\)</span> 为 <span class="math display">\[
P=K_{\mathrm{s}} w
\tag{5}
\]</span> 将式（3）（4）（5） 代入到式（2） 中，可以得到外载 <span
class="math inline">\(W\)</span> 与位移 <span
class="math inline">\(w\)</span> 的关系为 <span class="math display">\[
W = EA\left(
\frac{zw}{L^2}+\frac{1}{2}{ \left(\frac{w}{L}\right)}^2
\right) \frac{w+z}{L}+K_{ \mathrm{s} } w
= \frac{EA}{L^3 }\left(z^2 w+\frac{3}{2}zw^2 +\frac{1}{2}w^3 \right)+K_{
\mathrm{s} } w
\tag{6}
\]</span> 可以看到，外载与位移之间的关系是非线性的，我们可以用 MATLAB
作出位移-外载关系曲线的解析解：</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161017053力位移曲线-解析方法.png" alt="力位移曲线-解析方法" style="zoom: 50%;" /></p>
<h2 id="系统-位移-外载-关系的数值求解">系统 位移-外载
关系的数值求解</h2>
<p>接下来，我们将使用不同的数值方法来求解 位移-外载 曲线。</p>
<h3 id="增量步方法">增量步方法</h3>
<p>在陈述增量步方法之前，我们还是需要再强调一下线性问题与非线性问题之间的区别。对于线性问题，位移-外载曲线是一条<strong>直线</strong>。因此，求解一次系统方程得到
<span class="math inline">\((w_0 ,W_0
)\)</span>，就能够知道系统在任意外载 <span
class="math inline">\(W\)</span> 下的位移响应 <span
class="math inline">\(w\)</span>：</p>
<p><span class="math display">\[
w=\frac{w_0 }{W_0 }W
\]</span></p>
<p>但在本例中，位移-外载曲线并不是直线，我们不可能像线性问题一样，让外载「一步到位」，直接得到最终的加载结果。不过，我们可以将<strong>整个加载过程分成多个增量步</strong>，在增量步足够小的时候，系统的响应总是可以看作是
「线性」的。</p>
<p>我们将加载过程分成 <span class="math inline">\(N\)</span>
步，每一步的增量为 <span class="math inline">\(\Delta
W_n\)</span>。为了方便陈述系统在每一个加载点的状态，我们引入「加载时间」<span
class="math inline">\(t\)</span>，它与增量步之间的关系可以用下面的数轴来描述：</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161325025加载时间轴.png" alt="image-20240416132502849" style="zoom:67%;" /></p>
<div class="note info"><p>加载时间 <span class="math inline">\(t\)</span>
并不等同于真实的物理时间。</p>
</div>
<p>在该增量步下，如果使用显式方法计算（<span
class="math inline">\(t_{n+1}\)</span> 时刻的未知量可全部由 <span
class="math inline">\(t_{n}\)</span> 时刻的已知量计算得到），位移增量
<span class="math inline">\(\Delta w_{n+1}\)</span> 为 <span
class="math display">\[
\Delta w_{n+1}:={\left( \left. \frac{\mathrm{d}W}{\mathrm{d}w}
\right|_{t_{n}} \right)}^{-1} \Delta W_{n+1}=K_{n}^{-1} \Delta W_{n+1}
\tag{7}
\]</span></p>
<p>式中，<span class="math inline">\(K_{n}\)</span> 为外载 <span
class="math inline">\(W\)</span> 对位移 <span
class="math inline">\(w\)</span> 在 <span
class="math inline">\(t_{n}\)</span> 时刻的导数：</p>
<p><span class="math display">\[
K_{n} \triangleq \left. \frac{\mathrm{d} W}{\mathrm{d} w} \right|_{t_n}
=\frac{EA}{L}{\left(\frac{z}{L}\right)}^2 +\frac{EA}{L}\left(\frac{2zw_n
+ w_n^2 }{L^2 }\right)+\frac{N}{L}+K_{\mathrm{s}}
\]</span></p>
<p>式中，<span class="math inline">\(w_n = \sum_{k=1}^{n} \Delta
w_{k}\)</span>，<span class="math inline">\(n=0\)</span> 时 <span
class="math inline">\(w_n=0\)</span>。对于第一次的增量步，位移 <span
class="math inline">\(w_0 = 0\)</span>，杆中的内力 <span
class="math inline">\(N_0=0\)</span>，由此计算得到点 <span
class="math inline">\((0,0)\)</span> 处的 <span
class="math inline">\(K_{n}\)</span> 为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">K = <span class="number">3.3500</span></span><br></pre></td></tr></table></figure>
<p>下一步的位移增量 <span class="math inline">\(\Delta w_1\)</span>
为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">dw = <span class="number">-2.0896</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161048401增量步计算结果.png" alt="增量步计算结果" style="zoom:50%;" /></p>
<p>多个增量步累积计算的结果为</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161051373增量步方法结果.png" alt="增量步方法结果" style="zoom: 50%;" /></p>
<p>需要指出的是，只使用显式增量步方法得到的结果，<strong>系统内力与外载并不是平衡的</strong>。例如在第一个增量步时，外载增量
<span class="math inline">\(\Delta W_1 = -7\)</span>，对应位移增量为
<span class="math inline">\(\Delta w_1\)</span> 为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">dw = <span class="number">-2.0896</span></span><br></pre></td></tr></table></figure>
<p>代入式（4）中内力的计算公式，并在外载方向投影，得到杆内力与弹簧力之和为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">f_ext = <span class="number">-6.4908</span></span><br></pre></td></tr></table></figure>
<p>由此可见系统的内力与外载并不相等： <span class="math display">\[
-7=f^{\mathrm{ext}} \neq f^{\mathrm{int}} = -6.4908
\]</span></p>
<h3 id="迭代法求解">迭代法求解</h3>
<p>我们已经看到，如果只使用显式增量步计算，系统内外力并不是平衡的。系统内外力的差值可以定义为如下残差函数
<span class="math inline">\(g(w)\)</span> ：</p>
<p><span class="math display">\[
g(w) \triangleq \frac{EA}{L^3 }\left(z^2 w+\frac{3}{2}zw^2
+\frac{1}{2}w^3 \right)+K_{\mathrm{s}} w-W
\]</span></p>
<p>对给定的外载 <span
class="math inline">\(W\)</span>，真实位移应使得残差函数 <span
class="math inline">\(g(w) \equiv
0\)</span>。我们在增量步计算过程中，即使在 <span
class="math inline">\(t_n\)</span>
时刻可以保证系统内外力平衡，由于我们对系统在 <span
class="math inline">\(\Delta W_{n+1}\)</span> 增量步的线性假设，在 <span
class="math inline">\(t_{n+1}\)</span> 时刻的系统内外力一般并不平衡：
<span class="math display">\[
g(w_{n+1}^{(0)}) \neq 0
\]</span> 式中，<span class="math inline">\(w_{n+1}^{(0)}\)</span>
表示直接通过式（7）得到的结果。我们可以将 <span
class="math inline">\(w_{n+1}^{(0)}\)</span> 作为 Newton
迭代法的初值，迭代得到更好的位移增量 <span
class="math inline">\(w_{n+1}^{(i+1)}\)</span>： <span
class="math display">\[
\Delta w_{n+1}^{(i+1)} = -\left(
\left. \frac{\mathrm{d}g}{\mathrm{d}w} \right|_{w_{n+1}^{(i)}}
\right)^{-1}  
g( w_{n+1}^{(i)}), \quad
w_{n+1}^{(i+1)} = w_{n+1}^{(i)} + \Delta w_{n+1}^{(i+1)}
\tag{8}
\]</span></p>
<p>我们可以通过如下公式衡量迭代算法的收敛速度。如果方程在前后两次迭代步的残差满足
<span class="math display">\[
\frac{|g( w_{n+1}^{(i+1)})|}{|g( w_{n+1}^{(i)})|^M} \approx \text{Const}
\]</span> 那么该迭代算法收敛速度是 <span
class="math inline">\(M\)</span>
阶的。也就是说，每次迭代的残差与前一次迭代的 <span
class="math inline">\(M\)</span>
次方在量级上保持一致。例如在本问题中，收敛残差比值打印出的结果为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.009203</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.030338</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.064449</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.066711</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.099625</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.099167</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">73.914835</span></span><br></pre></td></tr></table></figure>
<p>所以算法（8）是平方收敛的（最后一步是因为达到了计算机浮点数精度）。这个算法的收敛速度是很快的，例如我们的初值的残差是
<code>E-01</code> 量级的，而计算机浮点数精度为
<code>E-16</code>。那么对于平方收敛算法，只需要迭代 <span
class="math display">\[
\left( \left( \left( \left( \square^{-1} \right)^2 \right)^2 \right)^2
\right)^2 = \square^{-16}
\]</span> <strong>4</strong>
次就可以收敛到浮点数的精度！但是，需要指出的是，算法（8）的每一次迭代过程中，都需要重新计算
<span class="math inline">\(\left( \left.
\frac{\mathrm{d}g}{\mathrm{d}w} \right|_{w_{n+1}^{(i)}}
\right)^{-1}\)</span>​，所以才能达到
平方阶的收敛速度。在本算例中可能无法体现（切线刚度矩阵为标量），但对于更复杂的非线性系统，计算切线刚度矩阵是非常消耗时间的。</p>
<p>不过，保证收敛的迭代算法并不是唯一的。我们可以放松对收敛速度的要求，降低计算切线刚度矩阵的难度。一种方法是，在计算得到第一次迭代时计算得到的切线刚度矩阵后，我们将它作为后续迭代中刚度矩阵的近似：
<span class="math display">\[
\Delta w_{n+1}^{(i+1)} = -\left(
\left. \frac{\mathrm{d}g}{\mathrm{d}w} \right|_{
w_{n+1}^\textcolor{red}{(0)} }
\right)^{-1}  
g( w_{n+1}^{(i)}), \quad
w_{n+1}^{(i+1)} = w_{n+1}^{(i)} + \Delta w_{n+1}^{(i+1)}
\tag{9}
\]</span>
算法（9）的收敛速度没有算法（8）速度那么快。例如算例在使用算法（9）时的一个加载步的迭代过程为：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Current load step: <span class="number">1</span> </span><br><span class="line">Current iteration step: <span class="number">1</span>; The out of balance force is <span class="number">9.5086E-02</span></span><br><span class="line">Current iteration step: <span class="number">2</span>; The out of balance force is <span class="number">6.0843E-03</span></span><br><span class="line">Current iteration step: <span class="number">3</span>; The out of balance force is <span class="number">3.9566E-04</span></span><br><span class="line">Current iteration step: <span class="number">4</span>; The out of balance force is <span class="number">2.5756E-05</span></span><br><span class="line">Current iteration step: <span class="number">5</span>; The out of balance force is <span class="number">1.6768E-06</span></span><br><span class="line">Current iteration step: <span class="number">6</span>; The out of balance force is <span class="number">1.0916E-07</span></span><br><span class="line">Current iteration step: <span class="number">7</span>; The out of balance force is <span class="number">7.1064E-09</span></span><br><span class="line">Current iteration step: <span class="number">8</span>; The out of balance force is <span class="number">4.6264E-10</span></span><br><span class="line">Current iteration step: <span class="number">9</span>; The out of balance force is <span class="number">3.0118E-11</span></span><br><span class="line">Current iteration step: <span class="number">10</span>; The out of balance force is <span class="number">1.9611E-12</span></span><br><span class="line">Current iteration step: <span class="number">11</span>; The out of balance force is <span class="number">1.2745E-13</span></span><br></pre></td></tr></table></figure>
<p>算法（8）和（9）在每一个加载步的迭代过程可以用下图清晰地表示出来：</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161457984切线刚度矩阵.png" alt="sln_iteration" style="zoom:40%;" /></div><div class="group-picture-column"><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161456503切线刚度矩阵.png" alt="sln_same_slope" style="zoom: 20%;" /></div></div></div>
<p>最终，我们给出在使用增量步，并对每一个增量步的结果进行 Newton
迭代，使得内力等于外载后得到的数值计算结果：</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161503122最终数值结果.png" alt="sln_inc_iter" style="zoom: 67%;" /></p>
<p>从上图可以看到，如果我们在非线性计算中</p>
<ul>
<li>减小增量步的步长；</li>
<li>在每一个增量步进行迭代，使得残差小于某一个阈值</li>
</ul>
<p>那么就能够得到相当不错的结果。</p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>非线性有限元</tag>
        <tag>刚度矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>等效夹杂方法</title>
    <url>/mechanics/%E7%AD%89%E6%95%88%E5%A4%B9%E6%9D%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>考虑如下场景: 一个无穷大的弹性体 D 中嵌入一个椭球形状的夹杂 <span
class="math inline">\(\Omega\)</span>, 如果夹杂的弹性模量 <span
class="math inline">\(C^*_{ijkl}\)</span><strong>与周围弹性体的弹性模量</strong><span
class="math inline">\(C_{ijkl}\)</span> 不同,
则称该夹杂为<strong>非均质夹杂</strong>. 因为非均质夹杂的存在,
其附近的应力场会发生改变. 考虑无穷远处的应变场强度为 <span
class="math inline">\(\varepsilon^0\)</span>, 对应的应力场为 <span
class="math inline">\(\sigma^0 = C : \varepsilon^0\)</span>,
应变与应力场扰动量分别为 <span
class="math inline">\(\varepsilon\)</span> 和 <span
class="math inline">\(\sigma\)</span>, 因此真实的位移和应力为 <span
class="math inline">\(u_i^0 + u_i\)</span> 和 <span
class="math inline">\(\sigma^0 + \sigma\)</span>.<span id="more"></span></p>
<p>应力扰动项 <span class="math inline">\(\sigma\)</span>
满足应力平衡方程(不考虑外力),
以及在无穷远处等于0(或者在有限区域表面等于0)</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
\nabla \cdot \sigma = 0\\
\sigma \cdot n = 0
\end{aligned}
\right.
\]</span></p>
<p>在夹杂内外满足本构方程:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
&amp; \sigma^0+\sigma=\textcolor{red}{L^* :
\left(\varepsilon^0+\varepsilon-\mu\right)} \quad \text { in } \Omega,
\\
&amp; \sigma^0+\sigma=L : \left(\varepsilon^0+\varepsilon\right) \quad
\text { in } D-\Omega .
\end{aligned}
\right.
\tag{1}
\]</span></p>
<p>而 Eshelby 方法所解决的原始问题是: 考虑无穷大的弹性体,
其中嵌入一个椭球夹杂, 该夹杂弹性模量与弹性体<strong>一致</strong>,
然而夹杂内给定常数值的本征应变 <span class="math inline">\(\mu\)</span>,
由此, Eshelby 问题所满足的本构方程为</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
&amp; \sigma^0+\sigma=\textcolor{red}{L :
\left(\varepsilon^0+\varepsilon-\tilde{\mu}\right)} \text { in } \Omega,
\\
&amp; \sigma^0+\sigma=L : \left(\varepsilon^0+\varepsilon\right) \text {
in } D-\Omega .
\end{aligned}
\right.
\tag{2}
\]</span></p>
<p>若令这两类问题等价, 则充要条件是方程组 (1) (2) <span
class="math inline">\(\Omega\)</span> 内的方程右端项相等</p>
<p><span class="math display">\[
L^* : \left(\varepsilon^0+\varepsilon-\mu\right) = L :
\left(\varepsilon^0+\varepsilon-\tilde{\mu}\right) \text { in } \Omega
\tag{3}
\]</span></p>
<p>求解 Eshelby 本征应变问题可以得到等效本征应变 <span
class="math inline">\(\tilde{\mu}\)</span> 与夹杂内外由夹杂引起的应变场
<span class="math inline">\(\varepsilon\)</span> 之间的关系:</p>
<p><span class="math display">\[
\begin{align}
  \varepsilon &amp;= S:\tilde{\mu} \quad x \text{ in } \Omega,\\
  \varepsilon(x) &amp;= D(x):\tilde{\mu} \quad x \text{ in } D-\Omega,
\end{align}
\]</span></p>
<p>将这一关系代入到式 (3) 中, 给定远端应力 <span
class="math inline">\(\varepsilon^0\)</span>, 以及夹杂上的本征应变 <span
class="math inline">\(\mu\)</span>, 就可以得到关于等效本征应变 <span
class="math inline">\(\tilde{\mu}\)</span> 所满足的方程:</p>
<p><span class="math display">\[
L^* : \left(\varepsilon^0+\varepsilon(\tilde{\mu})-\mu\right) = L :
\left(\varepsilon^0+\varepsilon(\tilde{\mu})-\tilde{\mu}\right) \text {
in } \Omega
\]</span></p>
<p>或者写成</p>
<p><span class="math display">\[
\delta L : \varepsilon(\tilde{\mu}) + L:\tilde{\mu} = -\delta L :
\varepsilon^0 + L^{*} : \mu, \quad \delta L = L^{*} - L
\]</span></p>
<p>如果 Eshelby 问题已经解出, 那么就可以得到整个区域上的应变场 <span
class="math inline">\(\varepsilon\)</span>.</p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>Eshelby 问题</tag>
        <tag>细观力学</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hill 参数表示横观各向同性的材料矩阵</title>
    <url>/mechanics/%E4%BD%BF%E7%94%A8-Hill-%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%A8%AA%E8%A7%82%E5%90%84%E5%90%91%E5%90%8C%E6%80%A7%E7%9A%84%E6%9D%90%E6%96%99%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>参考文献：Micromechanics of Composite Materials，George J.
Dvorak，section 2.3</p>
<p>Hill（1964）给出一种横观各向同性材料更紧凑的表达方式： <span
class="math display">\[
\left[\begin{array}{l}
\sigma_{11} \\
\sigma_{22} \\
\sigma_{33} \\
\sigma_{23} \\
\sigma_{31} \\
\sigma_{12}
\end{array}\right]=\left[\begin{array}{cccccc}
n &amp; l &amp; l &amp; 0 &amp; 0 &amp; 0 \\
l &amp; k+m &amp; k-m &amp; 0 &amp; 0 &amp; 0 \\
l &amp; k-m &amp; k+m &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; m &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; p &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; p
\end{array}\right]\left[\begin{array}{c}
\varepsilon_{11} \\
\varepsilon_{22} \\
\varepsilon_{33} \\
2 \varepsilon_{23} \\
2 \varepsilon_{31} \\
2 \varepsilon_{12}
\end{array}\right]
\]</span> 式中 1 方向为纤维主方向，参数 <span
class="math inline">\(k,l,n,m,p\)</span>
与横观各向同性的工程常数之间的对应关系为<span id="more"></span> <span
class="math display">\[
\left.
\begin{aligned}
k=\left[ 2\frac{1-v_{23}}{E_{22}} - 4 \frac{v_{12}^2}{E_{11}}
\right]^{-1} \quad
l=2 k v_{12} \\
n=E_{11}+4 k v_{12}^2 = E_{11} + \frac{l^2}{k} \quad
m=G_{23} \quad
p=G_{21}
\end{aligned}
\right\}
\]</span></p>
<p><span class="math display">\[
\left.
\begin{aligned}
E_{11} = n - l^2/k \quad
v_{12} = l/2 k \quad
v_{21} = E_{22} v_{12} / E_{11} \\
E_{22} = E_{33} = \frac{4 m\left(k n-l^2\right)}{n(k+m)-l^2} \quad
v_{23} = v_{32}=\frac{n(k-m)-l^2}{n(k+m)-l^2}
\end{aligned}
\right\}
\]</span></p>
<p>为验证上述公式，我们不妨代入各向同性的材料参数，那么该公式最终应退化为各向同性的材料矩阵：
<span class="math display">\[
k = \frac{E}{2(1+\nu)(1-2\nu)} = \lambda + \mu, \quad
l = \frac{\nu E}{(1+\nu)(1-2\nu)} = \lambda, \quad
n = \frac{\mu(3\lambda + 2\mu)}{\lambda + \mu} +
\frac{\lambda^2}{\lambda+\mu} = \lambda + 2\mu
\]</span> 以及 <span class="math display">\[
m = p = \mu
\]</span> 值得指出的是，使用 Hill
参数表示横观各向同性材料刚度矩阵，关系式 <span class="math display">\[
\frac{C_{33} - C_{32}}{2} = C_{44}
\]</span>
更方便直接看出。这也是横观各向同性材料与一般的正交各向异性材料之间的差别</p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>弹性力学</tag>
        <tag>横观各向同性</tag>
      </tags>
  </entry>
  <entry>
    <title>Fourier-方法分析-Hashin-Shtrikman-变分原理</title>
    <url>/mechanics/Fourier-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90-Hashin-Shtrikman-%E5%8F%98%E5%88%86/</url>
    <content><![CDATA[<p>Hashin-Shtrikman 变分原理中给出的泛函表达式为 <span
class="math display">\[
U^p (p_{ij}, \widetilde\varepsilon_{ij})
= \underbrace{\frac{1}{2}\int \bar\sigma_{ij}
\bar\varepsilon_{ij}\mathrm{d} y}_{\triangleq \bar U}
+ \underbrace{\frac{1}{2} \int p_{ij}(y) \widetilde\varepsilon_{ij}(y)
\mathrm{d} y}_{\triangleq \widetilde U}
- \frac{1}{2} \int \left( p_{ij}(y)~\delta L_{ijkl}^{-1}(y)~p_{kl}(y) -
2p_{ij}(y) \bar\varepsilon_{ij}\right)  \mathrm{d} y
\]</span> <span id="more"></span>对二阶张量进行 dev 分解 <span
class="math display">\[
\begin{aligned}
p_{ij} &amp;= p \delta_{ij} + f_{ij} \\
\bar\varepsilon_{ij} &amp;= \bar\varepsilon \delta_{ij} + \bar e_{ij}
\end{aligned}
\]</span> 代入到泛函表达式当中 <span class="math display">\[
U^p = \bar U + \widetilde U - \frac{1}{2} \int
\left(\frac{p^2}{K-K^0} + \frac{f_{ij} f_{ij}}{2(G-G^0)}
-6 p \bar\varepsilon-2 f_{i j} \bar e_{i j}\right) \mathrm{d} y
\]</span> 我们希望得到使用极化应力表示的 <span
class="math inline">\(\widetilde U\)</span> 项表达式, 但是 <span
class="math inline">\(\widetilde U\)</span>
项考量的是极化应力与应变扰动量之间的相互作用, 所以包含未知量 <span
class="math inline">\(\widetilde \varepsilon_{ij}\)</span>​. 幸运的是,
我们考察的 <span class="math inline">\(\widetilde U\)</span> 是能量项,
而根据 Fourier 分析中的 Parseval 公式,
在相空间中的能量内积等于物理空间中的能量内积: <span
class="math display">\[
\widetilde U = \frac{1}{2} \int p_{ij}(y) \widetilde \varepsilon_{ij}(y)
~\mathrm{d} y
\equiv \frac{1}{2} \int \widehat p_{ij}(\xi)
\widehat{\widetilde{u}}_{i,j}^{*}(\xi) ~\mathrm{d} \xi
\tag{0}
\]</span> 并且, 在 Fourier 变换下, 可以找到应变与极化应力的代数表达式.
式 (0) 中, <span class="math inline">\(\widehat{p}_{ij}\)</span>, <span
class="math inline">\(\widehat{\widetilde{u}}_{i,j}\)</span> 表示场变量
<span class="math inline">\(p_{ij}\)</span>, <span
class="math inline">\(\widetilde{u}_{i,j}\)</span> 的 Fourier 变换,
<span class="math inline">\(\square^{*}\)</span>​ 表示共轭复数, 三维的
Fourier 变换定义为</p>
<p><span class="math display">\[
\mathscr{F}[f(y)](\xi) \triangleq \left( \frac{1}{2 \pi} \right)^{3/2}
\int_{\mathbb{R}^3} f(y) e^{-i \xi \cdot y} \mathrm{d} y
\]</span></p>
<p>我们现在希望找到相空间中 <span
class="math inline">\(\widehat{p}_{ij}\)</span>, <span
class="math inline">\(\widehat{\widetilde{u}}_{i,j}\)</span> 之间的关系,
不过首先给出单胞上所满足的微分方程的 statement. 单胞上的控制方程为 <span
class="math display">\[
\left( L_{ijkl}^{0} \widetilde \varepsilon_{kl} + \widetilde p_{ij}
\right)_{,j} = 0
\tag{1}
\]</span> 以及小变形的几何方程 <span class="math display">\[
\widetilde \varepsilon_{kl} = \frac{1}{2} (\widetilde{u}_{k,l} +
\widetilde{u}_{l,k})
\tag{2}
\]</span> 和齐次位移边界条件: <span class="math display">\[
\widetilde{u}_k(\partial Y) = 0
\tag{3}
\]</span> 方程 (1) 中的 <span
class="math inline">\(\widetilde{p}_{ij}\)</span> 表征极化应力的扰动,
定义为 <span class="math display">\[
\widetilde{p}_{ij} \triangleq p_{ij} - \bar{p}_{ij}
\tag{4}
\]</span> 接下来, 对控制方程 (1) 几何方程 (2) 作 Fourier 变换得到 <span
class="math display">\[
i\xi_j \left( L_{ijkl}^{0} \widehat{ \widetilde{\varepsilon} }_{kl}   +
\widehat{ \widetilde{p} }_{ij} \right) = 0
\]</span> 和 <span class="math display">\[
\widehat{\widetilde{\varepsilon} }_{kl} = \frac{1}{2} i(\xi_l
\widehat{\widetilde{u}}_{k} + \xi_k \widehat{\widetilde{u}}_{l})
\]</span> 将各向同性材料的弹性模量 <span class="math display">\[
L_{ijkl}^{0} = \lambda^0 \delta_{ij} \delta_{kl} + \mu^{0} \delta_{ik}
\delta_{jl} + \mu^{0} \delta_{il} \delta_{jk}
\]</span> 和应变的 Fourier 表达式代入到控制方程的 Fourier 变换式中,
得到关于 <span class="math inline">\(\widehat{\widetilde{u}}_j\)</span>
的代数方程: <span class="math display">\[
(\lambda^0 + \mu^0) \xi_i \xi_k \widehat{\widetilde{u}}_k + \mu^0 \xi^2
\widehat{\widetilde{u}}_i
= i \xi_j \widehat{\widetilde{p}}_{ij}
\]</span> 式中, <span class="math inline">\(\xi^2 = \xi_{kk}\)</span>.
上述方程左端的系数矩阵为 <span class="math display">\[
A \triangleq \mu^0 \xi^{T} \xi ~\mathbf{I} + (\lambda^0 + \mu^0)\xi
\xi^{T}
= \mu^0 \xi^2 \mathbf{I}
+ (\lambda^0 + \mu^0)
\begin{pmatrix}
\xi_1 \xi_1 &amp; \xi_1 \xi_2 &amp; \xi_1 \xi_3 \\
\xi_2 \xi_1 &amp; \xi_2 \xi_2 &amp; \xi_2 \xi_3 \\
\xi_3 \xi_1 &amp; \xi_3 \xi_2 &amp; \xi_3 \xi_3
\end{pmatrix}
\]</span> 式中, <span class="math inline">\(\mathbf{I}\)</span> 为 3
阶单位矩阵. 对于形式为 <span class="math inline">\(I + \alpha
vv^T\)</span> 的矩阵, 其逆矩阵的形式为 <span class="math inline">\(I +
\beta vv^T\)</span>, 矩阵 <span class="math inline">\(A\)</span>
的逆求解得到 <span class="math display">\[
A^{-1} = \frac{1}{\mu^0} \frac{1}{\xi^2} \mathbf{I}
- \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)}
\frac{1}{(\xi^2)^2} \xi \xi^{T}
\]</span> 所以, <span
class="math inline">\(\widehat{\widetilde{u}}_{i}\)</span>
可以被显式地用 <span
class="math inline">\(\widehat{\widetilde{p}}_{ij}\)</span> 表示为 <span
class="math display">\[
\widehat{\widetilde{u}}_{i} = i \frac{1}{\mu^0} \frac{\xi_k}{\xi^2}
\widehat{\widetilde{p}}_{ik}
- i\frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{\xi_i
\xi_k \xi_l}{(\xi^2)^2} \widehat{\widetilde{p}}_{kl}
\]</span> 根据 Fourier 对导函数的变换规则, 只需要对上式两边乘 <span
class="math inline">\(i \xi_j\)</span>, 就可以得到关于 <span
class="math inline">\(\widehat{\widetilde{u}}_{i,j}\)</span> 的 Fourier
变换 <span class="math display">\[
\widehat{\widetilde{u}}_{i,j} = i \xi_j \widehat{\widetilde{u}}_{i}
= - \frac{1}{\mu^0} \frac{\xi_j\xi_k}{\xi^2}
\widehat{\widetilde{p}}_{ik}
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{\xi_i \xi_j
\xi_k \xi_l}{(\xi^2)^2} \widehat{\widetilde{p}}_{kl}
\]</span></p>
<p>代入到式 (0) 中得到 <span class="math display">\[
\widetilde U
= \frac{1}{2} \int \widehat{\widetilde{p}}_{ij}
\widehat{\widetilde{u}}_{i,j}^{*} ~\mathrm{d} \xi
= \frac{1}{2} \int \left(
- \frac{1}{\mu^0} \frac{\xi_j\xi_k}{\xi^2} \widehat{\widetilde{p}}_{ij}
\widehat{\widetilde{p}}_{ik}^{*}
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{\xi_i \xi_j
\xi_k \xi_l}{(\xi^2)^2} \widehat{\widetilde{p}}_{ij}
\widehat{\widetilde{p}}_{kl}^{*}
\right)~\mathrm{d} \xi
\tag{5}
\]</span> 如果我们假设极化应力是各向同性函数, 也就是说, 极化应力场 <span
class="math inline">\(p_{ij}(y)\)</span> 可以通过函数 <span
class="math inline">\(P_{ij}(r): \mathbb{R} \mapsto
\mathbb{S}^2\)</span> 表示: <span class="math display">\[
\widetilde p_{ij}(y) \equiv \widetilde P_{ij}(|y|)
\]</span> 如果函数在物理空间中是各向同性函数,
那么在相空间中也是各向同性函数 <span class="math display">\[
\widehat{\widetilde{p}}_{ij}(\xi) \equiv
\widehat{\widetilde{P}}_{ij}(|\xi|)
\]</span> 代入到式 (5) 中, 得到用各向同性函数 <span
class="math inline">\(P_{ij}(r)\)</span> 表示的积分 <span
class="math display">\[
2 \widetilde U
= \int \left(
- \frac{1}{\mu^0} \frac{\xi_j\xi_k}{\xi^2}
\widehat{\widetilde{P}}_{ij}(|\xi|)
\widehat{\widetilde{P}}_{ik}^{*}(|\xi|)
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{\xi_i \xi_j
\xi_k \xi_l}{(\xi^2)^2} \widehat{\widetilde{P}}_{ij}(|\xi|)
\widehat{\widetilde{P}}_{kl}^{*}(|\xi|)
\right)~\mathrm{d} \xi
\tag{6}
\]</span> 如果将式 (6) 转换到球坐标系下进行积分 <span
class="math display">\[
\xi_1 = r \sin\theta \cos\phi, \quad
\xi_2 = r \sin\theta \sin\phi, \quad
\xi_3 = r \cos\theta , \quad
\mathrm{d} \xi_1 ~\mathrm{d} \xi_2 ~\mathrm{d} \xi_3
= r^2 \sin \theta ~\mathrm{d} r ~\mathrm{d} \theta ~\mathrm{d} \phi
\]</span> 就可以在积分项中消去关于 <span
class="math inline">\(\xi_i\)</span> 的有理分式, 得到只关于径向微分
<span class="math inline">\(\mathrm{d} r\)</span> 的积分式 <span
class="math display">\[
2 \widetilde U
=  - \frac{1}{\mu^0} \frac{4\pi}{3} \int_{0}^{\infty}
\widehat{\widetilde{P}}_{ij}(r) \widehat{\widetilde{P}}_{ij}^{*}(r) r^2
\mathrm{d} r
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{4\pi}{15}
\int_{0}^{\infty} \left( \widehat{\widetilde{P}}_{mm}(r)
\widehat{\widetilde{P}}_{kk}^{*}(r)
+ 2\widehat{\widetilde{P}}_{ij}(r) \widehat{\widetilde{P}}_{ij}^{*}(r)
\right) r^2 \mathrm{d} r
\tag{7}
\]</span> 式 (7) 已经和最终的结果很接近了!
只要我们能够确定式中的径向积分, 这可以通过 Parseval
等式与物理空间中的能量积分关联为 <span class="math display">\[
\int_{0}^{\infty} \widehat{\widetilde{P}}_{ij}(r)
\widehat{\widetilde{P}}_{ij}^{*}(r) r^2 \mathrm{d} r
= \frac{1}{4\pi} \int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y)
~\mathrm{d}y, \quad
\int_{0}^{\infty} \widehat{\widetilde{P}}_{mm}(r)
\widehat{\widetilde{P}}_{kk}^{*}(r) r^2 \mathrm{d} r
= \frac{9}{4\pi} \int_{Y} \widetilde{p}(y) \widetilde{p}(y) ~\mathrm{d}y
\tag{a}
\]</span> 将式 (4) 代入上式左端项当中, 就得到使用 <span
class="math inline">\(p_{ij}\)</span> 表示的积分表达式: <span
class="math display">\[
\int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y) ~\mathrm{d}y
= \int_{Y}  p_{ij}(y) p_{ij}(y)~\mathrm{d}y
- 2 \bar{p}_{ij} \int_{Y} p_{ij}(y)  ~\mathrm{d}y
+ \bar{p}_{ij}\bar{p}_{ij}
= \int_{Y}  p_{ij}(y) p_{ij}(y)~\mathrm{d}y
- \bar{p}_{ij}\bar{p}_{ij}
\]</span></p>
<p>以及 <span class="math display">\[
\int_{Y} \widetilde{p}(y) \widetilde{p}(y) ~\mathrm{d}y
= \int_{Y}  p(y) p(y)~\mathrm{d}y - \bar{p}^2
\]</span> 将分块常值的极化应力表达式 <span class="math display">\[
p_{ij} := \sum_{\alpha}^{N} p_{ij}^{\alpha} \chi^{\alpha}
\]</span> 以及极化应力的 dev 分解代入式中得到 <span
class="math display">\[
\begin{gathered}
\int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y) ~\mathrm{d}y
= \underbrace{\left( \sum_{\alpha} c^{\alpha} f_{ij}^{\alpha}
f_{ij}^{\alpha} - \bar{f}_{ij}\bar{f}_{ij} \right)}_{\triangleq
\clubsuit}
+ 3\underbrace{\left(\sum_{\alpha} c^{\alpha} (p^{\alpha})^2 - \bar{p}^2
\right)}_{\triangleq \spadesuit}
= \clubsuit + 3\spadesuit \\
\int_{Y} \widetilde{p}(y) \widetilde{p}(y) ~\mathrm{d}y =
\left(\sum_{\alpha} c^{\alpha} (p^{\alpha})^2 - \bar{p}^2 \right) =
\spadesuit
\end{gathered}\tag{b}
\]</span> 最终, 我们代入到式 (7) 中, 得到 <span class="math display">\[
\begin{aligned}
2 \widetilde U
&amp;\stackrel{(a)}{=} - \frac{1}{3\mu^0}
\int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y) ~\mathrm{d}y
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{2}{15}
\int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y) ~\mathrm{d}y
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{3}{5}
\int_{Y} \widetilde{p}(y) \widetilde{p}(y) ~\mathrm{d}y \\
&amp;\stackrel{(b)}{=} - \frac{1}{3\mu^0} ( \clubsuit + 3\spadesuit )
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{2}{15} (
\clubsuit + 3\spadesuit )
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{3}{5}
\spadesuit \\
&amp;= \left(-\frac{1}{3\mu^0} + \frac{\lambda^0 + \mu^0}{\mu^0
(\lambda^0 + 2\mu^0)} \frac{2}{15} \right)\clubsuit
+ \left(-\frac{1}{\mu^0} + \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 +
2\mu^0)}\right)\spadesuit \\
&amp;= \frac{-3\lambda^0 -8\mu^0}{15\mu^0 (\lambda^0 + 2\mu^0)}
\clubsuit
+ \frac{-1}{\lambda^0 + 2\mu^0}\spadesuit
\end{aligned}
\]</span> 如果将 <span class="math display">\[
\lambda^0 = K^0 - \frac{2}{3}\mu^0
\]</span> 代入, 就可以得到 <span class="math display">\[
2 \widetilde U
= \frac{-3 K^0 - 6\mu^0}{5\mu^0 (3 K^0 + 4\mu^0)} \left( \sum_{\alpha}
c^{\alpha} f_{ij}^{\alpha} f_{ij}^{\alpha} - \bar{f}_{ij}\bar{f}_{ij}
\right)
+ \frac{-3}{3 K^0 + 4\mu^0} \left(\sum_{\alpha} c^{\alpha}
(p^{\alpha})^2 - \bar{p}^2 \right)
\tag{$\bigstar$}
\]</span></p>
]]></content>
      <categories>
        <category>力学</category>
      </categories>
      <tags>
        <tag>Fourier 变换</tag>
        <tag>变分原理</tag>
      </tags>
  </entry>
</search>
