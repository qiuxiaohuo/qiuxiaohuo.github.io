<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chebyshev 多项式</title>
    <url>/math/Chebyshev-%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Chebyshev 多项式的引入需要用关于 <span class="math inline">\(\cos
\theta\)</span> 的多项式表示 <span class="math inline">\(\cos
n\theta\)</span>, 这可以通过 Euler 公式得到: <span
class="math display">\[
\cos n\theta + i\sin n \theta = e^{i n \theta}
= (\cos \theta + i\sin \theta)^{n}
= \sum_{k=0}^{n} C_{n}^{k}(i\sin \theta)^{k}(\cos\theta)^{n-k}
\]</span> 因此, <span class="math inline">\(\cos n\theta\)</span>
等于上式右端的实数部分: <span class="math display">\[
\begin{aligned}
\cos n\theta &amp;= \mathrm{Re}~ \sum_{k=0}^{n} C_{n}^{k}(i)^{k}(\sin
\theta)^{k}(\cos\theta)^{n-k}
= \sum_{2k\leq n} C_{n}^{2k}(-1)^{k}(\sin
\theta)^{2k}(\cos\theta)^{n-2k} \\
&amp;= \sum_{2k\leq n} C_{n}^{2k}(-1)^{k}(1 -
\cos^2\theta)^{k}(\cos\theta)^{n-2k}
\triangleq  T_{n}(\cos \theta)
\end{aligned}
\tag{1}
\]</span> 而 Chebyshev 多项式就等于 <span
class="math inline">\(T_n\)</span>, <span
class="math inline">\(n=1,2,\ldots\)</span><span id="more"></span></p>
<div class="note primary no-icon"><h5 id="计算-chebyshev-多项式">计算 Chebyshev 多项式</h5>
<p><span class="math inline">\(T_0 = 1\)</span>, <span
class="math inline">\(T_1 = x\)</span>, <span class="math inline">\(T_2
= 2x^2 - 1\)</span></p>
<p><span class="math inline">\(n=3\)</span> 时, <span
class="math display">\[
\cos 3\theta = (\cos\theta)^3 + 3(-1)(1-\cos^2\theta)\cos\theta
= 4(\cos\theta)^3 - 3\cos\theta \\
\Rightarrow T_3 = 4x^3 -3x
\]</span> <span class="math inline">\(n = 4\)</span> 时, <span
class="math display">\[
\cos 4\theta = (\cos\theta)^4 + 6(-1)(1-\cos^2\theta)\cos^2\theta +
(1-\cos^2\theta)^2
= 8(\cos\theta)^4 - 8(\cos\theta)^2 + 1 \\
\Rightarrow T_4 = 8x^4 -8x^2 + 1
\]</span></p>
</div>
<p>接下来我们希望得到 Chebyshev 多项式的正交性,
由三角函数之间的正交性可以得到: <span class="math display">\[
\frac{1}{\pi}\int_{0}^{2\pi} \cos n \theta \cos k \theta
~\mathrm{d}\theta
= \begin{cases}
1, \quad n=k\\
0, \quad n \neq k
\end{cases}
\]</span> 根据式 (1), 将上式积分项写成关于 <span
class="math inline">\(\cos\theta\)</span> 函数的形式: <span
class="math display">\[
\frac{1}{\pi}\int_{0}^{2\pi} \cos n \theta \cos k \theta
~\mathrm{d}\theta
= \frac{1}{\pi}\int_{0}^{2\pi} T_n(\cos\theta) T_k(\cos\theta)
~\mathrm{d}\theta
= \frac{2}{\pi}\int_{0}^{\pi} T_n(\cos\theta) T_k(\cos\theta)
~\mathrm{d}\theta
\]</span> 作换元 <span class="math inline">\(x \doteq
\cos\theta\)</span>, 那么 <span class="math display">\[
\mathrm{d} x = -\sin\theta ~\mathrm{d}\theta = -\sqrt{1-x^2}
~\mathrm{d}\theta, \quad
\theta|_{0}^{\pi} \rightarrow x|_{1}^{-1}
\]</span> 所以得到 <span class="math display">\[
\frac{2}{\pi}\int_{0}^{\pi} T_n(\cos\theta) T_k(\cos\theta)
~\mathrm{d}\theta
= \frac{2}{\pi}\int_{-1}^{1} T_n(x) T_k(x)
\frac{\mathrm{d}x}{\sqrt{1-x^2}}
\tag{$\star$}
\]</span> 式 (<span class="math inline">\(\star\)</span>) 表示,
Chebyshev 多项式是在带权重意义下积分正交, 权函数 <span
class="math inline">\(w \triangleq 1/\sqrt{1-x^2}\)</span>.</p>
<p>另一种推导 Chebyshev 多项式的方法是,
将正交多项式看作是某个<strong>对称微分方程的特征函数</strong>.
类似于对称矩阵的特征向量是正交的, 对称微分方程的特征函数也是正交的.
Chebyshev 多项式对应的微分方程为 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d}x} \left( \sqrt{1-x^2}
\frac{\mathrm{d}u}{\mathrm{d}x} \right)
= \frac{\lambda}{\sqrt{1-x^2}} u, \quad\text{or}\quad
\frac{\mathrm{d}~}{\mathrm{d}x} \left( w^{-1}
\frac{\mathrm{d}u}{\mathrm{d}x} \right)
= \lambda w u
\tag{2}
\]</span> <div class="note primary no-icon"><h5 id="验证-chebyshev-多项式满足微分方程-2">验证 Chebyshev
多项式满足微分方程 （2）</h5>
<p><span class="math inline">\(T_0\)</span> 对应特征值为 <span
class="math inline">\(0\)</span>, <span
class="math inline">\(T_1\)</span> 对应特征值为 <span
class="math inline">\(-1\)</span>.</p>
<p>将 <span class="math inline">\(u=T_2(x)\)</span>​ 代入式 (2) 左端得到
<span class="math display">\[
\begin{aligned}
LHS
&amp;= \frac{\mathrm{d}~}{\mathrm{d}x} \left( \sqrt{1-x^2}
\frac{\mathrm{d}~}{\mathrm{d}x}\underbrace{(2x^2-1)}_{T_2(x)} \right)
= \frac{\mathrm{d}~}{\mathrm{d}x} \left( \sqrt{1-x^2} 4x \right)\\
&amp;= \frac{-x}{\sqrt{1-x^2}}4x + \sqrt{1-x^2}4 = \frac{-4x^2 + 4 -
4x^2}{\sqrt{1-x^2}} \\
&amp;= \frac{-4}{\sqrt{1-x^2}} \underbrace{(2x^2-1)}_{T_3(x)} \equiv
RHS(\lambda=-4)
\end{aligned}
\]</span> 将 <span class="math inline">\(u=T_3(x)\)</span> 代入式 (2)
左端, 得到 <span class="math display">\[
\begin{aligned}
LHS
&amp;= \frac{\mathrm{d}~}{\mathrm{d}x} \left( \sqrt{1-x^2}
\frac{\mathrm{d}~}{\mathrm{d}x}\underbrace{(4x^3-3x)}_{T_3(x)} \right)
= \frac{\mathrm{d}~}{\mathrm{d}x} \left( \sqrt{1-x^2} (12x^2-3)
\right)\\
&amp;= \frac{-x}{\sqrt{1-x^2}}(12x^2 - 3) + \sqrt{1-x^2}24x =
\frac{-12x^3 + 3x + 24x - 24x^3}{\sqrt{1-x^2}}\\
&amp;= \frac{-9}{\sqrt{1-x^2}} \underbrace{(4x^3-3x)}_{T_3(x)} \equiv
RHS(\lambda=-9)
\end{aligned}
\]</span> 将 <span class="math inline">\(u=T_4(x)\)</span> 代入式 (2)
左端得到 <span class="math display">\[
LHS \equiv RHS(\lambda = -16)
\]</span></p>
</div></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>正交函数基</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/math/Fredholm%20%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<p>对于一个有限维的线性算子 <span class="math inline">\(A: H \mapsto
H\)</span>, 定义其伴随算子 <span class="math inline">\(A^{*}\)</span> 为
<span class="math display">\[
(Au, v) = (u, A^{*} v), \quad \forall u,v \in H
\]</span> 若方程满足 <span class="math display">\[
A u = f
\]</span> 则上述方程有解的一个必要条件是 <span class="math display">\[
(f,v) = 0, \quad \forall v \in \mathcal{N}(A^{*})
\]</span> 其中, <span class="math inline">\(\mathcal{N}(A^{*})\)</span>
为算子 <span class="math inline">\(A^{*}\)</span> 的零空间.
这可以验证如下 <span class="math display">\[
A u = f \Rightarrow \\
(Au, v) = (f, v) = (u, A^{*} v), \quad \forall v \in H \Rightarrow \\
(f,v) = (u,0) = 0, \quad \forall v \in \mathcal{N}(A^{*})
\]</span> 周期函数空间</p>
<p>考虑单胞在空间中各个维度的长度等于 1, 若函数 <span
class="math inline">\(f:\mathbb{R}^{\mathrm{d}} \mapsto
\mathbb{R}\)</span> 满足 <span class="math display">\[
f(y + e_{i}) = f(y), \quad \forall y \in \mathbb{R}^{\mathrm{d}}
\]</span> 则称 <span class="math inline">\(f\)</span> 为 1-周期函数.
对椭圆形微分算子 <span class="math inline">\(\mathcal{A}\)</span>: <span
class="math display">\[
\mathcal{A} = \nabla_{y} \cdot (L\nabla_{y})
\]</span> 并满足正定性等一些性质, 那么, 弱形式 <span
class="math display">\[
\int_{\Theta} \nabla_{y} u : L :\nabla_{y} v \ \mathrm{d}y =
\int_{\Theta} f v \ \mathrm{d} y, \quad
\forall v \in H_{\mathrm{per}}^{1}(\Theta)
\]</span> 有唯一解的充分必要条件是 <span class="math display">\[
\int_{\Theta} f \ \mathrm{d} y = 0
\]</span></p>
]]></content>
  </entry>
  <entry>
    <title>Lagrange 乘子法</title>
    <url>/math/Lagrange-%E4%B9%98%E5%AD%90%E6%B3%95/</url>
    <content><![CDATA[<p>我们来推导一下 Lagrange 乘子法与含约束问题的等价性.
以关于双变量的函数为例,: <span class="math display">\[
Q(y_1, y_2): \mathbb{R^2} \mapsto \mathbb{R}
\]</span></p>
<p>现在希望获取该函数的最小值, 同时满足约束 <span
class="math display">\[
A(y_1, y_2) = 0
\]</span> <span id="more"></span>最直接的思路是, 通过约束方程 <span
class="math inline">\(A\)</span> , 用 <span
class="math inline">\(y_1\)</span> 表示 <span
class="math inline">\(y_2\)</span>, 这样, 代入到目标函数 <span
class="math inline">\(Q\)</span> 中, 就得到关于 <span
class="math inline">\(y_1\)</span> 的单变量方程 <span
class="math display">\[
R(y_1) \triangleq Q(y_1, y_2(y_1))
\]</span> 这样之后, 极值问题就等价于对函数 <span
class="math inline">\(R\)</span> 的导数为 0: <span
class="math display">\[
\frac{\mathrm{d} R}{\,\mathrm{d} y_1} = 0
\iff \frac{\partial Q}{\,\partial y_1} + \frac{\partial Q}{\,\partial
y_2} \frac{\mathrm{d}y_1}{\mathrm{d} y_2} = 0
\]</span> 同样的, 对约束方程关于 <span
class="math inline">\(y_1\)</span> 求导数得到 <span
class="math display">\[
\frac{\partial A}{\,\partial y_1} + \frac{\partial A}{\,\partial y_2}
\frac{\mathrm{d}y_1}{\mathrm{d} y_2} = 0
\]</span> 两个方程中都出现了 <span class="math inline">\(\mathrm{d} y_1
/ \mathrm{d} y_2\)</span> 项, 因此 <span class="math display">\[
\left. \frac{\partial Q}{\,\partial y_1} \right/ \frac{\partial
Q}{\,\partial y_2}
= \left. \frac{\partial A}{\,\partial y_1} \right/ \frac{\partial
A}{\,\partial y_2}
\]</span> 或者 <span class="math display">\[
\left. \frac{\partial Q}{\,\partial y_1} \right/ \frac{\partial
A}{\,\partial y_1}
= \left. \frac{\partial Q}{\,\partial y_2} \right/ \frac{\partial
A}{\,\partial y_2}
\]</span> 如果引入新的变量 <span class="math inline">\(x\)</span>,
表示偏导数之间的比值 <span class="math display">\[
\left. \frac{\partial Q}{\,\partial y_1} \right/ \frac{\partial
A}{\,\partial y_1}
= \left. \frac{\partial Q}{\,\partial y_2} \right/ \frac{\partial
A}{\,\partial y_2}
= -x
\]</span> 就得到 <span class="math display">\[
\begin{aligned}
\frac{\partial Q}{\,\partial y_1} + x \frac{\partial A}{\,\partial y_1}
= 0 \\
\frac{\partial Q}{\,\partial y_2} + x \frac{\partial A}{\,\partial y_2}
= 0
\end{aligned}
\]</span> 使用 Lagrange 乘子组成的目标函数为 <span
class="math display">\[
L(y_1,y_2,x) = Q(y_1, y_2) + x A(y_1, y_2)
\]</span> 对 <span class="math inline">\((y_1, y_2, x)\)</span>
分别求偏导数, 并令其等于 0, 得到 <span class="math display">\[
\begin{aligned}
\frac{\partial L}{\,\partial y_1} = 0 &amp;\iff
\frac{\partial Q}{\,\partial y_1} + x \frac{\partial A}{\,\partial y_1}
= 0 \\
\frac{\partial L}{\,\partial y_2} = 0 &amp;\iff
\frac{\partial Q}{\,\partial y_2} + x \frac{\partial A}{\,\partial y_2}
= 0 \\
\frac{\partial L}{\partial x} = 0 &amp;\iff A = 0 \\
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Lagrange 乘子法</tag>
      </tags>
  </entry>
  <entry>
    <title>p-范数下的圆周率</title>
    <url>/math/p-%E8%8C%83%E6%95%B0%E4%B8%8B%E7%9A%84%E5%9C%86%E5%91%A8%E7%8E%87/</url>
    <content><![CDATA[<h2 id="待求解积分的解析性质">待求解积分的解析性质</h2>
<p>在 <span class="math inline">\(p\)</span>-范数下的圆周率定义为 <span
class="math display">\[
\pi_p \triangleq \frac{2}{p} \int_{0}^{1} \left( u^{1-p} + (1-u)^{1-p}
\right)^{1/p} ~\mathrm{d}u,
\quad 1 &lt; p \leq \infty
\tag{1}
\]</span> 圆周率 <span class="math inline">\(\pi_p\)</span>
具有如下性质</p>
<ol type="1">
<li><span class="math inline">\(\pi_2\)</span> 是最小值;</li>
<li>如果 <span class="math inline">\({1}/{p} + {1}/{q} = 1\)</span>,
那么 <span class="math inline">\(\pi_p = \pi_q\)</span>.</li>
</ol>
<p>证明的参考文献为</p>
<ol type="1">
<li>Adler, C. L., &amp; Tanton, J. (2000). <em>π is the Minimum Value
for Pi. The College Mathematics Journal, 31(2), 102–106.</em></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYXRoLnN0YW5mb3JkLmVkdS9+dmFraWwvZmlsZXMvMDctMDMzMy5wZGY=">πp, the
value of π in lp - Stanford Mathematics<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>对不同的 <span class="math inline">\(p\)</span> 取值,
积分项函数的图像为</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202406031318804.png" alt="image-20240603131849757" style="zoom:50%;" /></p>
<p>由此可以看到积分项函数的性质为</p>
<ul>
<li>在 <span class="math inline">\(x=0\)</span> 和 <span
class="math inline">\(x=1\)</span> 处出现爆破,
因此使用的数值方法必须考虑到这一情况；</li>
<li>关于 <span class="math inline">\(x=0.5\)</span> 对称,
因此可以只考虑区间 <span class="math inline">\((0,0.5)\)</span>
上的积分</li>
</ul>
<h2 id="数值积分需要考虑的问题">数值积分需要考虑的问题</h2>
<p>根据对称性, 式 (1) 可以转换到区间 <span
class="math inline">\((0,0.5)\)</span> 上的积分: <span
class="math display">\[
\pi_p = \frac{4}{p} \int_{0}^{0.5} \left( u^{1-p} + (1-u)^{1-p}
\right)^{1/p} ~\mathrm{d}u
\]</span> 定义被积函数 <span class="math inline">\(f(x)\)</span> 为
<span class="math display">\[
f(x) \triangleq \frac{4}{p}\left( x^{1-p} + (1-x)^{1-p} \right)^{1/p}
\]</span> 因此 <span class="math display">\[
\pi_p = \int_{0}^{0.5} f(u) ~\mathrm{d}u
\]</span></p>
<h3 id="如何处理瑕积分">如何处理瑕积分</h3>
<p>被积函数在 <span class="math inline">\(x=0\)</span> 处发生爆破,
在本次作业中处理该瑕点的常用且可行的方式有:</p>
<ol type="1">
<li>将积分区间分成 <span class="math inline">\((0,\varepsilon)\)</span>
和 <span class="math inline">\((\varepsilon, 0.5)\)</span>, 在区间 <span
class="math inline">\((0,\varepsilon)\)</span> 上使用幂函数近似, 在区间
<span class="math inline">\((\varepsilon, 0.5)\)</span>
使用常规的积分策略;</li>
<li>换元, 将积分区间 <span class="math inline">\((0,1)\)</span> 变换到
<span class="math inline">\((0,\infty)\)</span> 上,
同时采用的换元方式使得被积函数快速衰减,
通过延展积分区间回避掉瑕点的爆破现象.</li>
</ol>
<p>方式 1 的一种推导思路陈述如下: 首先将 <span
class="math inline">\(f(x)\)</span> 变形为 <span
class="math inline">\((1+\square)^{1/p}\)</span> 的形式: <span
class="math display">\[
f(x) = \frac{4}{p} \frac{\left( 1 + \overbrace{(1/x-1)^{1-p}}^{\square}
\right)^{1/p}}{x^{1-1/p}}
\]</span> 注意到对任意给定的 <span
class="math inline">\(p\in(1,\infty)\)</span>, <span
class="math display">\[
\left( \frac{1}{x} -1 \right)^{1-p} \rightarrow 0, \quad when \quad x
\rightarrow 0^+
\]</span> 所以可以使用如下近似 <span class="math display">\[
(1+\square)^{1/p} \sim 1 + \frac{1}{p} \square
\Rightarrow f(x) \sim \underbrace{\frac{4}{p}x^{1/p-1}}_{①}
+ \underbrace{\frac{4}{p^2} \left( x^{1/p-1}-x^{1/p} \right)^{1-p}}_{②}
\]</span> 如果再忽略第 ② 项, 那么就可以用如下幂函数近似被积函数 <span
class="math inline">\(f(x)\)</span>: <span class="math display">\[
\widetilde f(x) = \frac{4}{p}x^{1/p-1}
\]</span> 这种忽略是合理的, 分别绘制出这两项的函数图像 (<span
class="math inline">\(p=1.1\)</span>​). 可以看到, 函数 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(x=0\)</span> 附近的奇性完全是由第 ①
项表现出来的.</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202406081336560.png" alt="image-20240608133623497" style="zoom:50%;" /></p>
<p>注意到当 <span class="math inline">\(p=1\)</span>, 时, <span
class="math inline">\(\widetilde f(x) \equiv 4\)</span>, <span
class="math inline">\(f(x) \equiv 8\)</span>, 为了弥补这一缺陷,
可以再补充一项常数项, 最终得到的在区间 <span
class="math inline">\((0,\varepsilon)\)</span> 上的近似函数为 <span
class="math display">\[
\widetilde f(x) \triangleq \frac{4}{p}x^{1/p-1} + 4
\]</span> 对上式在区间 <span
class="math inline">\((0,\varepsilon)\)</span> 上积分, 就得到 <span
class="math display">\[
\int_{0}^{\varepsilon} \widetilde f(x) ~\mathrm{d}x
= \int_{0}^{\varepsilon} \frac{4}{p}x^{1/p-1} + 4 ~\mathrm{d}x
= 4\varepsilon^{1/p} + 4\varepsilon
\triangleq I_1
\]</span> 最终 <span class="math inline">\(\pi_p\)</span> 为 <span
class="math display">\[
\boxed{
\pi_p \approx I_1 + \int_{\varepsilon}^{0.5} f(x) ~\mathrm{d}x
}
\]</span> 方式 2 中一种常用的换元方式为 <span class="exturl" data-url="aHR0cHM6Ly90b2J5ZHJpc2NvbGwubmV0L2ZuYy1qdWxpYS9nbG9iYWxhcHByb3gvaW1wcm9wZXIuaHRtbCNpbnRlZ3JhbmQtc2luZ3VsYXJpdHk=">Fundamentals
of Numerical Computation<i class="fa fa-external-link-alt"></i></span> <span class="math display">\[
u(t) = \frac{1}{1+\exp(2\sinh t)}
\]</span> 注意到 <span class="math inline">\(t=0\)</span> 时, <span
class="math inline">\(u=0.5\)</span>; <span
class="math inline">\(t\rightarrow \infty\)</span> 时, <span
class="math inline">\(x \rightarrow 0\)</span>​. 微分关系为 <span
class="math display">\[
\mathrm{d} u = - \frac{\cosh t}{2\cosh(\sinh t)^2}  ~\mathrm{d}t
\]</span> 所以 <span class="math display">\[
\pi_p = \int_{0}^{0.5} f(u) ~\mathrm{d}u
= -\int_{\infty}^{0} f(u(t)) \frac{\cosh t}{2\cosh(\sinh
t)^2}  ~\mathrm{d}t
= \int_{0}^{\infty} f(u(t)) \frac{\cosh t}{2\cosh(\sinh
t)^2}  ~\mathrm{d}t
\]</span> 定义权函数 <span class="math inline">\(\omega(t)\)</span>
<span class="math display">\[
\omega(t) \triangleq \frac{\cosh t}{2\cosh(\sinh t)^2}
\]</span> 绘制权函数的图像如下, 可以观察到, 该函数收敛很快, 当 <span
class="math inline">\(t=3\)</span> 时, <span
class="math inline">\(\omega(t) = 8.0089\times10^{-8}\)</span>; 当 <span
class="math inline">\(t=4\)</span> 时, <span
class="math inline">\(\omega(t) = 2.16089\times10^{-22}\)</span>.
因此在数值积分时, 可以设置初始积分区间为 <span
class="math inline">\((0,3)\)</span>, 然后不断扩展积分区间.
当被积函数取值小于给定阈值之后, 停止积分, 输出结果.</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202406081424413.png" alt="image-20240608142415330" style="zoom:50%;" /></p>
<p>需要指出的是, 换元方式并不是<strong>唯一的</strong>.
作业中使用到的换元方式还有 <span class="math display">\[
u(t) = \frac{1}{1+e^{-t}}
\]</span></p>
<h3 id="如何处理-p-取较大值的情况">如何处理 <span
class="math inline">\(p\)</span> 取较大值的情况</h3>
<p>最方便的方式是使用最开始给出的解析性质: <span class="math display">\[
\pi_p = \pi_q, \quad if \quad \frac{1}{p} + \frac{1}{q} = 1
\]</span> 如果不清楚这一性质, 那么必须考虑数值计算 <span
class="math inline">\(p\)</span> 次幂可能出现的问题. 例如计算 <span
class="math inline">\((0.1^{1000})^{0.001}\)</span> 时, 正确结果为 <span
class="math inline">\(0.1\)</span>, 但当 <span
class="math inline">\(0.1^{1000}\)</span> 在计算机求解时等于 <span
class="math inline">\(0\)</span>, 再开 <span
class="math inline">\(0.001\)</span> 次方结果还是等于 0.
这是一些同学的程序在 <span class="math inline">\(p\)</span>
很大时输出结果误差很大的原因.</p>
]]></content>
  </entry>
  <entry>
    <title>一般的线性系统</title>
    <url>/math/%E4%B8%80%E8%88%AC%E7%9A%84%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>我们首先考虑常系数齐次系统 <span class="math display">\[
\dot{x} = Ax \\
x(0) = x_0
\]</span> 该方程的解为 <span class="math display">\[
x(t) = x_0 e^{At}
\]</span> <span id="more"></span>是不是很简单? 好,
我们继续再考虑系数随时间变化的系统 <span class="math display">\[
\dot{x} = A(t)x \\
x(0) = x_0
\]</span> well, 这样子方程就不太容易直接看出解出来了. 因为从形式上来说,
我们只能确定 <span class="math inline">\(e^{At}\)</span>,
并验证该解满足方程. 但是对于 <span
class="math inline">\(e^{A(t)t}\)</span>, 微分得到的结果为 <span
class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} e^{A(t)t}
= \frac{\mathrm{d}~}{\mathrm{d} t} \sum_{k=0}^{\infty}
\frac{t^k}{k!}A(t)^k
= A(t)\sum_{k=1}^{\infty} \frac{t^{k}}{k!}A(t)^{k}
+ \sum_{k=0}^{\infty} \frac{t^{k}}{k!}\frac{\mathrm{d}~}{\mathrm{d}
t}A(t)^{k}
\]</span> 最后又多出一项,</p>
<p>不过我们可以先设解的存在, 将基本解定义为 <span
class="math display">\[
\Psi(t) = \begin{pmatrix}
\psi_{11}(t) &amp; \psi_{12}(t) \\
\psi_{21}(t) &amp; \psi_{22}(t)
\end{pmatrix}, \quad
\Psi(0) = \begin{pmatrix}
1 &amp; 0 \\ 0 &amp; 1
\end{pmatrix}
\]</span> 并满足方程, 这样, 解就可以表示为 <span class="math display">\[
x(t) = \Psi(t) x_0
\]</span> 注意到对于常系数矩阵 <span class="math inline">\(A\)</span>,
有公式 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t}  \det e^{At} = \mathrm{tr} A~\det
e^{At}
\]</span> 一般的, 对于矩阵 <span class="math inline">\(A(t)\)</span>,
同样有 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \det e^{A(t)} = \mathrm{tr}A(t) \det
e^{A(t)}
\]</span> 好, 接下来我们接触最复杂的情况: 非齐次方程 <span
class="math display">\[
\dot{x} = A(t)x + g(t) \\
x(0) = x_0
\]</span> 对于线性方程, 我们总是可以通过叠加原理,
将方程转化为我们已经处理过的情况. 对于本问题, 我们可以做如下分解 <span
class="math display">\[
\dot{x} = A(t)x, \quad x(0) = x_0 \\
\dot{x} = A(t)x + g(t), \quad x(0) = 0
\]</span> 这样, 我们就将非齐次方程中的初值转化为 0,
所以我们现在就可以只关注于非齐次项的处理. 我们假设方程的解为 <span
class="math display">\[
x(t) = \Psi(t) c(t)
\]</span> 求一次导数得到 <span class="math display">\[
\dot{x}(t) = \dot{\Psi}(t)c(t) + \Psi(t) \dot{c}(t)
\]</span> 代入到方程中得到 <span class="math display">\[
\dot{\Psi}(t)c(t) + \Psi(t) \dot{c}(t) = A(t)x(t) + g(t)
\]</span> 如果令???? (这一步总是让我很不舒服, 为什么?
这样不是和变系数的假设相违背了呢?) <span class="math display">\[
\dot{\Psi}(t)c(t) = A(t)x(t)
\]</span> 就得到关于系数 <span class="math inline">\(c(t)\)</span>
的微分方程 <span class="math display">\[
\dot{c}(t) = \Psi^{-1}(t) g(t)
\]</span> 积分得到 <span class="math display">\[
c(t) = \int_0^t \Psi^{-1}(s) g(s) ~\mathrm{d}s
\]</span> 所以我们就得到了 Duhamel 原理 <span class="math display">\[
x(t) = \Psi(t) x_0 + \int_0^t \Psi(t) \Psi^{-1}(s) g(s) ~\mathrm{d}s
\]</span> 现在我们回归到具体的方程, 比如常系数方程, 就得到 <span
class="math display">\[
x(t) = e^{At} x_0 + \int_0^t e^{A(t-s)} g(s) ~\mathrm{d}s
\]</span> 我们还可以用一种更形象的方式陈述 Duhamel 原理, 也即冲量原理.
设在时刻 <span class="math inline">\(s\)</span>, 在 <span
class="math inline">\(\Delta s\)</span> 的时间范围内,
方程的非齐次项产生冲量 <span class="math inline">\(g(s) \Delta
s\)</span>. 该冲量将在未来的 <span class="math inline">\(t-s\)</span>
时间内, 作为初值影响方程的解: <span class="math display">\[
\Delta x = e^{A(t-s)} g(s) \Delta s
\]</span> 对 <span class="math inline">\(\Delta s\)</span> 积分得到
<span class="math inline">\(g(s)\)</span> 在时间 <span
class="math inline">\((0,t)\)</span> 内对方程解的总贡献为 <span
class="math display">\[
x(t) = \int_0^t e^{A(t-s)} g(s) \mathrm{s} s
\]</span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>常微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title>函数范数: 等价类的引入</title>
    <url>/math/%E5%87%BD%E6%95%B0%E8%8C%83%E6%95%B0-%E7%AD%89%E4%BB%B7%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<p>定义某一空间 <span class="math inline">\(V\)</span> 上的范数,
就是确定该空间上某一个非负实值映射 <span class="math inline">\(\| \cdot
\|\)</span>, 且该映射满足如下条件:</p>
<ol type="1">
<li>对任意的 <span class="math inline">\(v \in V\)</span>, <span
class="math inline">\(\| v \| \geq 0\)</span> 成立, 当且仅当 <span
class="math inline">\(v = 0\)</span> 时 <span class="math inline">\(\| v
\| = 0\)</span>;</li>
<li>对任意的 <span class="math inline">\(c \in \mathbb{R}\)</span> 和
<span class="math inline">\(v \in V\)</span>, <span
class="math inline">\(\|cv\| = |c| \|v\|\)</span>;</li>
<li>对任意的 <span class="math inline">\(u, v \in V\)</span>, 不等式
<span class="math inline">\(\|u+v\| \leq \|u\| + \|v\|\)</span>
成立.</li>
</ol>
<p>我现在想处理的是, 当空间的概念从有限维的向量空间,
拓展到无穷维的函数空间上时, 条件 1 中 <span class="math inline">\(v =
0\)</span> 的定义也需要加以推广, 以适应这个条件中 <span
class="math inline">\(v=0\)</span> 与 <span class="math inline">\(\|v\|
= 0\)</span> 的等价性. <span id="more"></span>我们以函数的 <span
class="math inline">\(1-\)</span>范数 <span class="math display">\[
\begin{equation}
  \|\cdot\| = \int|\cdot| \mathrm{d} \Omega
\end{equation}
\]</span> 以及定义在 <span class="math inline">\(\Omega = [-1,
1]\)</span> 上的两个函数 <span class="math inline">\(f(x)\)</span>,
<span class="math inline">\(g(x)\)</span> <span class="math display">\[
\begin{equation}
  f(x) = \begin{cases}
    1 \quad x \geq 0 \\
    0 \quad x &lt; 0
  \end{cases} \quad \quad
  g(x) = \begin{cases}
    1 \quad x &gt; 0 \\
    0 \quad x \leq 0
  \end{cases}
\end{equation}
\]</span> 为例. 函数 <span class="math inline">\(f-g\)</span> 的范数为
<span class="math display">\[
\begin{equation}
  \|f-g\| = \int_{-1}^{1} |f-g| \mathrm{d}x = 0,
\end{equation}
\]</span> 根据范数成立的条件 1, 则应该有 <span
class="math inline">\(f-g=0\)</span>, 或者等价的 <span
class="math inline">\(f=g\)</span>. 可是, 函数 <span
class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(g(x)\)</span> 在 <span
class="math inline">\(x=0\)</span> 处并不相等, 如果用数学味比较浓的表达,
那就是</p>
<div class="note success no-icon"><p>函数 <span class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(g(x)\)</span> 在区间 <span
class="math inline">\([-1,1]\)</span> 上并不是<strong>逐点</strong>
(pointwise) 相等的.</p>
</div>
<p>为了调和这一概念上的矛盾, 我们有 2 个思路: 1) 修改范数的定义; 2)
修改函数相等的定义.</p>
<p>对于第 1 个思路, 我们可以验证, 如果函数的范数定义为 <span
class="math display">\[
\|\cdot\| = \max_{-1 \leq x \leq 1} |\cdot|,
\]</span> 那么 <span class="math inline">\(\|f-g\|\)</span> 等价于 <span
class="math inline">\(f\)</span>, <span class="math inline">\(g\)</span>
逐点相等. 这实际是函数的 <span
class="math inline">\(\infty-\)</span>范数.</p>
<p>至于思路 2, 我们需要引入<strong>等价类</strong>的概念. 首先我们定义
<span class="math inline">\(V\)</span> 的子空间 <span
class="math inline">\(V^0\)</span> <span class="math display">\[
\begin{equation}
    V^0 = \{ v^0 \mid \| v^0 \|=0 \}.
\end{equation}
\]</span> 那么, 对任意 <span class="math inline">\(v \in V\)</span>,
<strong><span class="math inline">\(v\)</span> 与所有其它的函数 <span
class="math inline">\(v+v^0\)</span>, <span class="math inline">\(v^0
\in V^0\)</span> 共同组成同一个等价类</strong>.</p>
<p>这样, 我们重新定义相等 "<span class="math inline">\(=\)</span>"
的概念为</p>
<div class="note success no-icon"><p><span class="math inline">\(f=g\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(f\)</span> 与 <span
class="math inline">\(g\)</span> 属于同一个等价类, 即 <span
class="math inline">\(f = g+v^0\)</span>, <span
class="math inline">\(v^0 \in V^0\)</span>.</p>
</div>
<p>在上述相等的意义下, <span class="math inline">\(f\)</span> 与 <span
class="math inline">\(g\)</span> 并不一定是逐点相等的,
但只相差一个范数为 0 的函数 <span class="math inline">\(v^0\)</span>.
因此,</p>
<div class="note success no-icon"><p><span class="math inline">\(f=g\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(f = g+v^0\)</span>, <span
class="math inline">\(v^0 \in V^0\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(\| f-g \| = 0\)</span>.</p>
</div>
<p>这样我们就保证了范数定义中条件 1 的等价性.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>等价类</tag>
      </tags>
  </entry>
  <entry>
    <title>常微分方程唯一性定理的证明</title>
    <url>/math/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%94%AF%E4%B8%80%E6%80%A7%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<div class="note success no-icon"><h4 id="常微分方程的唯一性定理">常微分方程的唯一性定理</h4>
<p>对于如下常微分方程: <span class="math display">\[
\left\{
\begin{aligned}
  &amp;\dot{x} = f(t,x)\\
  &amp;x(0) = x_0
\end{aligned}
\right.
\]</span> 如果 <span class="math inline">\(f(t,x)\)</span> 关于 <span
class="math inline">\(x\)</span>​ <strong>Lipschitz 连续</strong>,
那么方程的解唯一.</p>
</div>
<span id="more"></span>
<p>Lipschitz 连续的必要性可以在方程证明中看到,
所以我们在证明过程中再提出 Lipschitz 条件的具体形式.</p>
<p>首先假设, 存在 <span class="math inline">\(x_1\)</span>, <span
class="math inline">\(x_2\)</span>
两个解满足命题中给出的微分方程和初值条件, 那么有 <span
class="math display">\[
\begin{aligned}
  x_1(t) = x_0 + \int_0^t f(s,x_1(s)) \mathrm{d} s\\
  x_2(t) = x_0 + \int_0^t f(s,x_2(s)) \mathrm{d} s
\end{aligned}
\]</span></p>
<p>两式相减, 两端取绝对值得到</p>
<p><span class="math display">\[
\vert x_1(t) - x_2(t) \vert = \int_0^t \vert  f(s,x_1(s)) - f(s,x_2(s))
\vert  \mathrm{d} s
\]</span></p>
<p>我们希望能得到对方程左端项的估计, 而 Lipschitz 条件要求, 对任意的
<span class="math inline">\(x,y\in \mathbb{R}_n\)</span>:</p>
<p><span class="math display">\[
\vert f(t,x) -f(t,y)  \vert \leq L |x-y|
\]</span></p>
<p><span class="math inline">\(L\)</span> 是 Lipschitz 常数, 不依赖于
<span class="math inline">\(x,y,t\)</span>. 这样我们就得到了关于 <span
class="math inline">\(r(t) = |x_1(t) - x_2(t)|\)</span> 的积分不等式:
<span class="math display">\[
r(t) \leq L \int_{0}^{t} r(s) \mathrm{d} s
\]</span></p>
<p>上述不等式又称 Gronwall 不等式, 是对 <span
class="math inline">\(r(t)\)</span> 最坏情况的指数估计. 如果我们有</p>
<p><span class="math display">\[
f(t) \leq C_0 + \int_0^t f(s) g(s) \mathrm{d} s, \quad C_0 \geq 0, f(t),
g(t) \geq 0
\]</span></p>
<p>那么 <span class="math display">\[
f(t) \leq C_0 e^{\int_0^t g(s) \mathrm{d} s}
\]</span></p>
<p>在我们的证明中, <span class="math inline">\(C_0 = 0\)</span>, 所以
<span class="math display">\[
0 \leq r(t) \leq 0
\]</span></p>
<p>这就得到 <span class="math inline">\(r(t) \equiv 0\)</span>, 所以
<span class="math inline">\(x_1(t) \equiv x_2(t)\)</span>.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Lipschitz 连续</tag>
        <tag>解的唯一性</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵值函数的微分运算</title>
    <url>/math/%E7%9F%A9%E9%98%B5%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E5%BE%AE%E5%88%86%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>我们考虑的矩阵值函数, 其每个元素是关于 <span
class="math inline">\(t\)</span> 的单变量函数: <span
class="math display">\[
A(t) = [a_{ij}(t)]
\]</span> 从 <span class="math inline">\(\mathbb{R} \mapsto
\mathbb{R}^n\)</span> 上的函数几乎可以将单变量函数的微分运算直接平推,
只要确定了范数度量 <span class="math inline">\(\|\cdot\|\)</span> (从
<span class="math inline">\(\mathbb{R} \mapsto \mathbb{R}^n\)</span>
的函数就没有那么平凡).</p>
<p>考虑如下微分 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} e^{At}
= \frac{\mathrm{d}~}{\mathrm{d} t} \sum_{k=0}^{\infty} \frac{t^k}{k!}A^k
= A\sum_{k=1}^{\infty} \frac{t^{k-1}}{(k-1)!}A^{k-1} = A e^{At} = e^{At}
A
\]</span> 对 <span class="math inline">\(\det A(t)\)</span> 的导数,
可以有两种方式看. 一种是利用定义 <span class="math display">\[
\det A(t) = \sum_{\{\sigma_i\}} (-1)^{\mathrm{sign} \{\sigma_i\}}
a_{1\sigma_1}(t) a_{2\sigma_2}(t) \ldots a_{n\sigma_n}(t)
\]</span> <span id="more"></span>根据导数定义 <span class="math display">\[
\det A(t+h) - \det A(t) \\
= \sum_{\{\sigma_i\}} (-1)^{\mathrm{sign} \{\sigma_i\}}
(a_{1\sigma_1}(t+h) a_{2\sigma_2}(t+h) \ldots a_{n\sigma_n}(t+h)
- a_{1\sigma_1}(t) a_{2\sigma_2}(t) \ldots a_{n\sigma_n}(t)) \\
= \sum_{\{\sigma_i\}} (-1)^{\mathrm{sign} \{\sigma_i\}}
(a&#39;_{1\sigma_1} a_{2\sigma_2} \ldots a_{n\sigma_n}
+ a_{1\sigma_1} a&#39;_{2\sigma_2} \ldots a_{n\sigma_n}
+ \cdots
+ a_{1\sigma_1} a_{2\sigma_2} \ldots a&#39;_{n\sigma_n}) \\
= \det(A&#39;_1, A_2, \ldots, A_n) + \det(A_1, A&#39;_2, \ldots, A_n)
+ \ldots + \det(A_1, A_2, \ldots, A&#39;_n)
\]</span> 另一种证明要用到如下结论: 对于特征多项式 <span
class="math inline">\(\det (A + \lambda I)\)</span>, 是关于 <span
class="math inline">\(\lambda\)</span> 的 <span
class="math inline">\(n\)</span> 阶多项式, 多项式的前两项系数为 <span
class="math display">\[
\det (A + \lambda I) = \lambda^n + (\mathrm{tr} A )\lambda^{n-1} +
\cdots + \det A
\]</span> 可以通过递归方法证明. <span class="math display">\[
\det A(t+h) = \det [A(t) + h A&#39;(t) + o(h)]
= \det A(t) \det [I + h A^{-1}(t)A&#39;(t) + o(h)] \\
= \det A(t) (1 + h\mathrm{tr}(A^{-1}A&#39;) + o(h) )
\]</span> 因此 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \det A(t) = \det A
~\mathrm{tr}(A^{-1}A&#39;)
\]</span> 上式要求 <span class="math inline">\(A(t)\)</span> 可逆,
对于更一般的矩阵 <span class="math inline">\(A(t)\)</span>, 可以通过
adjugate 矩阵表示 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \det A(t)
=  \mathrm{tr}(\mathrm{adj}(A) A&#39;)
= \mathrm{cof}(A) : A&#39;
\]</span> 积分得到 <span class="math display">\[
\det A(t) = \det A(0) e^{\int_0^t \mathrm{tr}(A^{-1}(s)A&#39;(s))
~\mathrm{d}s}
\]</span> 如果将 <span class="math inline">\(A(t) = e^{At}\)</span>
代入, 就会得到很有意思的等式 <span class="math display">\[
\int_0^t \mathrm{tr}(e^{-As} A e^{As}) ~\mathrm{d}s = \mathrm{tr}(A)t
\]</span> 所以 <span class="math display">\[
\det e^{At} = e^{\mathrm{tr}(A)t}
\]</span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵值函数</tag>
        <tag>行列式</tag>
      </tags>
  </entry>
  <entry>
    <title>数学相关文档中不同类型的等号释义</title>
    <url>/math/%E6%95%B0%E5%AD%A6%E6%96%87%E6%A1%A3%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AD%89%E5%8F%B7%E9%87%8A%E4%B9%89/</url>
    <content><![CDATA[<p>我在数学相关文档的编写中，对三种特殊的等号作如下释义：</p>
<h2 id="恒等于-equiv">恒等于 <span
class="math inline">\(\equiv\)</span></h2>
<p>LaTeX 表达式：<code>\equiv</code></p>
<p>用在分析语言当中，左侧为函数，右侧为常数，表示等号左侧的函数在定义域上的取值恒等于右侧的常数。例如</p>
<blockquote>
<p>三角恒等式 <span class="math display">\[
\cos^2 x + \sin^2 x \equiv 1
\]</span></p>
</blockquote>
<span id="more"></span>
<h2 id="定义-triangleq">定义 <span
class="math inline">\(\triangleq\)</span></h2>
<p>LaTeX 表达式：<code>\triangleq</code></p>
<p>定义新的符号，左右两侧表达式中会出现新的符号，并总能通过已定义的符号表示出来，例如</p>
<blockquote>
<p>已知物体质量 <span class="math inline">\(m\)</span>，加速度 <span
class="math inline">\(a\)</span>，我们定义作用在物体上的力 <span
class="math inline">\(F\)</span> 为 <span class="math display">\[
F \triangleq ma
\]</span></p>
</blockquote>
<p>符号 <span class="math inline">\(\triangleq\)</span>
是左右对称的，所以 <span class="math inline">\(\triangleq\)</span>
左侧不一定总是为新定义的变量，例如</p>
<blockquote>
<p>材料中的应变 <span class="math inline">\(\varepsilon\)</span>
是弹性应变 <span class="math inline">\(e\)</span> 与本征应变 <span
class="math inline">\(\mu\)</span> 之和： <span class="math display">\[
\varepsilon \triangleq e + \mu
\]</span></p>
</blockquote>
<h2 id="赋值">赋值 <span class="math inline">\(:=\)</span>​</h2>
<p>LaTeX 表达式：<code>\coloneqq</code> （依赖宏包
<code>mathtools</code>）</p>
<p>在旧的文档中我用来定义变量，与 Computational Inelasticity
中的符号一致。现在我用符号 <span class="math inline">\(:=\)</span>
进行赋值，左侧为变量名。右侧为具体值，例如</p>
<blockquote>
<p>取测试函数（test function）为常数，也即 <span
class="math inline">\(v_{i,j}(y) := v_{i,j}\)</span></p>
</blockquote>
<h2 id="参考文档">参考文档</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xODIxMDEvYXBwcm9wcmlhdGUtbm90YXRpb24tZXF1aXYtdmVyc3Vz">Appropriate
Notation: ≡ versus :=<i class="fa fa-external-link-alt"></i></span> 给出了为什么我用 <span
class="math inline">\(\triangleq\)</span> 取代 <span
class="math inline">\(:=\)</span> 作为定义符号的原因</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1YWxzX3NpZ24=">Equal sign<i class="fa fa-external-link-alt"></i></span>
给出了等号的历史来源，以及所有可能见到的表示左右两端存在某种关系的符号，比如
<span class="math inline">\(\approx\)</span>，<span
class="math inline">\(\cong\)</span> ……</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xMDU4NTk2L2luLXBsYWluLWxhbmd1YWdlLXdoYXRzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tdHdvLXRoaW5ncy10aGF0LWFyZS1lcXVpdmFsZW50">In
plain language, what's the difference between two things that are
'equivalent', 'equal', and 'identical'?<i class="fa fa-external-link-alt"></i></span> 给出了 <span
class="math inline">\(\equiv\)</span> 在数论中的含义</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>符号约定</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵指数</title>
    <url>/math/%E7%9F%A9%E9%98%B5%E6%8C%87%E6%95%B0/</url>
    <content><![CDATA[<p>矩阵指数 (Matrix Exponential) 定义为 <span class="math display">\[
e^{A} \triangleq \sum_{k=0}^{\infty} \frac{1}{k!}A^k
\]</span> 因为之后要用到矩阵指数表示常微分方程组的解,
所以在上式中加入时间项 <span class="math display">\[
e^{At} \triangleq \sum_{k=0}^{\infty} \frac{t^k}{k!}A^k
\]</span> 在接下来的计算中, 我们给出 <span
class="math inline">\(e^{At}\)</span> 而不是 <span
class="math inline">\(e^A\)</span>, 因为虽然 <span
class="math inline">\(e^{At}\)</span> 与 <span
class="math inline">\(e^{A}\)</span> 计算过程相同, 但是从 <span
class="math inline">\(e^A\)</span> 的结果并不是可以很轻松地得到 <span
class="math inline">\(e^{At}\)</span> 的形式.
所以直接给出更一般的结论.</p>
<p>通过级数的定义式, 可以得到一些特殊矩阵级数的表达式<span id="more"></span></p>
<blockquote>
<p>[!TIP]</p>
<p><span class="math inline">\(A = I\)</span> 时, 矩阵指数为 <span
class="math display">\[
e^{It} = \sum_{k=0}^{\infty} \frac{1}{k!} I^k t^k
= \left( \sum_{k=0}^{\infty} \frac{t^k}{k!}  \right)I
= e^{t} I
\]</span></p>
</blockquote>
<blockquote>
<p>[!TIP]</p>
<p><span class="math inline">\(A = \mathrm{diag}(a_1, a_2, \ldots,
a_n)\)</span> 时, 矩阵指数为 <span class="math display">\[
\begin{aligned}
e^{At} &amp;= \sum_{k=0}^{\infty} \frac{t^k}{k!} \mathrm{diag}(a_1^k,
a_2^k, \ldots, a_n^k)
= \mathrm{diag}(
\sum_{k=0}^{\infty} \frac{t^k}{k!}a_1^k,
\sum_{k=0}^{\infty} \frac{t^k}{k!}a_2^k, \ldots,
\sum_{k=0}^{\infty} \frac{t^k}{k!}a_n^k) \\
&amp;= \mathrm{diag}(e^{a_1 t}, e^{a_2 t}, \ldots, e^{a_n t})
\end{aligned}
\]</span></p>
</blockquote>
<blockquote>
<p>[!TIP]</p>
<p><span class="math inline">\(A\)</span> 可以对角化时: <span
class="math display">\[
A = P \Lambda P^{-1}, ~\Lambda = \mathrm{diag}(\lambda_1, \lambda_2,
\ldots, \lambda_n)
\]</span></p>
<p><span class="math display">\[
e^{At} = \sum_{k=0}^{\infty} \frac{t^k}{k!} \left( P \Lambda P^{-1}
\right)^k
= P \left( \sum_{k=0}^{\infty} \frac{t^k}{k!}\Lambda^k \right) P^{-1}
= P e^{\Lambda t} P^{-1}
\]</span></p>
</blockquote>
<p>除此之外, 还可以根据矩阵乘积随幂次增长的规律,
得到另一些常见矩阵的指数</p>
<blockquote>
<p>[!TIP]</p>
<p>矩阵 <span class="math inline">\(A\)</span> 时 Nilpotent 矩阵, 如果
<span class="math display">\[
A^N = 0
\]</span> 这意味着矩阵指数只涉及到有限项矩阵幂的求和: <span
class="math display">\[
e^{At} = \sum_{k=0}^{N} \frac{t^k}{k!}A^k
\]</span> 对于方阵 <span class="math inline">\(A\)</span>,
如果对角线以及对角线(上/下)所有元素都等于 0, 那么该矩阵就是 <span
class="math inline">\(n\)</span> 次的 Nilpotent 矩阵, 例如 <span
class="math display">\[
A = \begin{pmatrix}
  0 &amp; 1\\0 &amp; 0
\end{pmatrix}, \quad
A^2 = \begin{pmatrix}
  0 &amp; 0\\0 &amp; 0
\end{pmatrix}, \quad
e^{At} = \begin{pmatrix}
  1 &amp; 0\\0 &amp; 1
\end{pmatrix}
+ t\begin{pmatrix}
  0 &amp; 1\\0 &amp; 0
\end{pmatrix}
= \begin{pmatrix}
  1 &amp; t\\0 &amp; 1
\end{pmatrix}
\]</span></p>
</blockquote>
<blockquote>
<p>[!TIP]</p>
<p>矩阵 <span class="math inline">\(A\)</span> 为 <span
class="math display">\[
A = \begin{pmatrix}
  0 &amp; 1\\-1 &amp; 0
\end{pmatrix}
\]</span> 计算前 4 项的矩阵幂为 <span class="math display">\[
A^2 = -I, \quad
A^3 = -A, \quad
A^4 =  I
\]</span> 所以 <span class="math display">\[
e^{At}
= \begin{pmatrix}
  0 &amp; \sum_{k=0}^{\infty}\frac{(-t)^k}{(2k+1)!}\\
  -\sum_{k=0}^{\infty}\frac{(-t)^k}{(2k+1)!} &amp; 0
\end{pmatrix}
+ \begin{pmatrix}
  \sum_{k=0}^{\infty}\frac{(-t)^k}{(2k)!} &amp; 0\\
  0 &amp; \sum_{k=0}^{\infty}\frac{(-t)^k}{(2k)!}
\end{pmatrix}
= \begin{pmatrix}
   \cos t &amp; \sin t\\
  -\sin t &amp; \cos t
\end{pmatrix}
\]</span></p>
</blockquote>
<blockquote>
<p>[!TIP]</p>
<p>矩阵 <span class="math inline">\(A\)</span> 为 <span
class="math display">\[
A = \begin{pmatrix}
\lambda &amp; 1 \\
0 &amp; \lambda
\end{pmatrix}
\]</span> 那么 <span class="math display">\[
A^{k} = \begin{pmatrix}
\lambda^k &amp; k\lambda^{k-1} \\
0 &amp; \lambda^k
\end{pmatrix}
\]</span> 所以 <span class="math display">\[
e^{At} = I + \sum_{k=1}^{\infty} \frac{t^k}{k!}\begin{pmatrix}
\lambda^k &amp; k\lambda^{k-1} \\
0 &amp; \lambda^k
\end{pmatrix}
= \lim_{N\rightarrow \infty} \begin{pmatrix}
\sum_{k=0}^{N} \frac{(t\lambda)^k}{k!} &amp; t\sum_{k=0}^{N-1}
\frac{(t\lambda)^k}{k!} \\
0 &amp; \sum_{k=0}^{N} \frac{(t\lambda)^k}{k!}
\end{pmatrix}
= e^{\lambda t}\begin{pmatrix}
1 &amp; t \\
0 &amp; 1
\end{pmatrix}
\]</span></p>
</blockquote>
<blockquote>
<p>[!TIP]</p>
<p>矩阵 <span class="math inline">\(A\)</span> 的另一种计算方法 <span
class="math display">\[
A = \begin{pmatrix}
\lambda &amp; 1 \\
0 &amp; \lambda
\end{pmatrix}
\]</span> 有如下定理:</p>
<p>如果 <span class="math inline">\(AB = BA\)</span>, 那么 <span
class="math inline">\(e^{A+B} = e^{B+A}\)</span>.</p>
<p>将矩阵 <span class="math inline">\(A\)</span> 分解为 <span
class="math display">\[
A = \begin{pmatrix}
\lambda &amp; 0 \\
0 &amp; \lambda
\end{pmatrix}
+ \begin{pmatrix}
0 &amp; 1 \\
0 &amp; 0
\end{pmatrix} = B+C
\]</span> 容易验证 <span class="math inline">\(BC = CB\)</span>, 所以
<span class="math display">\[
e^{At} = e^{Bt}e^{Ct} = e^{\lambda t}I\begin{pmatrix}
  1 &amp; t\\0 &amp; 1
\end{pmatrix}
= e^{\lambda t} \begin{pmatrix}
  1 &amp; t\\0 &amp; 1
\end{pmatrix}
\]</span></p>
</blockquote>
<p>好了, 经过前面的热身之后, 我们现在来处理讨厌的 Jordan 标准型情况.
任何 <span class="math inline">\(n\)</span> 维矩阵都可以分解为对角线上为
Jordan 标准块的 “对角”矩阵: <span class="math display">\[
A = P \mathrm{diag}(J_1, J_2, \ldots, J_k) P^{-1}, \quad k \leq n
\]</span> 我们需要特别考虑重根情况. 只有出现重根时, 才有可能用到 Jordan
标准型. 设特征根 <span class="math inline">\(\lambda_i\)</span> 为 <span
class="math inline">\(m_i\)</span> 阶代数重根, 对应的特征向量空间 <span
class="math inline">\(E_{\lambda_i}\)</span>, 特征向量空间的维度 <span
class="math inline">\(\dim E_{\lambda_i}\)</span>
总是小于等于该特征值对应的代数重数的, 并且根据定义, <span
class="math inline">\(\dim E_{\lambda_i} \geq 1\)</span>. 所以 <span
class="math display">\[
1 \leq \dim E_{\lambda_i} \leq m_i
\]</span> 当 <span class="math inline">\(\dim E_{\lambda_i} &lt;
m_i\)</span> 时, 就会出现维度大于 1 的 Jordan 块. 一个典型的 Jordan
块可以表示为如下次对角线为 1 的矩阵: <span class="math display">\[
J_i = \begin{pmatrix}
\lambda_i &amp; 1 &amp;  &amp; 0 \\
                    &amp; \lambda_i &amp; \ddots &amp; \\
                 &amp;  &amp; \ddots &amp; 1\\
                0 &amp;  &amp;  &amp; \lambda_i
\end{pmatrix}_{m\times m}
\]</span> 关于 Jordan 块有如下性质:</p>
<ol type="1">
<li><span class="math inline">\(J_i\)</span> 只有一个特征值 <span
class="math inline">\(\lambda_i\)</span>;</li>
<li><span class="math inline">\(\dim E_{\lambda_i} = 1\)</span>,
或者更确切地说, <span class="math inline">\(E_{\lambda_i} =
\mathrm{span} \{ (1,0,0,\ldots,0)^\top \}\)</span>, 因为矩阵 <span
class="math inline">\(J_i - \lambda_i I\)</span> 的零空间是一维的;</li>
<li>使得 <span class="math inline">\((J_i - \lambda_i I)^p = 0\)</span>
的最小 <span class="math inline">\(p\)</span> 值为 <span
class="math inline">\(m\)</span>, 也即 <span class="math inline">\((J_i
- \lambda_i I)^m = 0\)</span>;</li>
<li>设 <span class="math inline">\(\{e_i\}\)</span> 为空间 <span
class="math inline">\(\mathbb{C}^{m}\)</span> 的标准基, 那么对任意的
<span class="math inline">\(i\)</span>, <span class="math inline">\((J_i
- \lambda_i I)^i e_k = 0\)</span>, <span class="math inline">\(k =
1,2,\ldots, i\)</span></li>
</ol>
<p>由性质 4, 我们可以定义广义的特征向量空间 <span
class="math inline">\(K_{\lambda_i}\)</span> <span
class="math display">\[
K_{\lambda_i} = \{ x \mid (A - \lambda I)^px = 0  \}
\]</span> 接下来, 我们将陈述 Jordan 分解定理</p>
<p>对于 <span class="math inline">\(n\)</span> 阶方阵 <span
class="math inline">\(A\)</span>, 得到特征值序列 <span
class="math inline">\(\lambda_1, \lambda_2, \ldots, \lambda_k\)</span>,
以及相应的代数重数 <span class="math inline">\(m_1, m_2, \ldots,
m_k\)</span>, 有如下结论</p>
<ol type="1">
<li><span class="math inline">\(\dim K_{\lambda_i} = m_i\)</span>;</li>
<li><span class="math inline">\(\mathbb{C}^{n} = K_{\lambda_1} \oplus
K_{\lambda_2} \oplus \cdots \oplus K_{\lambda_k}\)</span>;</li>
</ol>
<p>好了, 上述结论告诉我们 Jordan 分解是可行的, 可是具体要怎么做呢?
关键的地方就在于此. 我们希望将矩阵 <span
class="math inline">\(A\)</span> 分解为 <span class="math display">\[
A = P J P^{-1}
\]</span> 式中, <span class="math inline">\(J\)</span> 为 Jordan 标准型,
对于可对角化的矩阵, <span class="math inline">\(P\)</span>
是由特征向量组成的矩阵. 对于 Jordan 标准型, 该怎样构造 <span
class="math inline">\(P\)</span> 呢?</p>
<p>我们将上述矩阵写成如下特征向量的形式 <span class="math display">\[
A ( v_1, v_2, v_3, \ldots ) = ( v_1, v_2, v_3, \ldots ) J
= (\lambda v_1, \lambda v_2 + v_1, \lambda v_3 + v_2, \ldots)
\]</span> 所以有 <span class="math display">\[
(A - \lambda I) v_1 =  0, \\
(A - \lambda I) v_2 = v_1 \iff (A - \lambda I)^2 v_2 = 0 \\
(A - \lambda I) v_3 = v_2 \iff (A - \lambda I)^3 v_3 = 0 \\
\cdots
\]</span> 因此, 我们可以递归地确定向量 <span class="math inline">\(v_1,
v_2, v_3, \ldots\)</span>. 首先根据 <span
class="math inline">\(N(A-\lambda I)\)</span> 确定特征向量空间 <span
class="math inline">\(E_1\)</span>, 再求解 <span
class="math inline">\(N(A-\lambda I)^2\)</span>, 确定特征向量空间 <span
class="math inline">\(E_2\)</span>, 依此类推确定特征向量空间 <span
class="math inline">\(E_3, \ldots, E_m\)</span>, 那么,
最终确定的特征向量族为 <span class="math display">\[
v_m \in E_m / \bigcup_{i=1}^{m-1} E_i, \quad v_{m-1} = (A - \lambda
I)v_m, \ldots
\]</span></p>
<blockquote>
<p>[!CAUTION]</p>
<p>矩阵 <span class="math inline">\(P\)</span> 的排列必须严格按照 <span
class="math inline">\((v_1, v_2, v_3, \ldots)\)</span> 的顺序,
否则无法得到 Jordan 标准形式.</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微分方程</tag>
        <tag>Jordan 标准型</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式相关的概念</title>
    <url>/math/%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<p>对于 <span class="math inline">\(n\)</span> 阶行列式 <span
class="math inline">\(|A|\)</span>, 去掉 <span
class="math inline">\(i\)</span> 行和 <span
class="math inline">\(j\)</span> 列得到的 <span
class="math inline">\(n-1\)</span> 阶行列式记作<strong>余因式</strong>
<span class="math inline">\(c_{ij}\)</span>, 行列式 <span
class="math inline">\(|A|\)</span> 的<strong>代数余子式</strong>定义为
<span class="math display">\[
m_{ij} \triangleq (-1)^{i+j} c_{ij}
\]</span> 行列式可以按照行或者列展开为低阶行列式的线性组合: <span
class="math display">\[
|A| = \sum_{i=1}^{n} a_{ij} m_{ij} = \sum_{j=1}^{n} a_{ij} m_{ij}
\]</span> <span id="more"></span>此外, 如果选取不同的行(列),
那么展开的线性组合总是等于 0: <span class="math display">\[
\sum_{j=1}^{n} a_{ij} m_{kj} = 0, \quad i \neq k \\
\sum_{i=1}^{n} a_{ij} m_{ik} = 0, \quad j \neq k
\]</span> 因此, 可以将上述两个结论通过 <span
class="math inline">\(\delta_{ij}\)</span> 总结成一个公式: <span
class="math display">\[
a_{ki} m_{kj} = a_{ik} m_{jk} = |A| \delta_{ij}
\]</span> 将上式写成矩阵形式为 <span class="math display">\[
A M^{\top} = M^{\top} A = |A| I
\]</span> 通常将 <span class="math inline">\(M^{\top}\)</span>
定义为矩阵 <span class="math inline">\(A\)</span> 的<strong>伴随
(adjugate) 矩阵</strong>, <span class="math inline">\(M\)</span> 称为
<strong>cofactor</strong> 矩阵: <span class="math display">\[
\mathrm{adj}~A \triangleq M^{\top}
\]</span> 注意到, 如果矩阵 <span class="math inline">\(A\)</span> 可逆,
那么伴随矩阵与矩阵的逆之间的关系为 <span class="math display">\[
A^{-1} = \frac{1}{|A|}\mathrm{adj}~A = \frac{1}{|A|} M^{\top}
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<p>矩阵 <span class="math inline">\(A\)</span> 的逆可以通过伴随矩阵表示,
但即使矩阵 <span class="math inline">\(A\)</span> 不可逆, <span
class="math inline">\(A\)</span> 的伴随矩阵同样存在</p>
</blockquote>
<blockquote>
<p>[!TIP]</p>
<h5 id="克莱默法则的证明">克莱默法则的证明</h5>
<p>对于线性方程组 <span class="math display">\[
A x = b
\]</span> 并且矩阵 <span class="math inline">\(A\)</span> 可逆. 那么
<span class="math display">\[
x = A^{-1} b = \frac{1}{|A|} M^{\top} b
\]</span> 写成分量的形式为 <span class="math display">\[
x_i = \frac{1}{|A|} m_{ji} b_j
\]</span> 若构造矩阵 <span class="math inline">\(A^{i}\)</span>,
使得矩阵第 <span class="math inline">\(i\)</span> 列替换为向量 <span
class="math inline">\(b\)</span>, 并按照第 <span
class="math inline">\(i\)</span> 列展开, 就得到 <span
class="math display">\[
|A^{i}| = \sum_{j} b_j m_{ji}
\]</span> 因此有 <span class="math display">\[
x_{i} = \frac{|A^i|}{|A|}
\]</span></p>
</blockquote>
<p>对于矩阵 <span class="math inline">\(A\)</span> 的特征多项式 <span
class="math inline">\(A(\lambda)\)</span> <span class="math display">\[
A(\lambda) \triangleq |\lambda I - A|
\]</span> 是关于 <span class="math inline">\(\lambda\)</span> 的 <span
class="math inline">\(n\)</span> 次多项式, 可以证明, 上式的前两项为
<span class="math display">\[
A(\lambda) = \lambda^{n} -\mathrm{tr}A~\lambda^{n-1} + \cdots
\]</span> 因此, 如果 <span class="math inline">\(\|A\| \ll 1\)</span>,
那么 <span class="math display">\[
|I + A| \sim 1 + \mathrm{tr}A
\]</span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>行列式</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑命题视角下的极限 连续与一致连续</title>
    <url>/math/%E9%80%BB%E8%BE%91%E5%91%BD%E9%A2%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%9E%81%E9%99%90-%E8%BF%9E%E7%BB%AD%E4%B8%8E%E4%B8%80%E8%87%B4%E8%BF%9E%E7%BB%AD/</url>
    <content><![CDATA[<h3 id="极限的定义-以及否定形式">极限的定义, 以及否定形式</h3>
<p>关于序列 <span class="math inline">\(\{a_n\}\)</span>
的极限命题为:</p>
<blockquote>
<p>对任意的 <span class="math inline">\(\varepsilon &gt; 0\)</span>,
存在 <span class="math inline">\(N \in \mathbb{N}\)</span>, 当 <span
class="math inline">\(n&gt;N\)</span> 时, <span
class="math inline">\(|a_n - a| &lt; \varepsilon\)</span></p>
</blockquote>
<p>我们用<strong>含参数的陈述</strong>表示上述命题的后半段:</p>
<p><span class="math display">\[
S(N, \varepsilon): n &gt; N \Rightarrow |a_n - a| &lt; \varepsilon
\]</span></p>
<span id="more"></span>
<p>当给定 <span class="math inline">\((N, \varepsilon)\)</span> 时,
就可以确定该命题的真伪.
极限定义就是对上述含参数的陈述添加量词进行修饰:</p>
<p><span class="math display">\[
a_n \rightarrow a \Leftrightarrow \forall \varepsilon &gt; 0, \exists N
\in \mathbb{N} \quad n &gt; N \Rightarrow |a_n - a| &lt; \varepsilon
\]</span></p>
<p>注意, <span class="math inline">\(\forall \varepsilon &gt;0\)</span>
 与 <span class="math inline">\(\exists N \in \mathbb{N}\)</span>
不能交换顺序, 也即含量词陈述的命题, 量词的顺序不能随意改变, 例如,
如果修改成</p>
<p><span class="math display">\[
\exists N \in \mathbb{N}, \forall \varepsilon &gt; 0 \quad n &gt; N
\Rightarrow |a_n - a| &lt; \varepsilon
\]</span></p>
<p>那么只有常数序列才能存在极限, 这样的定义就是平凡的了.</p>
<p>注意到, 含量词的命题可以等价为:</p>
<ul>
<li><p><span class="math inline">\(\forall x \in X \quad S(x)
\Longleftrightarrow \bigwedge_{x \in X} S(x)\)</span>;</p></li>
<li><p><span class="math inline">\(\exists x \in X \quad S(x)
\Longleftrightarrow \bigvee_{x \in X} S(x)\)</span>.</p></li>
</ul>
<p>式中, <span class="math inline">\(\wedge\)</span> 表示命题关系“与”
(AND), <span class="math inline">\(\vee\)</span> 表示命题关系“或”(OR).
当否定含量词的命题时, 根据 de Morgan 定律: <span class="math display">\[
(B~\cup~C)^{\prime} = B^{\prime}~\cap~C^{\prime}\\
(B~\cap~C)^{\prime} = B^{\prime}~\cup~C^{\prime}
\]</span></p>
<ul>
<li><p><span class="math inline">\(\sim(\forall x \in X \quad S(x))
\Longleftrightarrow \bigvee_{x \in X}\sim S(x) \Longleftrightarrow
\exists x \in X \quad \sim S(x)\)</span>;</p></li>
<li><p><span class="math inline">\(\sim(\exists x \in X \quad S(x))
\Longleftrightarrow \bigwedge_{x \in X} \sim S(x)\Longleftrightarrow
\forall x \in X \quad \sim S(x)\)</span>.</p></li>
</ul>
<p>注意到, 含参数陈述命题的取值集合 <span
class="math inline">\(X\)</span> 不会发生改变 (比如取该集合的补集).
由此我们可以得到极限命题的否定形式:</p>
<p><span class="math display">\[
\exists \varepsilon &gt; 0, \forall N \in \mathbb{N} \quad n &gt; N
\wedge |a_n - a| \geq \varepsilon
\]</span></p>
<p>该命题后半部分可以合并为:</p>
<p><span class="math display">\[
\exists \varepsilon &gt; 0, \forall N \in \mathbb{N} \quad |a_N - a|
\geq \varepsilon
\]</span></p>
<h3 id="连续与一致连续">连续与一致连续</h3>
<p>我们用逻辑语言定义一致连续: 给定函数 <span class="math inline">\(f: A
\mapsto \mathbb{R}^m\)</span>, 定义域 <span class="math inline">\(A
\subset \mathbb{R}^n\)</span> :</p>
<p><span class="math display">\[
\forall \varepsilon &gt; 0, \textcolor{red}{\exists \delta &gt; 0},
\forall y \in A, \forall x \in A \quad \|x-y\|\leq\delta \Rightarrow
\|f(x) - f(y)\| \leq \varepsilon
\]</span></p>
<p>而函数 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(A\)</span> 上连续的定义为</p>
<p><span class="math display">\[
\forall \varepsilon &gt; 0, \forall y \in A, \textcolor{red}{\exists
\delta &gt; 0}, \forall x \in A \quad \|x-y\|\leq\delta \Rightarrow
\|f(x) - f(y)\| \leq \varepsilon
\]</span></p>
<p>第二个定义中, 存在量词变量 <span
class="math inline">\(\delta\)</span> 的选择依赖于之前全称量词变量 <span
class="math inline">\(y\)</span>,
这一点改变使得第一个定义和第二个定义并不是等价的
(虽然看起来只是命题叙述的顺序发生了变化). 事实上,
第一个命题蕴含第二个命题:</p>
<p><span class="math display">\[
f~\text{一致连续} \Rightarrow f~\text{连续}
\]</span></p>
<p>证明上述问题是乏味的, 甚至像是在玩弄文字游戏, 我们不妨做一点别的事情,
比如, 将定义连续的命题中的存在量词 <span class="math inline">\(\exists
\delta &gt; 0\)</span> 继续后移:</p>
<p><span class="math display">\[
\forall \varepsilon &gt; 0, \forall y \in A, \forall x \in A,
\textcolor{red}{\exists \delta &gt; 0} \quad \|x-y\|\leq\delta
\Rightarrow \|f(x) - f(y)\| \leq \varepsilon
\]</span></p>
<p>该命题本身就构成了重言式, 也就是说, 该命题一直为 true. 证明过程如下:
对任意给定的 <span class="math inline">\(\varepsilon, x, y\)</span>, 取
<span class="math inline">\(\delta &gt; \|x-y\|\)</span>, 根据蕴含命题
<span class="math inline">\(p \Rightarrow q\)</span> 的真值表, 若 <span
class="math inline">\(p\)</span> 为 false, 则 <span
class="math inline">\(p \Rightarrow q\)</span> 恒为 true, 无论 <span
class="math inline">\(q\)</span> 怎样取值. 因此, <span
class="math inline">\(\|x-y\|\leq\delta \Rightarrow \|f(x) - f(y)\| \leq
\varepsilon\)</span> 恒为 true.</p>
<p>假如我们将第三个定义称为”弱连续”, 那么, 根据上述论证,
所有的函数都是”弱连续”的, 因此, “弱连续“
就不能够将某一类函数与其它函数区分开. “弱连续“ 的定义是平凡的.</p>
<p>现在, 如果我们将存在量词移到命题的最前端:</p>
<p><span class="math display">\[
\textcolor{red}{\exists \delta &gt; 0}, \forall \varepsilon &gt; 0,
\forall y \in A, \forall x \in A \quad \|x-y\|\leq\delta \Rightarrow
\|f(x) - f(y)\| \leq \varepsilon
\]</span></p>
<p>并称满足这个定义的函数为”强一致收敛”函数, 可以看到,
“强一致收敛“函数只能是常值函数, 因此也是一致收敛函数.综上,
我们有上述关于连续性命题的强弱关系: <span class="math display">\[
f~\text{强一致连续} \Rightarrow f~\text{一致连续} \Rightarrow
f~\text{连续} \Rightarrow f~\text{弱连续}
\]</span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>逻辑命题</tag>
        <tag>极限定义</tag>
      </tags>
  </entry>
  <entry>
    <title>Bessel 位势和 Yukawa 位势</title>
    <url>/math/Fourier-analysis/Bessel-%E4%BD%8D%E5%8A%BF%E5%92%8C-Yukawa-%E4%BD%8D%E5%8A%BF/</url>
    <content><![CDATA[<p>Bessel 方程定义为 <span class="math display">\[
-\Delta u + u = f
\]</span> 为了求该方程的基本解, 方程右端非齐次项换成 Delta 函数 <span
class="math inline">\(\delta\)</span>. 两边作 Fourier 变换, 就得到 <span
class="math display">\[
(1 + 4\pi^2 |\xi|^2) \widehat{B} = 1
\]</span> 接下来要求解函数 <span
class="math inline">\(\widehat{B}(\xi)\)</span> 的 Fourier 逆变换,
又称为 Bessel 位势 <span class="math display">\[
B(x)
= \int_{\mathbb{R}^d} \frac{e^{i2\pi \xi \cdot x}}{1 + 4\pi^2 |\xi|^2}
~\mathrm{d}\xi
\]</span> <span id="more"></span>但是这个积分我们不会算啊, 怎么办?
一种思路是将该积分转换为我们熟悉的 Gauss 积分, 我们知道 <span
class="math display">\[
\int_0^{\infty} e^{-ct} \mathrm{d}t = \frac{1}{c}
\]</span> 将积分中的常数 <span class="math inline">\(c\)</span> 换成
Bessel 位势, 就得到 <span class="math display">\[
\widehat{B}(\xi) = \int_0^{\infty} e^{-t - 4\pi^2 t |\xi|^2} \mathrm{d}t
\]</span> 不幸的是, 我们现在多了一层积分, 幸运的是, 我们把讨厌的 <span
class="math inline">\(|\xi|^2\)</span> 移到指数上去了, 这就可以通过
Gauss 积分处理, 如果我们默认积分是可以换序的: <span
class="math display">\[
\int_0^{\infty} e^{-t} \int_{\mathbb{R}^d} e^{i2\pi \xi \cdot x}  e^{-
4\pi^2 t |\xi|^2}
~\mathrm{d}\xi \mathrm{d}t
\]</span> 这就得到 <span class="math display">\[
\int_0^{\infty} e^{-t} (4\pi^2 t)^{-d/2} e^{-|x|^2/4\pi^2 t}
~\mathrm{d}t
\]</span> 特别的, 当 <span class="math inline">\(d=1\)</span> 时, 积分为
<span class="math display">\[
B(x)
= \int_{\mathbb{R}} \frac{e^{i2\pi \xi x}}{1 + 4\pi^2 \xi^2}
~\mathrm{d}\xi
\]</span> 我们可以通过留数积分来计算, 考虑函数 <span
class="math display">\[
f(z) = \frac{1}{1 + 4\pi^2 z^2}
\]</span> 注意到当 <span class="math inline">\(|z| \rightarrow
\infty\)</span> 时, <span class="math inline">\(f(z) \rightarrow
0\)</span>. 考虑上半平面的半圆, 可以证明, 当半圆半径 <span
class="math inline">\(R \rightarrow \infty\)</span> 时, 在半圆弧上的积分
<span class="math display">\[
\lim_{R \rightarrow \infty} \int_{\Gamma_R} f(z) e^{i2\pi x z}
~\mathrm{d}z = 0
\]</span> 因此 <span class="math display">\[
\oint_{C} f(z) e^{i2\pi x z} ~\mathrm{d}z = \int_{\mathbb{R}} f(\xi)
e^{i2\pi x \xi} ~\mathrm{d}\xi
= 2\pi i \mathrm{Res}
\]</span> 因此问题转化为计算留数. 函数 <span
class="math inline">\(f(z)\)</span> 的极点为 <span
class="math display">\[
\pm\frac{1}{2\pi i}
\]</span> 选择位于上半平面的极点 <span class="math inline">\(-1/2\pi
i\)</span>, 得到留数为 <span class="math display">\[
\mathrm{Res} = \lim_{z\rightarrow z_0} (z-z_0) f(z) e^{i2\pi x z}
= -\frac{i}{4\pi} e^{-x}
\]</span> 最终得到 <span class="math display">\[
\int_{\mathbb{R}} f(\xi) e^{i2\pi x \xi} ~\mathrm{d}\xi
= \frac{1}{2} e^{-x}
\]</span> 但是这个答案是不完全对的! 因为一维的 Bessel 位势为 <span
class="math display">\[
B(x) = \frac{1}{2} e^{-|x|}
\]</span> 我没有看到怎样把这个绝对值的符号加进去.</p>
]]></content>
      <categories>
        <category>Fourier 分析</category>
      </categories>
      <tags>
        <tag>Bessel 方程</tag>
        <tag>Yukawa 位势</tag>
      </tags>
  </entry>
  <entry>
    <title>Fourier-变换和逆变换公式的一致性</title>
    <url>/math/Fourier-analysis/Fourier-%E5%8F%98%E6%8D%A2%E5%85%AC%E5%BC%8F%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<p>Fourier 变换公式, 在不同的应用场景下, 定义可能是不一样的. 但是,
Fourier 逆变换公式必须与变换公式保持<strong>一致</strong>, 才能满足
Fourier 逆定理. 例如, 定义一种 Fourier 变换方式如下 <span
class="math display">\[
\hat f(\xi) \triangleq \int_{\mathbb{R}^d} f(x) e^{-i2\pi x \cdot \xi}
~\mathrm{d} x
\]</span> Fourier 逆变换公式并<strong>不是通过定义得到,</strong>
而是<strong>根据 Fourier 逆定理推导得到</strong>: <span
class="math display">\[
f(x) =  \int_{\mathbb{R}^d} \hat f(\xi) e^{i2\pi x \cdot \xi}
~\mathrm{d} \xi
\]</span> 上面例子的好处是不需要在变换公式的前面引入额外的系数. 接下来,
我们将根据这一公式, 利用积分变换, 得到不同形式下一致的 Fourier
变换和逆变换公式. <span id="more"></span>首先定义一般的 Fourier 变换公式: <span
class="math display">\[
\tilde f(\xi) \triangleq b\int_{\mathbb{R}^d} f(x) e^{-i2\pi a x \cdot
\xi} ~\mathrm{d} x
= b \hat f(a\xi)
\]</span> 对应的 Fourier 逆变换公式为 <span class="math display">\[
f(x) = b&#39; \int_{\mathbb{R}^d} \tilde f(\xi) e^{i 2\pi a x \cdot
\xi}  ~\mathrm{d} \xi
= b b&#39; \int_{\mathbb{R}^d} \hat f(a \xi) e^{i 2\pi a x \cdot
\xi}  ~\mathrm{d} \xi
\]</span> 作换元 <span class="math inline">\(a\xi = \eta\)</span>, 那么
<span class="math inline">\(a^d \mathrm{d} \xi = \mathrm{d}
\eta\)</span>, 代入公式中得到 <span class="math display">\[
f(x) = a^{-d} b b&#39; \int_{\mathbb{R}^d} \hat f(\eta) e^{i 2\pi x
\cdot \eta}  ~\mathrm{d} \eta
= a^{-d} b b&#39; f(x)
\]</span> 由此得到变换公式中设定的变量之间的关系为 <span
class="math display">\[
a^{-d} b b&#39; \equiv 1
\]</span> 综上所述, <span class="math display">\[
\boxed{
\begin{aligned}
\hat f(\xi) &amp;= b \int_{\mathbb{R}^d} f(x) e^{-i2\pi a x \cdot \xi}
~\mathrm{d} x \\
f(x) &amp;= \frac{a^d}{b~} \int_{\mathbb{R}^d} \hat f(\xi) e^{i2\pi a x
\cdot \xi} ~\mathrm{d} \xi
\end{aligned}
}
\]</span> <div class="note info no-icon"><p>评注:</p>
<p>按照上式定义的 Fourier 变换公式, 对于偏导数的 Fourier 变换为 <span
class="math display">\[
\widehat{\frac{\partial f}{\partial x_i}} = i2\pi a\xi_i \hat f(\xi)
\]</span> 该公式与积分项前的系数无关.</p>
</div></p>
<p>现在考虑一些常用的情况. 对于一维情景, 如果定义 Fourier 变换公式为
<span class="math display">\[
\hat f(\xi) \triangleq \int_{\mathbb{R}} f(x) e^{-i x \xi} ~\mathrm{d} x
, \quad
b = 1, \quad a = \frac{1}{2\pi}
\]</span> 那么对应的 Fourier 逆变换公式为 <span class="math display">\[
f(x) = \frac{1}{2\pi} \int_{\mathbb{R}} f(x) e^{i x \xi} ~\mathrm{d} \xi
\]</span> 推广到三维场景, 那么 <span class="math display">\[
\begin{aligned}
\hat f(\xi) &amp;\triangleq \int_{\mathbb{R}^3} f(x) e^{-i x \cdot \xi}
~\mathrm{d} x \\
f(x) &amp;= \frac{1}{(2\pi)^3} \int_{\mathbb{R}^3} \hat f(\xi) e^{i x
\cdot \xi} ~\mathrm{d} \xi
\end{aligned}
\]</span> 如果希望 Fourier 变换与逆变换公式前的系数相等, 那么有 <span
class="math display">\[
b = a^{d/2}
\]</span> 如果继续考虑 <span class="math inline">\(a = 1/2\pi\)</span>
的情景, 那么</p>
<p>一维情景 <span class="math display">\[
\begin{aligned}
\hat f(\xi) &amp;\triangleq \frac{1}{\sqrt{2\pi}} \int_{\mathbb{R}} f(x)
e^{-i x \xi} ~\mathrm{d} x \\
f(x) &amp;= \frac{1}{\sqrt{2\pi}} \int_{\mathbb{R}} \hat f(\xi) e^{i x
\xi} ~\mathrm{d} \xi
\end{aligned}
\]</span> 三维情景 <span class="math display">\[
\begin{aligned}
\hat f(\xi) &amp;\triangleq  \frac{1}{(2\pi)^{3/2}} \int_{\mathbb{R}^3}
f(x) e^{-i x \cdot \xi} ~\mathrm{d} x \\
f(x) &amp;= \frac{1}{(2\pi)^{3/2}} \int_{\mathbb{R}^3} \hat f(\xi) e^{i
x \cdot \xi} ~\mathrm{d} \xi
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>Fourier 分析</category>
      </categories>
      <tags>
        <tag>Fourier 变换</tag>
      </tags>
  </entry>
  <entry>
    <title>Fourier 级数的一些性质</title>
    <url>/math/Fourier-analysis/Fourier-%E7%BA%A7%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<p>对于 <span class="math inline">\([0,1]\)</span> 上的周期函数 <span
class="math inline">\(f(x):\mathbb{R} \mapsto \mathbb{C}\)</span>,
其内积定义为 <span class="math display">\[
\langle f(x), g(x) \rangle \triangleq \frac{1}{L} \int_0^{L} f(x)
\overline{g(x)} ~\mathrm{d}x
\tag{$\star$}
\]</span> <span class="math inline">\(f(x)\)</span>​ 的 Fourier
级数表示为 <span class="math display">\[
f(x) \sim \sum_{k=-\infty}^{\infty} c_k e^{i 2\pi k x},
\tag{1}
\]</span> <span id="more"></span>其系数 <span class="math inline">\(c_k\)</span> 为:
<span class="math display">\[
c_k = \langle f(x), e^{i 2\pi k x} \rangle = \int_{0}^{1} f(x) e^{-i
2\pi k x} ~\mathrm{d}x
\tag{2}
\]</span> ## Parseval 等式</p>
<p>根据式 (1) (2) 我们可以得到关系 <span class="math inline">\(f(x) \sim
\{ c_k \}\)</span>, 而 Parseval 等式给出 <span
class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(\{
c_k \}\)</span> 在所属空间的 (能量) 范数等价性: <span
class="math display">\[
\int_{0}^{1} |f(x)|^2 ~\mathrm{d}x = \sum_{k=-\infty}^{\infty} |c_k|^2
\tag{$\bigstar$}
\]</span> 相比 “形式地” 给出的证明, 我更愿意通过计算去解释式 (<span
class="math inline">\(\bigstar\)</span>) 的内涵. 首先, 我们声明,
对任意有限和 <span class="math display">\[
S_N(x) \triangleq \sum_{k=0}^{N} \left( A_k \cos 2\pi k x + B_k \sin
2\pi k x \right),
\tag{3}
\]</span> <strong>Fourier 系数是使得在均值平方意义下 <span
class="math inline">\(S_N(x)\)</span> 对 <span
class="math inline">\(f(x)\)</span> 的最佳估计</strong>. 换句话说, 误差
<span class="math display">\[
E(A_k,B_k) \triangleq \int_0^1 \left( f(x)
- \sum_{k=0}^{N} \left( A_k \cos 2\pi k x + B_k \sin 2\pi k x \right)
\right)^2 \mathrm{d}x
\]</span> 在 <span class="math inline">\(A_k := a_k\)</span>, <span
class="math inline">\(B_k := b_k\)</span> 时取最小值. 例如, 上式对 <span
class="math inline">\(A_k\)</span> 求偏导数得到 <span
class="math display">\[
\begin{aligned}
\frac{\partial E}{ \partial A_k}
&amp;= -2\int_0^1 \left( f(x)
- \sum_{k=0}^{N} \left( A_k \cos 2\pi k x + B_k \sin 2\pi k x \right)
\right) \cos 2\pi k x \mathrm{d}x\\
&amp;= -2\int_0^1 f(x) \cos 2\pi k x ~\mathrm{d}x + A_k
\end{aligned}
\]</span> 令上式等于 0, 也即取极值 (对于正定二次型 <span
class="math inline">\(E\)</span> , 极值点也是最小值点) 条件得到 <span
class="math display">\[
A_k = 2\int_0^1 f(x) \cos 2\pi k x ~\mathrm{d}x = a_k
\]</span> 同样也可以得到 <span class="math display">\[
B_k = 2\int_0^1 f(x) \sin 2\pi k x ~\mathrm{d}x = b_k
\]</span> 如果将 Fourier 级数展开解释为 <span
class="math inline">\(f(x)\)</span> 在正交基上的投影,
那么上面的一切似乎都是顺理成章的. <span
class="math inline">\(f(x)\)</span> 在子空间中的投影点,
也是该子空间中距离 <span class="math inline">\(f(x)\)</span> 最近的点.
如果给出 <span class="math inline">\(f(x)\)</span>
所属空间中的一族规范正交基 <span class="math inline">\(\{ c_k
\}\)</span>, 那么 <span class="math inline">\(f(x)\)</span> 在该空间中的
“长度”, 就等于 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(\{ c_k \}\)</span> 表示下 “坐标” 的平方和,
这也就是 Parseval 等式 (<span class="math inline">\(\bigstar\)</span>).
我们甚至还可以通过这一概念的类比, 直接得到 Bessel 不等式,
也即函数在有限个正交基上的投影长度总是小于原来的长度: <span
class="math display">\[
\int_{0}^{1} |f(x)|^2 ~\mathrm{d}x \geq \sum_{k\in K} |c_k|^2, \quad K
\subseteq \mathbb{Z}
\]</span> 这一切与有限维空间中如此相似的性质, 放到无穷维空间中仍然适用,
是因为<strong>使得我们内积的定义方式 (<span
class="math inline">\(\star\)</span>​) 有意义的函数所属的空间是 Hilbert
空间</strong>. Hilbert 空间, 即使是无穷维的,
也不会丢失掉类似于有限维空间中的长度, 角度和内积性质.</p>
<h2 id="fourier-级数的收敛性">Fourier 级数的收敛性</h2>
<p>定义函数 <span class="math inline">\(f\)</span> 的 Fourier
级数的部分和 <span class="math display">\[
S_N[f](x) \triangleq \sum_{|k| \leq N} c_k e^{i 2\pi kx},
\]</span> 那么, 在什么意义下, 当 <span class="math inline">\(N
\rightarrow \infty\)</span> 时, <span
class="math inline">\(S_N[f]\)</span> 收敛到 <span
class="math inline">\(f\)</span> 呢? 根据 Parseval 等式, 我们知道 <span
class="math display">\[
\int_{0}^{1} |f(x) - S_N[f](x)|^2 ~\mathrm{d}x = \sum_{|k| &gt; N}
|c_k|^2
\]</span> 当 <span class="math inline">\(N \rightarrow \infty\)</span>
时, 根据上式, 函数 <span class="math inline">\(S_N[f]\)</span> 在 <span
class="math inline">\(L_2\)</span> 范数意义下收敛到 <span
class="math inline">\(f\)</span>. 进一步的, 我们还可以给出使得 <span
class="math inline">\(S_N[f]\)</span> 在逐点意义下收敛到 <span
class="math inline">\(f\)</span> 的定理:</p>
<div class="note success no-icon"><p>对于 <span class="math inline">\(f \in L_2(\mathbb{R})\)</span>, 当
<span class="math inline">\(N \rightarrow \infty\)</span> 时, 有 <span
class="math display">\[
S_{N}[f] \rightarrow f, \quad a.e.
\tag{$\spadesuit$}
\]</span></p>
</div>
<p>注意到, 我们给出的 <span class="math inline">\(S_N[f]\)</span>
收敛性是 <strong>almost everywhere</strong> 上的, 如果我们得到点 <span
class="math inline">\(x\)</span> 处的 Fourier
级数不总是收敛到对应的函数值 <span class="math inline">\(f(x)\)</span>,
这并不与式 (<span class="math inline">\(\spadesuit\)</span>) 矛盾.
接下来我们将举例说明, 函数 <span class="math inline">\(f\)</span>
满足定理 <span class="math inline">\(\spadesuit\)</span> 条件,
但在某些点 <span class="math inline">\(x\)</span> 处其 Fourier
级数并不收敛到 <span class="math inline">\(f(x)\)</span>.</p>
<div class="note primary no-icon"><h5 id="例-gibbs-现象">例: Gibbs 现象</h5>
<p>给定在 <span class="math inline">\((0, 2\pi)\)</span> 上的周期函数
<span class="math inline">\(f(x):\mathbb{R} \mapsto \mathbb{R}\)</span>
<span class="math display">\[
f(x) = \frac{\pi - x}{2}, x\in (0, 2\pi)
\]</span> 其 Fourier 级数展开式为 <span class="math display">\[
f(x) \sim \frac{1}{1} \sin x + \frac{1}{2} \sin 2x + \cdots +
\frac{1}{n} \sin nx + \cdots
\]</span> 定义函数 <span class="math inline">\(f\)</span> 的部分和 <span
class="math inline">\(S_N(x):\mathbb{R} \mapsto \mathbb{R}\)</span>
<span class="math display">\[
S_N(x) \triangleq \sum_{k=1}^{N} \frac{1}{k} \sin kx
\]</span> 那么根据定理 <span class="math inline">\(\spadesuit\)</span>,
当 <span class="math inline">\(N\rightarrow \infty\)</span> 时, <span
class="math inline">\(S_N \rightarrow f, a.e.\)</span>
但接下来我们将证明, <strong>当 <span class="math inline">\(N\rightarrow
\infty\)</span> 时, 在区间 <span class="math inline">\((0,
\frac{\pi}{N})\)</span> 上函数 <span
class="math inline">\(S_{N}\)</span> 的最大值并不收敛到 <span
class="math inline">\(f\)</span> 的最大值, 也即 <span
class="math inline">\(\frac{\pi}{2}\)</span>​.</strong></p>
<p>首先, 函数 <span class="math inline">\(S_N\)</span>
的导函数是可以得到一个紧凑的表达式的: <span class="math display">\[
S_N^{\prime}(x) = \frac{\sin \left(\frac{Nx}{2}\right) }{\sin
\left(\frac{x}{2}\right) }
\cos \left( \frac{N+1}{2}x \right)
\]</span> 由此可以得到, 当 <span class="math inline">\(x =
\frac{\pi}{N+1}\)</span> 时, 函数 <span
class="math inline">\(S_N\)</span> 在 <span class="math inline">\((0,
\frac{\pi}{N})\)</span> 取到最大值, 所以 <span class="math display">\[
\max_{x\in(0,\frac{\pi}{N})} S_N(x) = S_N(\frac{\pi}{N+1})
= \sum_{k=1}^{N} \frac{1}{k} \sin \frac{k\pi}{N+1}
\]</span> 如果记 <span class="math display">\[
\frac{k\pi}{N+1} \doteq t_k, \quad
\frac{\pi}{N+1}  \doteq \Delta t
\]</span> 那么 <span class="math display">\[
\max_{x\in(0,\frac{\pi}{N})} S_N(x)
= \sum_{k=1}^{N} \frac{\sin t_k}{t_k} \Delta t
\]</span> 当 <span class="math inline">\(N \rightarrow \infty\)</span>
时, 上式趋近于积分 <span class="math display">\[
\max_{x\in(0,\frac{\pi}{N})} S_N(x) \rightarrow \int_{0}^{\pi}
\frac{\sin t}{t} ~\mathrm{d}t
\approx 1.85194
\]</span> 这与函数 <span class="math inline">\(f\)</span>
最大值的相对误差为 <span class="math display">\[
\mathrm{error} = \frac{|\int_{0}^{\pi} \frac{\sin t}{t} -
\frac{\pi}{2}|}{\frac{\pi}{2}}
\approx 0.17898
\]</span> 将 <span class="math inline">\(N=3,4,5,10,20\)</span>
的部分和函数 <span class="math inline">\(S_N\)</span> 绘图,
如下图所示</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202405051052718Gibbs.png" alt="image-20240505105212544" style="zoom:80%;" /></p>
</div>
<h2 id="riemann-lebesgue-引理">Riemann-Lebesgue 引理</h2>
<p>接下来, 我们希望建立起一个对 <span class="math inline">\(c_k\)</span>
与 <span class="math inline">\(f\)</span> 光滑性联系的印象:
<strong><span class="math inline">\(f\)</span> 越光滑, <span
class="math inline">\(c_k\)</span> 收敛到 0 的速度就越快.</strong></p>
<p>首先, 我们可以通过定义得到关于 <span
class="math inline">\(c_k\)</span> 最粗糙的估计: <span
class="math display">\[
|c_k| \leq \int_{0}^{1} |f(x)| ~\mathrm{d}x, \quad \forall k \in
\mathbb{Z}
\]</span> 接下来将要说明的是, <strong>当 <span class="math inline">\(|k|
\rightarrow \infty\)</span> 时, <span class="math inline">\(c_k
\rightarrow 0\)</span></strong>. 这一结论由 Riemann-Lebesgue
引理给出:</p>
<div class="note success no-icon"><h5 id="riemann-lebesgue-引理-级数形式">Riemann-Lebesgue 引理
(级数形式)</h5>
<p>若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\((0,1)\)</span> 上可积, 那么当 <span
class="math inline">\(|k| \rightarrow \infty\)</span> 时, <span
class="math display">\[
c_k \rightarrow 0.
\]</span></p>
</div>
<p>我们可以通过构造如下列式来证明这一引理. 若 <span
class="math inline">\(f(x)\)</span> 偏移 <span
class="math inline">\(x_0\)</span>, 对应的 Fourier 级数系数 <span
class="math inline">\(c_k^{\prime}\)</span> 为: <span
class="math display">\[
c_k^{\prime} = \int_{0}^{1} f(x+x_0) e^{-i 2\pi kx} ~\mathrm{d}x
\stackrel{y\doteq x+x_0}{=} \int_{0}^{1} f(y) e^{-i 2\pi k (y-x_0)}
~\mathrm{d}x
= e^{i 2\pi k x_0} c_k
\]</span></p>
<p>若 <span class="math inline">\(x_0 := \frac{1}{2k}\)</span>, 那么
<span class="math inline">\(c_k^{\prime} = -c_k\)</span>, 所以 <span
class="math display">\[
c_k = \frac{c_k - c_k^{\prime}}{2}
= \frac{1}{2} \int_{0}^{1} \left( f(x)-f(x+\frac{1}{2k}) \right) e^{-i
2\pi kx} ~\mathrm{d}x
\tag{$\clubsuit$}
\]</span> 由上式可以看到, 如果函数 <span
class="math inline">\(f\)</span> <strong>连续</strong>, 那么当 <span
class="math inline">\(|k| \rightarrow \infty\)</span> 时, <span
class="math inline">\(c_k \rightarrow 0\)</span>.
对于一般的<strong>可积函数</strong> <span
class="math inline">\(f\)</span>, 给定 <span
class="math inline">\(\varepsilon &gt; 0\)</span>,
总可以确定某一个连续函数 <span class="math inline">\(g\)</span>, 使得
<span class="math display">\[
\int_{0}^{1} |f(x) - g(x)| ~\mathrm{d}x &lt; \frac{\varepsilon}{2}
\]</span> 以及某一个 <span class="math inline">\(N\)</span>, 使得当
<span class="math inline">\(|k| &gt; N\)</span> 时, <span
class="math inline">\(c_k(g) &lt; \frac{\varepsilon}{2}\)</span>,
由此我们得到 <span class="math display">\[
|c_k(f)| \leq |c_k(f) - c_k(g)| + |c_k(g)|
\leq \int_{0}^{1} |f(x) - g(x)| ~\mathrm{d}x + \frac{\varepsilon}{2}
\leq \varepsilon
\]</span> 这就证明了 Riemann-Lebesgue 引理. <span
class="math inline">\(\blacksquare\)</span></p>
<p>再然后, 我们希望在知道函数 <span class="math inline">\(f\)</span>
光滑性的信息之后, <strong>能够对 <span
class="math inline">\(c_k\)</span> 收敛到 0 的速度有一个估计</strong>.
如果函数 <span class="math inline">\(f \in C^1(\mathbb{R})\)</span>,
那么通过下面简单的计算可以得到系数 <span
class="math inline">\(c_k\)</span> 的收敛速度为 <span
class="math inline">\(\mathcal{O}(\frac{1}{|k|})\)</span> : <span
class="math display">\[
\begin{aligned}
c_k &amp;= \int_{0}^{1} f(x) e^{-i 2\pi k x} ~\mathrm{d}x
= \frac{1}{-i 2\pi k} \int_{0}^{1} f(x) ~\mathrm{d}e^{-i 2\pi k x} \\
&amp;= \frac{1}{i 2\pi k} \int_{0}^{1} e^{-i 2\pi k x} ~\mathrm{d}f(x)
+ \underbrace{\left. \frac{1}{-i 2\pi k} f(x) e^{-i 2\pi k
x}\right\vert_{0}^{1}}_{=0} \\
&amp;= \frac{1}{i 2\pi k} \int_{0}^{1} e^{-i 2\pi k x} f&#39;(x)
~\mathrm{d}x
\sim \mathcal{O}(\frac{1}{|k|})
\end{aligned}
\]</span> 如果函数 <span class="math inline">\(f\)</span>
具有更高阶的光滑性, 那么 <span class="math display">\[
c_k =  \frac{1}{i 2\pi k} \int_{0}^{1} e^{-i 2\pi k x}
f&#39;(x)  ~\mathrm{d} x
= \frac{1}{(i 2\pi k)^2}  \int_{0}^{1} e^{-i 2\pi k x} f&#39;&#39;(x)
~\mathrm{d} x
= \cdots
\]</span> 如果函数 <span class="math inline">\(f\)</span> 是 Lipschitz
连续的, 也即 <span class="math display">\[
|f(x) - f(y)| \leq \mathrm{Lip}(f) |x-y|, \quad \forall x,y \in
\mathbb{R}
\]</span> 那么代入式 (<span class="math inline">\(\clubsuit\)</span>)
中得到 <span class="math display">\[
|c_k| \leq \frac{\mathrm{Lip}(f)}{4 |k|}
\]</span> Fourier 变换的 Riemann-Lebesgue 引理为</p>
<div class="note success no-icon"><h5 id="riemann-lebesgue-引理-变换形式">Riemann-Lebesgue 引理
(变换形式)</h5>
<p>若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(\mathbb{R}\)</span> 上可积, 那么当 <span
class="math inline">\(\xi \rightarrow \infty\)</span> 时, <span
class="math display">\[
\widehat f(\xi) = \int_{\mathbb{R}} f(x) e^{i 2 \pi \xi x} ~\mathrm{d}x
\rightarrow 0.
\]</span></p>
</div>
<blockquote>
<p>[!NOTE]</p>
<p>从 Riemann-Lebesgue 引理中可以直接得到以下结论:</p>
<p>若函数 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(\mathbb{R}\)</span> 上可积, 那么 <span
class="math display">\[
\int_{\mathbb{R}} f(x) \cos(tx) ~\mathrm{d}x \rightarrow 0, ~
\int_{\mathbb{R}} f(x) \sin(tx) ~\mathrm{d}x \rightarrow 0, ~
~when~ t \rightarrow \infty
\]</span></p>
</blockquote>
]]></content>
      <categories>
        <category>Fourier 分析</category>
      </categories>
      <tags>
        <tag>Parseval 等式</tag>
        <tag>Fourier 级数的收敛性</tag>
        <tag>Gibbs 现象</tag>
        <tag>Riemann-Lebesgue 引理</tag>
      </tags>
  </entry>
  <entry>
    <title>Fourier 级数的三角系数与指数系数转换关系</title>
    <url>/math/Fourier-analysis/Fourier-%E7%BA%A7%E6%95%B0%E7%9A%84%E4%B8%89%E8%A7%92%E7%B3%BB%E6%95%B0%E4%B8%8E%E6%8C%87%E6%95%B0%E7%B3%BB%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>对于 <span class="math inline">\([0,1]\)</span> 上的周期函数 <span
class="math inline">\(f(x)\)</span>, 并延拓到整个 <span
class="math inline">\(\mathbb{R}\)</span> 上, <span
class="math inline">\(f(x)\)</span>​ 的 Fourier 级数表示为 <span
class="math display">\[
f(x) \sim \frac{a_0}{2} + \sum_{k=1}^{\infty} a_k \cos 2\pi k x
+ \sum_{k=1}^{\infty} b_k \sin 2\pi k x
\tag{1}
\]</span> 根据三角函数基的正交性 (正交性在文末证明): <span
class="math display">\[
\int_{0}^{1} \cos 2\pi k x \cos 2\pi m x ~\mathrm{d} x
= \begin{cases}
0,           \quad &amp;k \neq m \\
\frac{1}{2}, \quad &amp;k = m \\
\end{cases}
\]</span> ( 三角函数基虽然正交, 但不是规范正交的! )
<span id="more"></span>可以确定由式 (1) 表示的 Fourier 级数系数为 <span
class="math display">\[
\begin{aligned}
a_k &amp;= 2 \int_{0}^{1} f(x) \cos 2\pi k x ~\mathrm{d}x, \quad
k=0,1,2,\ldots\\
b_k &amp;= 2 \int_{0}^{1} f(x) \sin 2\pi k x ~\mathrm{d}x, \quad
k=1,2,\ldots
\end{aligned}
\tag{2}
\]</span> 如果我们选用指数函数基底表示 <span
class="math inline">\(f(x)\)</span>: <span class="math display">\[
f(x) \sim \sum_{k=-\infty}^{\infty} c_k e^{i 2\pi k x},
\tag{3}
\]</span> 那么根据指数函数基底的规范正交性, 可以得到 <span
class="math display">\[
c_k = \langle f(x), e^{i 2\pi k x} \rangle = \int_{0}^{1} f(x) e^{-i
2\pi k x} ~\mathrm{d}x
\tag{4}
\]</span> 接下来, 我们希望得到 (1) (3) Fourier 级数表示系数之间的关系,
我们将式 (4) 积分项中的 <span class="math inline">\(e^{-i2\pi k
x}\)</span> 展开得到 <span class="math display">\[
\begin{aligned}
c_k
=  \int_{0}^{1} f(x) \cos{2\pi k x} ~\mathrm{d}x
- i\int_{0}^{1} f(x) \sin{2\pi k x} ~\mathrm{d}x \\
c_{-k}
=  \int_{0}^{1} f(x) \cos{2\pi k x} ~\mathrm{d}x
+ i\int_{0}^{1} f(x) \sin{2\pi k x} ~\mathrm{d}x
\end{aligned}
\]</span> 再根据 (2) 式给出的 <span class="math inline">\(a_k\)</span>,
<span class="math inline">\(b_k\)</span> 表达式可以得到 <span
class="math display">\[
\begin{gathered}
a_k= c_k + c_{-k}, \quad b_k = i(c_k - c_{-k}), \quad k=1,2,\ldots \\
a_0 = c_0
\end{gathered}
\]</span></p>
<p>此外, 我们还可以看到 <span class="math display">\[
c_{-k} = \overline{c}_{k}
\]</span> <div class="note info no-icon"><h5 id="remark">Remark</h5>
<ol type="1">
<li>式 (1) 中常数项含分数是因为, 如果我们将 Fourier 级数表示为</li>
</ol>
<p><span class="math display">\[
f(x) \sim a_0^{\prime} + \sum_{k=1}^{\infty} a_k \cos 2\pi k x
+ \sum_{k=1}^{\infty} b_k \sin 2\pi k x,
\tag{1$^\prime$}
\]</span></p>
<p>那么 <span class="math display">\[
a_{0}^{\prime} = \int_{0}^{1} f(x) ~\mathrm{d}x,
\]</span> 而公式 (2) 中 <span class="math inline">\(a_0\)</span> <span
class="math display">\[
a_0 = 2\int_{0}^{1} f(x) ~\mathrm{d}x = 2a_{0}^{\prime}
\]</span></p>
<ol start="2" type="1">
<li>对于周期为 <span class="math inline">\(L\)</span> 的函数 <span
class="math inline">\(f(x)\)</span>, 其 Fourier 级数的表达式为</li>
</ol>
<p><span class="math display">\[
f(x) \sim \frac{a_0}{2} + \sum_{k=1}^{\infty} a_k \cos \frac{2\pi}{L} k
x
+ \sum_{k=1}^{\infty} b_k \sin \frac{2k\pi}{L} x
\tag{1$&#39;&#39;$}
\]</span></p>
<p>或者 <span class="math display">\[
f(x) \sim \sum_{k=-\infty}^{\infty} c_k e^{i \frac{2\pi}{L} k x},
\tag{3$&#39;&#39;$}
\]</span> 同样也可以用三角函数基 <span class="math inline">\(\{ \cos
\frac{2\pi}{L} k x \}\)</span>, <span class="math inline">\(\{ \sin
\frac{2\pi}{L} k x \}\)</span> 和指数函数基 <span
class="math inline">\(\{ e^{i \frac{2\pi}{L} k x} \}\)</span> 的内积得到
Fourier 系数的表达式为 <span class="math display">\[
\begin{aligned}
a_k &amp;= \frac{2}{L} \int_{0}^{L} f(x) \cos \frac{2\pi}{L} k x
~\mathrm{d}x, \quad k=0,1,2,\ldots\\
b_k &amp;= \frac{2}{L} \int_{0}^{L} f(x) \sin \frac{2\pi}{L} k x
~\mathrm{d}x, \quad k=1,2,\ldots
\end{aligned}
\tag{2$&#39;&#39;$}
\]</span> 和 <span class="math display">\[
c_k = \frac{1}{L} \int_{0}^{L} f(x) e^{-i \frac{2\pi}{L} k x}
~\mathrm{d}x
\tag{4$&#39;&#39;$}
\]</span> 另一个思路是积分变换, 我们以指数函数基为例. 对于周期为 <span
class="math inline">\(L\)</span> 的函数 <span
class="math inline">\(f(x)\)</span>, 函数 <span
class="math inline">\(F(y) := f(Ly)\)</span> 的周期为 <span
class="math inline">\(1\)</span> , 根据式 (3) <span
class="math display">\[
F(y) \sim \sum_{k=-\infty}^{\infty} c_k e^{i 2\pi k y}
\]</span> 以及系数 <span class="math inline">\(c_k\)</span> 为 <span
class="math display">\[
c_k = \int_{0}^{1} F(y) e^{-i 2\pi k y} ~\mathrm{d}y
= \int_{0}^{1} f(Ly) e^{-i 2\pi k y} ~\mathrm{d}y
\]</span> 作变量替换 <span class="math inline">\(x == Ly\)</span>, 也即
<span class="math inline">\(y==\frac{x}{L}\)</span>, 所以 <span
class="math display">\[
f(x) \sim \sum_{k=-\infty}^{\infty} c_k e^{i \frac{2\pi}{L} k x}
\]</span> 其 Fourier 系数为 <span class="math display">\[
c_k = \int_{0}^{L} F(y) e^{-i 2\pi k \frac{x}{L}}
\frac{1}{L}~\mathrm{d}x
= \frac{1}{L} \int_{0}^{L} F(y) e^{-i \frac{2\pi}{L} k x} ~\mathrm{d}x
\]</span></p>
</div></p>
<h2
id="三角函数基与指数函数基的正交性证明">三角函数基与指数函数基的正交性证明</h2>
<p>首先, 周期为 <span class="math inline">\(L\)</span> 的函数 <span
class="math inline">\(f(x),g(x): \mathbb{R} \mapsto \mathbb{C}\)</span>
的内积定义为 <span class="math display">\[
\langle f(x), g(x) \rangle \triangleq \frac{1}{L} \int_0^{L} f(x)
\overline{g(x)} ~\mathrm{d}x
\tag{$\star$}
\]</span> 注意到这种内积的定义<strong>并不是唯一的</strong>, 但是, 按照
(<span class="math inline">\(\star\)</span>) 的定义, 指数函数基 <span
class="math inline">\(\{ e^{i \frac{2\pi}{L} kx} \}\)</span>
总是规范正交基: <span class="math display">\[
\langle e^{i \frac{2\pi}{L} k x}, e^{i \frac{2\pi}{L} m x} \rangle
= \frac{1}{L} \int_{0}^{L} e^{i \frac{2\pi}{L} k x} e^{-i \frac{2\pi}{L}
m x} ~\mathrm{d}x
=\begin{cases}
\frac{L}{i2\pi(k-m)} \left( e^{i \frac{2\pi}{L} (k-m)} -1 \right) \equiv
0, \quad &amp;k \neq m \\
1, &amp;k = m
\end{cases}
\]</span> 三角函数基 <span class="math inline">\(\{ \cos \frac{2\pi}{L}
kx \}\)</span>, <span class="math inline">\(\{ \sin \frac{2\pi}{L} kx
\}\)</span>的正交性的证明可以通过积化和差公式: <span
class="math display">\[
\begin{aligned}
\cos \frac{2\pi}{L} k x \cos 2m\pi x &amp;= \frac{1}{2} \left( \cos
\frac{2\pi}{L} (k-m) x + \cos \frac{2\pi}{L} (k+m) x \right) \\
\sin \frac{2\pi}{L} k x \sin 2m\pi x &amp;= \frac{1}{2} \left( \cos
\frac{2\pi}{L} (k-m) x - \cos \frac{2\pi}{L} (k+m) x \right)
\end{aligned}
\]</span> 当 <span class="math inline">\(k\neq m\)</span> 时,
上式右侧积分总等于 0, 所以 <span class="math display">\[
\begin{aligned}
\langle \cos{\frac{2\pi}{L} k x}, \cos{\frac{2\pi}{L} m x} \rangle
&amp;= 0, \quad k\neq m\\
\langle \sin{\frac{2\pi}{L} k x}, \sin{\frac{2\pi}{L} m x} \rangle
&amp;= 0, \quad k\neq m
\end{aligned}
\]</span> 只有当 <span class="math inline">\(k=m\)</span> 时, <span
class="math display">\[
\begin{aligned}
\langle \cos{\frac{2\pi}{L} k x}, \cos{\frac{2\pi}{L} k x} \rangle
= \frac{1}{L} \int_{0}^{L} \cos^2 \frac{2\pi}{L} k x ~\mathrm{d}x =
\frac{1}{2}, \quad
\langle \sin{\frac{2\pi}{L} k x}, \sin{\frac{2\pi}{L} k x} \rangle
= \frac{1}{L} \int_{0}^{L} \sin^2 \frac{2\pi}{L} k x ~\mathrm{d}x =
\frac{1}{2}
\end{aligned}
\]</span> 三角函数基 <span class="math inline">\(\{ \cos \frac{2\pi}{L}
kx \}\)</span>, <span class="math inline">\(\{ \sin \frac{2\pi}{L} kx
\}\)</span>之间总是正交的, 这是因为 <span class="math display">\[
\sin \frac{2\pi}{L} k x \cos \frac{2\pi}{L} m x = \frac{1}{2} \left(
\sin \frac{2\pi}{L}(k+m)x + \sin \frac{2\pi}{L}(k-m)x \right)
\]</span> 因此, 对任意的 <span class="math inline">\(k\)</span>, <span
class="math inline">\(m\)</span>, <span class="math display">\[
\langle \sin{\frac{2\pi}{L} k x}, \cos{\frac{2\pi}{L} m x} \rangle
= \frac{1}{L} \int_{0}^{L}\sin \frac{2\pi}{L} k x \cos \frac{2\pi}{L} m
x ~\mathrm{d}x \equiv 0
\]</span></p>
]]></content>
      <categories>
        <category>Fourier 分析</category>
      </categories>
      <tags>
        <tag>Fourier 系数</tag>
        <tag>正交函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Gaussian 函数的 Fourier 变换与逆变换</title>
    <url>/math/Fourier-analysis/Gauss-%E5%87%BD%E6%95%B0%E7%9A%84-Fourier-%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%86%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>首先, 我们来考虑一维情景下 Gauss 函数在 <span
class="math inline">\(\mathbb{R}\)</span> 上的积分: <span
class="math display">\[
I = \int_{-\infty}^{\infty} e^{-\pi x^2} \mathrm{d}x
\tag{1}
\]</span> 这可以通过 “升一维” (replica trick) 的办法去做: <span
class="math display">\[
I^2 = \int_{-\infty}^{\infty} e^{-\pi x^2} \mathrm{d}x
\int_{-\infty}^{\infty} e^{-\pi y^2} \mathrm{d}y
= \iint_{\mathbb{R}^2} e^{-\pi (x^2 + y^2)} \mathrm{d}x\mathrm{d}y
\]</span> 变换到极坐标系中, 得到 <span class="math display">\[
x^2 + y^2 = r^2, \quad \mathrm{d}x\mathrm{d}y =
r\mathrm{d}r\mathrm{d}\theta
\]</span> 所以 <span class="math display">\[
I^2 = \int_{0}^{2\pi} \mathrm{d}\theta \int_{0}^{\infty} e^{-\pi r^2}
r\mathrm{d}r = 10
\]</span></p>
<span id="more"></span>
<blockquote>
<p>[!TIP]</p>
<p>一个有意思的结论是, 上述的 replica trick 可以应用函数的范围是有限的
(<em>Poisson’s remarkable calculation – a method or a trick?</em>).
如果函数 <span class="math inline">\(f:\mathbb{R} \mapsto
\mathbb{R}\)</span> 满足如下泛函: <span class="math display">\[
f(x) f(y) = g(x^2 + y^2) h(y/x)
\]</span> 并且待选取的函数集合是基本函数, 那么函数 <span
class="math inline">\(f\)</span> 的形式只能是关于 <span
class="math inline">\(x\)</span> 的幂函数和 <span
class="math inline">\(e^{x^2}\)</span> 的乘积: <span
class="math display">\[
f(x) = A x^p e^{x^2}
\]</span></p>
</blockquote>
<p>接下来, 我们考虑一维情景 Gauss 函数的 Fourier 变换: <span
class="math display">\[
\widehat{e^{-\pi x^2}}  = \int_{\mathbb{R}} e^{-\pi x^2} e^{-i 2\pi \xi
x} ~\mathrm{d}x
\tag{2}
\]</span></p>
<p>最直接的方法是使用换元, <span class="math display">\[
\int_{\mathbb{R}}  e^{-\pi(x^2 + 2i\xi x)} ~\mathrm{d}x
= e^{ -\pi\xi^2} \int_{\mathbb{R}}  e^{-\pi(x + i\xi)^2} ~\mathrm{d}x
= e^{ -\pi\xi^2} \int_{L}  e^{-z^2} ~\mathrm{d}z, \quad L =
line(-\infty+i\xi, +\infty + i\xi)
\]</span> 构造积分回路 <span class="math inline">\((-a+i\xi, a + i\xi,
a, -a)\)</span>, 可以证明当 <span class="math inline">\(a \rightarrow
\infty\)</span> 时, 在 <span class="math inline">\((a, a+i\xi)\)</span>
, <span class="math inline">\((-a, -a + i\xi)\)</span> 上的积分等于 0,
所以 <span class="math display">\[
\int_{L}  e^{-z^2} ~\mathrm{d}z = \int_{-\infty}^{\infty} e^{-\pi x^2}
\mathrm{d}x = 1
\]</span> 最终得到 <span class="math display">\[
\widehat{e^{-\pi x^2}} = e^{-\pi \xi^2}
\]</span></p>
<p>还有一种方式是使用分部积分, 得到关于 <span
class="math inline">\(\widehat{e^{-\pi x^2}}\)</span> 的微分方程.
引入新的函数记号 <span class="math inline">\(F(\xi) \triangleq
\widehat{e^{-\pi x^2}}\)</span>, 再对式 (2) 两边分别关于 <span
class="math inline">\(\xi\)</span> 求导数: <span class="math display">\[
\begin{aligned}
F&#39;(\xi) &amp;= \int_{\mathbb{R}} -i2\pi x e^{-\pi x^2} e^{- i 2\pi
\xi x} ~\mathrm{d}x
= \int_{\mathbb{R}} i  e^{- i 2\pi \xi x} ~\mathrm{d}e^{-\pi x^2} \\
&amp;= - \int_{\mathbb{R}} i e^{-\pi x^2} ~\mathrm{d}e^{- i 2\pi \xi x}
+ \underbrace{i e^{- i 2\pi \xi x} e^{-\pi
x^2}|_{-\infty}^{+\infty}}_{=0}\\
&amp;= -2\pi\xi F(\xi)
\end{aligned}
\]</span> 求解上述微分方程得到 <span class="math display">\[
F(\xi) = F(0) e^{-\pi\xi^2}
\]</span> 又因为 <span class="math inline">\(F(0) = I \equiv 1\)</span>,
所以 <span class="math inline">\(\widehat{e^{-\pi x^2}} = e^{-\pi
\xi^2}\)</span>.</p>
<p>高维情境下的 Gaussian 函数的 Fourier
变换可以根据指数的性质自然分解为一维 Fourier 变换的乘积: <span
class="math display">\[
\widehat{e^{-\pi |x|^2}} = \int_{\mathbb{R}^d} e^{-\pi \sum x_i}
e^{-i2\pi \xi \cdot x} ~\mathrm{d}x
= \sum_{i=1}^{d} \int_{\mathbb{R}} e^{-\pi x_i^2} e^{-2\pi \xi_i x_i}
~\mathrm{d} x_i
= e^{-\pi|\xi|^2}
\]</span> Gaussian 函数的逆变换可以通过 Fourier 逆定理,
也可以通过将上述证明中的 <span class="math inline">\(i\)</span> 替换为
<span class="math inline">\(-i\)</span>, 结论是不变的: <span
class="math display">\[
( e^{-\pi|\xi|^2}   )^{\vee} = e^{-\pi |x|^2}
\]</span> 当 Gaussian 函数中含有因子时, 其 Fourier 变换为 <span
class="math display">\[
(e^{-\lambda \pi |x|^2})^{\wedge} = \lambda^{-d/2} e^{ - \pi
|\xi|^2/\lambda}
\]</span> 对应的 Fourier 逆变换为 <strong>(形式上完全一样)</strong>
<span class="math display">\[
(e^{-\lambda \pi |\xi|^2})^{\vee} = \lambda^{-d/2} e^{-\pi |x|^2 /
\lambda}
\]</span> 如果函数 <span class="math inline">\(f\)</span> 是 <span
class="math inline">\(\alpha-\)</span>​ 齐次的, 也即 <span
class="math display">\[
f(\lambda x) = \lambda^{\alpha} f(x)
\]</span> 线性函数 <span class="math inline">\(\alpha = 1\)</span>;
幂函数 <span class="math inline">\(x^p\)</span> <span
class="math inline">\(\alpha = p\)</span>; Gaussian 函数是径向对称函数,
但不是齐次函数.</p>
]]></content>
      <categories>
        <category>Fourier 分析</category>
      </categories>
      <tags>
        <tag>Gaussian 函数</tag>
        <tag>积分技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>离散 Fourier 级数</title>
    <url>/math/Fourier-analysis/%E7%A6%BB%E6%95%A3-Fourier-%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<p>连续的Fourier 级数将 <span class="math inline">\(L_2([0,2
\pi])\)</span> 空间中函数 <span class="math inline">\(f\)</span> 与
<span class="math inline">\(l_2\)</span> 空间中的 Fourier 系数 <span
class="math inline">\(c_k\)</span> 关联起来: <span
class="math display">\[
f(x) = \sum_{k \in \mathbb{Z}} c_k e^{i kx}, \quad
c_k  = \frac{1}{2 \pi} \int_{0}^{2 \pi} f(x) e^{-i kx} \mathrm{d} x
\]</span></p>
<p>对于离散情景, 如果已知函数 <span class="math inline">\(f\)</span> 在
<span class="math inline">\([0, 2\pi]\)</span> 上 <span
class="math inline">\(n\)</span> 个点处的取值 <span
class="math inline">\(f_0, f_1, \dots,f_{n-1}\)</span>, 那么,
是否存在一个映射关系 <span class="math inline">\(F: \mathbb{R}^n \mapsto
\mathbb{R}^n\)</span>, 得到对应的 Fourier 级数系数 <span
class="math inline">\(c_0, c_1, \dots,c_{n-1}\)</span> 呢? 这就是离散的
Fourier 变换. <span id="more"></span></p>
<div class="note primary no-icon"><h5 id="例-离散的-fourier-变换">例: 离散的 Fourier 变换</h5>
<p>已知函数 <span class="math inline">\(f\)</span> 在点 <span
class="math inline">\(0, \pi/2, \pi, 3\pi/2\)</span> 上取值分别为 <span
class="math inline">\(1,2,3,4\)</span>, 如果使用 Fourier 级数的前 4
项和作为函数 <span class="math inline">\(f\)</span> 的近似: <span
class="math display">\[
\tilde f(x) \triangleq c_0 + c_1 e^{ix} + c_2 e^{i2x} + c_3 e^{i3x}
\]</span> 并令函数 <span class="math inline">\(\tilde f\)</span>
在对应点处与函数 <span class="math inline">\(f\)</span> 取值相同,
那么就得到关于系数 <span class="math inline">\(c_k, k=1,2,3,4\)</span>
的四个方程: <span class="math display">\[
\begin{aligned}
c_0+c_1+c_2+c_3=2 \\
c_0+i c_1-c_2-i c_3=4 \\
c_0-c_1+c_2-c_3=6 \\
c_0-i c_1-c_2+i c_3=8
\end{aligned}
\]</span> 求解上述方程, 得到 <span class="math display">\[
c_0 = 5, \quad
c_1 = -1+i, \quad
c_2 = -1, \quad
c_3 = -1-i
\]</span> 注意到 <span class="math inline">\(c_0 = \mathrm{avg}~ f_i =
\left( \sum_{i=0}^{3} f_i \right) / 4\)</span>, 这恰好与连续 Fourier
级数计算常数项系数的公式 <span class="math display">\[
c_0 = \frac{1}{L} \int_{0}^{L} f(x) ~\mathrm{d}x
\]</span> 相仿!</p>
</div>
<p>因为 Fourier 变换是<strong>线性</strong>的, 对于 <span
class="math inline">\(\mathbb{R}^n \mapsto \mathbb{R}^n\)</span>
上的线性映射, 总可以找到一个 <span class="math inline">\(n \times
n\)</span> 的矩阵来表示. 我们约定在区间 <span
class="math inline">\([0,2\pi]\)</span> 上均匀分布的点集 <span
class="math inline">\(x_k = 2\pi k/n\)</span> 处采集函数 <span
class="math inline">\(f\)</span> 的数值 <span class="math inline">\(f_0,
f_1, \dots, f_{n-1}\)</span>. 为方便表示之后得到的矩阵 <span
class="math inline">\(F\)</span>, 定义如下复数 <span
class="math inline">\(w\)</span>: <span class="math display">\[
w \triangleq e^{i 2 \pi/n}
\]</span> 注意到 <span class="math inline">\(w^n = 1\)</span>, 是 <span
class="math inline">\(1\)</span> 的一个 <span
class="math inline">\(n\)</span> 次根. 近似函数取为 Fourier 级数的前
<span class="math inline">\(n\)</span> 项和 <span
class="math display">\[
\tilde f(x) = \sum_{k=0}^{n-1} c_k e^{i k x},
\]</span> 令 <span class="math inline">\(\tilde f(x_k) = f_k,~
k=0,1,\dots,n-1\)</span>, 就得到关于系数 <span
class="math inline">\(c_k\)</span> 的 <span
class="math inline">\(n\)</span> 个方程: <span class="math display">\[
\begin{aligned}
  c_0 + c_1 + \cdots + c_k + \cdots + c_{n-1} = f_0, \\
  c_0 + c_1 w + \cdots + c_k w^k + \cdots + c_{n-1} w^{n-1} = f_0, \\
  c_0 + c_1 w^2 + \cdots + c_k w^{2k} + \cdots + c_{n-1} w^{2(n-1)} =
f_0, \\
  \cdots
\end{aligned}
\]</span> 定义离散 Fourier 变换矩阵 <span
class="math inline">\(F\)</span> <span class="math display">\[
F_{jk} \triangleq w^{jk},\quad j,k=0,1,2,\ldots,n-1
\]</span> (注意矩阵的下标是<strong>从 0 开始索引</strong>的),
这样就可以得到方程 <span class="math display">\[
F_{jk} c_k = f_j,\quad j=0,1,2,\ldots,n-1
\]</span> <div class="note success no-icon"><p>Fourier 变换矩阵最重要的性质是, 如果我们记 <span
class="math inline">\(\overline{w} \triangleq e^{-i 2\pi/n}\)</span>,
以及 <span class="math inline">\(\overline F_{jk} \triangleq \overline
w^{jk}\)</span>, 那么矩阵 <span class="math inline">\(F\)</span>
的逆可以通过矩阵 <span class="math inline">\(\overline F\)</span> 表示为
<span class="math display">\[
(F)^{-1} = \frac{1}{n} \overline F, \quad \text{或者} \quad
F \overline F = \overline F F = nI
\tag{1}
\]</span> 证明过程也很整洁, 矩阵的乘法通过分量可以表示为等比数列之和:
<span class="math display">\[
\begin{aligned}
  (F \overline F)_{jl} &amp;= F_{jk} \overline F_{kl} = e^{i 2\pi jk/n}
e^{-i 2\pi kl/n}
  = \sum_{k=0}^{n-1} \left( e^{i 2\pi (j-l)/n} \right)^k \\
  &amp;= \begin{cases}
    \dfrac{1 - r^n}{1 - r},\quad j \neq l \\
    n,\quad j=l
  \end{cases}
\end{aligned}
\]</span> 式中, <span class="math inline">\(r \triangleq e^{i 2\pi
(j-l)/n}\)</span>, 而当 <span class="math inline">\(j \neq l\)</span>
时, <span class="math inline">\(r^n\)</span> 恒等于 0: <span
class="math display">\[
r^n = e^{i 2\pi (j-l)} \equiv 1,\quad j \neq l
\]</span> 由此得到式 (1) 中的结论.</p>
</div></p>
<p>根据式 (1) 中的结论, 物理空间中的数据点 <span
class="math inline">\(\{f_k\}\)</span> 与相空间中的数据点 <span
class="math inline">\(\{c_k\}\)</span> 之间的关联为 <span
class="math display">\[
F_{jk} c_k = f_j, \quad
\frac{1}{n} \overline F_{jk} f_k = c_j
\]</span></p>
<p>或者写成 <span class="math display">\[
f_j = c_k w^{jk}, \quad
c_j = \frac{1}{n}  f_k w^{-jk}
\]</span></p>
]]></content>
      <categories>
        <category>Fourier 分析</category>
      </categories>
      <tags>
        <tag>函数拟合</tag>
        <tag>Fourier 变换矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>离散卷积定理</title>
    <url>/math/Fourier-analysis/%E7%A6%BB%E6%95%A3%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>首先, 定义两种向量之间的运算: 乘积 <span class="math inline">\(f
\circ g\)</span> 和卷积 <span class="math inline">\(f*g\)</span>:</p>
<p>向量 <span class="math inline">\(f,g\)</span> 之间的乘积计算 <span
class="math inline">\(f \circ g: \mathbb{R}^n \times \mathbb{R}^n
\mapsto \mathbb{R}^n\)</span> 定义为 <span class="math display">\[
(f \circ g)_k \triangleq f_k g_k, \quad k = 0,1,\ldots,n-1
\]</span> 向量 <span class="math inline">\(f,g\)</span> 之间的卷积计算
<span class="math inline">\(f*g: \mathbb{R}^n \times \mathbb{R}^n
\mapsto \mathbb{R}^n\)</span> 定义为 <span class="math display">\[
(f*g)_k \triangleq \sum_{i=0}^{n-1} f_i g_{k-i}, \quad k =
0,1,\ldots,n-1
\]</span> 我在这篇文章中希望说明的是, 向量的 乘积/卷积 运算,
总是可以通过 卷积/乘积 运算得到同样的结果.
将这两种运算联系到一起的就是<strong>离散卷积定理</strong>.<span id="more"></span></p>
<div class="note info no-icon"><h5 id="注">注:</h5>
<p>按照上述定义, 计算卷积时会出现指标为负数的情况, 例如,
计算卷积的第一个分量时: <span class="math display">\[
(f*g)_0 = f_0 g_0 + f_1 g_{-1} + f_2 g_{-2} + \cdots + f_{n-1}
g_{-(n-1)}
\]</span> 但因为周期性 (或者称为 aliasing), <span
class="math inline">\(g_{k} = g_{k+n}\)</span>, 所以上式又可以写成 <span
class="math display">\[
(f*g)_0 = f_0 g_0 + f_1 g_{n-1} + f_2 g_{n-2} + \cdots + f_{n-1} g_{1}
\]</span></p>
</div>
<p>接下来我们将举一个数例, 说明卷积的计算过程</p>
<div class="note primary no-icon"><h5 id="离散卷积计算">离散卷积计算</h5>
<p>若 <span class="math inline">\(f=(1,2,3,4)\)</span>, <span
class="math inline">\(g=(5,6,7,8)\)</span>, 那么 <span
class="math inline">\(f,g\)</span>​ 之间的卷积为</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\((f*g)_0\)</span></th>
<th><span class="math inline">\(f\)</span></th>
<th><span class="math inline">\(g\)</span></th>
<th></th>
<th><span class="math inline">\((f*g)_1\)</span></th>
<th><span class="math inline">\(f\)</span></th>
<th><span class="math inline">\(g\)</span></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>1</td>
<td>5</td>
<td>5</td>
<td></td>
<td>1</td>
<td>6</td>
<td>6</td>
</tr>
<tr class="even">
<td></td>
<td>2</td>
<td>8</td>
<td>16</td>
<td></td>
<td>2</td>
<td>5</td>
<td>10</td>
</tr>
<tr class="odd">
<td></td>
<td>3</td>
<td>7</td>
<td>21</td>
<td></td>
<td>3</td>
<td>8</td>
<td>24</td>
</tr>
<tr class="even">
<td>sum = 66</td>
<td>4</td>
<td>6</td>
<td>24</td>
<td>sum = 68</td>
<td>4</td>
<td>7</td>
<td>28</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\((f*g)_2\)</span></th>
<th><span class="math inline">\(f\)</span></th>
<th><span class="math inline">\(g\)</span></th>
<th></th>
<th><span class="math inline">\((f*g)_3\)</span></th>
<th><span class="math inline">\(f\)</span></th>
<th><span class="math inline">\(g\)</span></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>1</td>
<td>7</td>
<td>7</td>
<td></td>
<td>1</td>
<td>8</td>
<td>8</td>
</tr>
<tr class="even">
<td></td>
<td>2</td>
<td>6</td>
<td>12</td>
<td></td>
<td>2</td>
<td>7</td>
<td>14</td>
</tr>
<tr class="odd">
<td></td>
<td>3</td>
<td>5</td>
<td>15</td>
<td></td>
<td>3</td>
<td>6</td>
<td>18</td>
</tr>
<tr class="even">
<td>sum = 66</td>
<td>4</td>
<td>8</td>
<td>32</td>
<td>sum = 60</td>
<td>4</td>
<td>5</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>因此, <span class="math display">\[
f*g = (66,68,66,60).
\]</span></p>
</div>
<p>如果直接按照定义去计算卷积, 那么需要 (<span
class="math inline">\(n\)</span> 个分量 <span
class="math inline">\(\times\)</span> 每个分量需要 <span
class="math inline">\(n\)</span> 次乘法 <span
class="math inline">\(=\)</span> <span
class="math inline">\(n^2\)</span>) 计算量,
接下来我们将给出离散形式的卷积定理, 使用该方法, 并搭配上快速 Fourier
变换, 可以实现更高效率地计算卷积.</p>
<div class="note success no-icon"><h5 id="离散形式的卷积定理">离散形式的卷积定理</h5>
<p>若物理空间中的向量 <span class="math inline">\(f\)</span> 和 <span
class="math inline">\(g\)</span> 分别对应相空间中的 <span
class="math inline">\(c\)</span> 和 <span
class="math inline">\(d\)</span> : <span class="math display">\[
c \triangleq (F)^{-1} f, \quad d \triangleq (F)^{-1} g,
\]</span> 那么 <span class="math inline">\(f*g\)</span>
等于相空间中向量之间的乘积 <span class="math inline">\(c \circ
d\)</span> 的变换, 并乘因子 <span class="math inline">\(n\)</span> <span
class="math display">\[
f*g = n F(c \circ d)
\tag{1}
\]</span></p>
</div>
<p>在证明该定理之前, 我们首先通过一个算例验证一下该定理:</p>
<div class="note primary no-icon"><p>我们使用式 (1) 重新计算 <span
class="math inline">\(f=(1,2,3,4)\)</span>, <span
class="math inline">\(g=(5,6,7,8)\)</span> 的卷积. 首先, 维度为 4 的
Fourier 变换矩阵以及逆矩阵为 <span class="math display">\[
F = \begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; i &amp; -1 &amp; -i \\
1 &amp; -1 &amp; 1 &amp; -1 \\
1 &amp; -i &amp; -1 &amp; i
\end{pmatrix}, \quad
(F)^{-1} = \frac{1}{4} \begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; -i &amp; -1 &amp; i \\
1 &amp; -1 &amp; 1 &amp; -1 \\
1 &amp; i &amp; -1 &amp; -i
\end{pmatrix}
\]</span> 对应的相空间中的 <span class="math inline">\(c\)</span> 和
<span class="math inline">\(d\)</span> 为 <span class="math display">\[
c = (F)^{-1}f = \frac{1}{4} \begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; -i &amp; -1 &amp; i \\
1 &amp; -1 &amp; 1 &amp; -1 \\
1 &amp; i &amp; -1 &amp; -i
\end{pmatrix}
\begin{pmatrix}
1 \\ 2 \\ 3 \\ 4
\end{pmatrix}
= \frac{1}{4} \begin{pmatrix}
10 \\ -2 + 2i \\ -2 \\ -2-2i
\end{pmatrix}
\]</span></p>
<p><span class="math display">\[
d = (F)^{-1}g = \frac{1}{4} \begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; -i &amp; -1 &amp; i \\
1 &amp; -1 &amp; 1 &amp; -1 \\
1 &amp; i &amp; -1 &amp; -i
\end{pmatrix}
\begin{pmatrix}
5 \\ 6 \\ 7 \\ 8
\end{pmatrix}
= \frac{1}{4} \begin{pmatrix}
26 \\ -2 + 2i \\ -2 \\ -2-2i
\end{pmatrix}
\]</span></p>
<p><span class="math inline">\(c\)</span> 与 <span
class="math inline">\(d\)</span> 乘积为 <span class="math display">\[
c \circ d = \frac{1}{16} \begin{pmatrix}
260 \\ -8i \\ 4 \\ 8i
\end{pmatrix}
\]</span> 再对 <span class="math inline">\(c \circ d\)</span> 作变换得到
<span class="math display">\[
n F(c \circ d) = 4\begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; i &amp; -1 &amp; -i \\
1 &amp; -1 &amp; 1 &amp; -1 \\
1 &amp; -i &amp; -1 &amp; i
\end{pmatrix}
\frac{1}{16} \begin{pmatrix}
260 \\ -8i \\ 4 \\ 8i
\end{pmatrix}
= \begin{pmatrix}
66 \\ 68 \\ 66 \\ 60
\end{pmatrix}
\]</span></p>
</div>
<p>使用离散卷积定理计算卷积的计算量为</p>
<ol type="1">
<li>物理空间到相空间的变换, <span
class="math inline">\(2n^2\)</span></li>
<li>乘积 <span class="math inline">\(c \circ d\)</span>, <span
class="math inline">\(n\)</span></li>
<li>相空间到物理空间的变换, <span
class="math inline">\(n^2\)</span>​</li>
</ol>
<p>总共需要 <span class="math inline">\(3n^2 + n\)</span> 次乘法!
这比直接用定义计算还要多上 <span class="math inline">\(3\)</span> 倍!
那么为什么说使用卷积定理计算速度更快呢? <strong>这是因为在第 1 和第 3
步的矩阵乘法运算可以通过快速 Fourier 变换 (Fast Fourier Transformation,
FFT) 替代</strong>, 这只需要 <span class="math inline">\(\mathcal{O}(n
\log n)\)</span> 次计算量.</p>
<p>接下来, 我们将用矩阵方法证明卷积定理. 首先将左侧的 <span
class="math inline">\(f\)</span> 向量拉成一个 <span
class="math inline">\(n \times n\)</span> 的矩阵,
矩阵的每一行对应上一行向右移动一个元素的位置,
右侧溢出的元素补缺到每一行的最左侧: <span class="math display">\[
C_f \triangleq \begin{pmatrix}
f_0 &amp; f_{n-1} &amp; \cdot &amp; \cdot &amp; f_{1} \\
f_{1} &amp; f_{0} &amp; f_{n-1} &amp; \cdot &amp; f_{2} \\
\cdot &amp; f_{1} &amp; f_{0} &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; f_{n-1} \\
f_{n-1} &amp; f_{n-2} &amp; \cdot &amp; f_{1} &amp; f_{0}
\end{pmatrix}
\]</span> 可以看到, 卷积 <span class="math inline">\(f*g\)</span>
结果就等于矩阵乘法 <span class="math inline">\(C_f g\)</span>
得到的向量. 接下来我们考察矩阵 <span class="math inline">\(C_f\)</span>
的特征值和特征向量. 立刻可以看到的是, 向量 <span
class="math inline">\((1,1,\ldots,1)^T\)</span> 是矩阵的一个特征向量,
并且对应的特征值为 <span class="math inline">\(\lambda_0 =
\sum_{k=0}^{n-1} f_k\)</span>. 向量 <span
class="math inline">\((1,w,\ldots,w^{n-1})^T\)</span> 同样也是矩阵 <span
class="math inline">\(C_f\)</span> 的一个特征向量, 对应特征值为 <span
class="math display">\[
\lambda_1 = \sum_{k=0}^{n-1} f_{k} w^{n-k} = \sum_{k=0}^{n-1} f_{k}
w^{-k}
\]</span> 我们可以验证第 <span class="math inline">\(j\)</span>
行的计算结果, 左侧矩阵乘法得到的第 <span
class="math inline">\(j\)</span>​ 个分量为 <span class="math display">\[
LHS = f_j \times 1 + f_{j-1} \times w + \cdots + f_0 w^j + f_{n-1}
w^{j+1} + \ldots + f_{j+1} w^{n-1}
\]</span> 提取因子 <span class="math inline">\(w^j\)</span> 得到 <span
class="math display">\[
LHS = w^j \left( \underbrace{f_j \times w^{-j} + f_{j-1} \times
w^{-(j-1)} + \cdots + f_1 w^{-1} + f_0 w^0}_{\clubsuit}
+ \underbrace{f_{n-1} w^{1} + \ldots + f_{j+1} w^{n-j-1}}_{\spadesuit}
\right)
\]</span> 对于式中 <span class="math inline">\(\spadesuit\)</span> 部分,
我们可以除因子 <span class="math inline">\(w^n\)</span>
(并且不改变这一部分的大小, 因为 <span
class="math inline">\(w^n=1\)</span>) 得到 <span class="math display">\[
f_{n-1} w^{1} + \ldots + f_{j+1} w^{n-j-1} = f_{n-1} w^{-(n-1)} + \ldots
+ f_{j+1} w^{-(j+1)}
\]</span> 重新排列就可以得到右端项向量第 <span
class="math inline">\(j\)</span> 行分量: <span class="math display">\[
LHS = w^j \lambda_1 = RHS
\]</span> 一般的, 我们可以得到矩阵 <span
class="math inline">\(C_f\)</span> 的<strong>特征向量为 Fourier 变换矩阵
<span class="math inline">\(F\)</span> 的列向量</strong>,
<strong>特征值为 <span class="math inline">\(f\)</span> 的 Fourier
变换系数 <span class="math inline">\(c[f]\)</span> 再乘 <span
class="math inline">\(n\)</span></strong>. 写成矩阵的形式为 <span
class="math display">\[
C_f F = F \Lambda_f,\quad \Lambda_f = n ~\mathrm{diag}~ (c[f])
\]</span> 而这样的矩阵分解, 恰好对应于离散卷积定理.
我们现在用矩阵乘法将卷积 <span class="math inline">\(f*g\)</span>
表示为周期矩阵 <span class="math inline">\(C_f\)</span> 与向量 <span
class="math inline">\(g\)</span> 的矩阵乘积, <span
class="math inline">\(C_f\)</span> 可以分解为三个特殊的矩阵之间的乘积
<span class="math inline">\(F \Lambda_f (F)^{-1}\)</span>, 因此,
卷积计算过程也可以分解为对应地 “三步走”:</p>
<ol type="1">
<li>对向量 <span class="math inline">\(g\)</span> 作变换 <span
class="math inline">\((F)^{-1}g\)</span>, 得到关于 <span
class="math inline">\(g\)</span> 的 Fourier 变换系数 <span
class="math inline">\(d\)</span></li>
<li><span class="math inline">\(\Lambda d\)</span> 得到向量 <span
class="math inline">\(n(c \circ d)\)</span>, 也就是 <span
class="math inline">\(n\)</span> 倍的 <span
class="math inline">\(c\)</span>, <span class="math inline">\(d\)</span>
乘积</li>
<li>对乘积 <span class="math inline">\(n(c \circ d)\)</span> 作变换
<span class="math inline">\(F\)</span>, 得到卷积 <span
class="math inline">\(f*g\)</span>​</li>
</ol>
<p>由此得到如下离散卷积定理的表达式: <span class="math display">\[
(F)^{-1}(f*g) = (F)^{-1} F \Lambda_f (F)^{-1} g = n \left[ (F)^{-1}f
\right] \circ \left[ (F)^{-1}g \right]
\tag{2}
\]</span> 我们可以立刻看到, 式 (2) 与前文得到的式 (1)
其实说明的是一回事.</p>
<p>按照上面的矩阵证明方法, 同样也可以说明反方向用乘积计算卷积也是可行的.
如果我们将变换后的向量 <span class="math inline">\(c\)</span> <span
class="math inline">\(d\)</span> 之间卷积写成矩阵乘积的形式, 就得到
<span class="math display">\[
c*d = C_c d
\]</span> 矩阵 <span class="math inline">\(C_c\)</span>
的特征向量为变换矩阵 <span class="math inline">\(\overline F\)</span>
的列向量, 特征值为 <span class="math inline">\(f[c]\)</span>,
写成矩阵的形式就得到 <span class="math display">\[
C_c \overline F = \overline F \Lambda_c,\quad \Lambda_c = \mathrm{diag}~
(f[c])
\]</span> 所以 <span class="math display">\[
c*d = \overline F \Lambda_c (\overline F)^{-1} d = \frac{1}{n} \overline
F \Lambda_c g =  F^{-1}(f \circ g)
\]</span> 综合上述讨论,
我们可以将离散卷积定理总结为如下对称且优美的形式: <span
class="math display">\[
\begin{aligned}
(F)^{-1}(f*g) &amp;= n \left[ (F)^{-1}f \right] \circ \left[ (F)^{-1}g
\right] \\
F^{-1}(f \circ g) &amp;= \left[ (F)^{-1}f \right]*\left[ (F)^{-1}f
\right]
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>Fourier 分析</category>
      </categories>
      <tags>
        <tag>离散卷积定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Laplace 算子在极坐标下的形式</title>
    <url>/math/PDE/Laplace-%E7%AE%97%E5%AD%90%E5%9C%A8%E6%9E%81%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<p>在二维空间中的函数 <span class="math inline">\(u:\mathbb{R}^2 \mapsto
\mathbb{R}\)</span>, 满足 Laplace 方程: <span class="math display">\[
-\Delta u = 0
\]</span> 式中 <span class="math inline">\(\Delta\)</span> 为 Laplace
算子, 在直角坐标下为 <span class="math display">\[
\Delta = \frac{\partial^2~}{\partial x^2} + \frac{\partial^2~}{\partial
y^2}
\tag{D}
\]</span> 在极坐标下写作 <span class="math display">\[
\Delta = \frac{\partial^2~}{\partial r^2}
+ \frac{1}{r} \frac{\partial~}{\partial r}
+ \frac{1}{r^2} \frac{\partial^2~}{\partial \theta^2}
\tag{P}
\]</span> <span id="more"></span>这两种坐标形式下的 Laplace 算子表示可以通过坐标变换
<span class="math display">\[
x = r\cos \theta, \quad y = r \sin \theta
\]</span> 或者 <span class="math display">\[
r = \sqrt{x^2 + y^2}, \quad \theta = \arctan \frac{y}{x}
\]</span> 得到, 但是我现在不想这样做, 因为我已经这么做了很多次了,
并且每一次推导都是 “全新” 的体验.
我现在想做的是怎么样才能快速记住极坐标变换的形式.</p>
<p>首先可以观察方程的量纲, 可以验证, 式 (P) 与式 (D) 在量纲上是一致的.
但是这也仅仅限于验证, 并不能帮助我得到极坐标表达式的形式.</p>
<p>如果尝试将一阶微分写成矩阵的形式, 那么就有: <span
class="math display">\[
\begin{pmatrix}
\frac{\partial~}{\partial x} \\ \frac{\partial~}{\partial y}
\end{pmatrix}
= R(\theta)
\begin{pmatrix}
\frac{\partial~}{\partial r} \\ \frac{1}{r} \frac{\partial~}{\partial
\theta}
\end{pmatrix}
\]</span> 式中, <span class="math inline">\(R(\theta)\)</span>
为旋转矩阵 <span class="math display">\[
R(\theta) \triangleq \begin{pmatrix}
\cos\theta &amp; -\sin\theta \\ \sin\theta &amp; \cos\theta
\end{pmatrix}
\]</span> 但是, 无法再继续得到用矩阵表示的二阶偏导数形式,
这是因为算子的系数是非线性的. 如果是线性的, 那么极坐标表达式 (P)
就不会出现关于 <span class="math inline">\(r\)</span> 的一次偏导数.</p>
<p>那么还可以继续怎么做下去呢? 最终我在 Math stack Exchange
上找到了这一篇回答: <span class="exturl" data-url="aHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yMjQ4NjYxL2hvdy10by1yZW1lbWJlci1sYXBsYWNpYW4taW4tcG9sYXItYW5kLWh5cGVyc3BoZXJpY2FsLWNvb3JkaW5hdGVz">How
to remember laplacian in polar and (hyper)spherical coordinates<i class="fa fa-external-link-alt"></i></span></p>
<p>设直角坐标下的函数形式为 <span class="math inline">\(u(x,y)\)</span>,
考虑点 <span class="math inline">\(P\)</span> 在 <span
class="math inline">\((x,0)\)</span> 的特殊情况, 此时 <span
class="math inline">\(r \equiv x\)</span>, 所以 <span
class="math inline">\(u_{xx} \equiv u_{rr}\)</span>.
现在我们要考虑在圆周曲线上的导数与垂直于 <span
class="math inline">\(x\)</span> 轴直线的导数的区别. <span
class="math display">\[
u_{\theta}(\theta) = u(r\cos\theta, r\sin\theta)
\]</span> <span class="math inline">\(U_{\theta}\)</span> 对 <span
class="math inline">\(\theta\)</span> 的一阶导数为 <span
class="math display">\[
\frac{\mathrm{d} u_{\theta}}{\mathrm{d} \theta} = u_x
(-r\sin\theta)|_{\theta=0}
+ u_{y}(r\cos\theta)|_{\theta=0} = r u_y
\]</span> 这是很合理的, 因为在垂直于 <span
class="math inline">\(x\)</span> 轴方向上有微元关系 <span
class="math inline">\(r~\mathrm{d} \theta = \mathrm{d}y\)</span>.</p>
<p>接下来要求二阶导数, 注意到不能直接对上式代入数值之后的关系式 <span
class="math inline">\({\mathrm{d} u_{\theta}}/{\mathrm{d} \theta}= r
u_y\)</span> 关于 <span class="math inline">\(\theta\)</span> 求导得到
<span class="math inline">\({\mathrm{d}^2 u_{\theta}}/{\mathrm{d}
\theta^2}= r^2 u_{yy}\)</span>, 因为 <span
class="math inline">\({\mathrm{d} u_{\theta}}/{\mathrm{d} \theta}=
0\)</span> 的项中仍可能对二阶导数项有贡献. 所以 <span
class="math display">\[
\left.\frac{\mathrm{d}^2 u_{\theta}}{\mathrm{d}
\theta^2}\right|_{\theta=0}= -u_x r + u_{yy}r^2
\]</span> 注意到 <span class="math inline">\(u_x \equiv u_r\)</span>,
所以 <span class="math inline">\(u_{yy}\)</span> 可以表示为 <span
class="math display">\[
u_{yy} = \frac{1}{r}u_r + \frac{1}{r^2}u_{\theta\theta}
\]</span> 这就通过特殊位置的点, 得到极坐标的形式 (P)</p>
<p><em>还可以继续推广到高维情景</em></p>
]]></content>
      <categories>
        <category>偏微分方程</category>
      </categories>
      <tags>
        <tag>极坐标</tag>
      </tags>
  </entry>
  <entry>
    <title>Bessel 函数</title>
    <url>/math/PDE/Bessel-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong><em>参考文献: Gilbert Strang, Introduction to applied
mathematics</em></strong></p>
<p>Bessel 函数是求解二维圆形区域上的振型方程引入的, 振型方程为 <span
class="math display">\[
\Delta u + \lambda u = 0, \quad
u=0 \quad\text{on}\quad B(1,0)
\]</span> 写成极坐标的形式为 <span class="math display">\[
\frac{\partial^2 u}{\partial r^2}
+ \frac{1}{r}\frac{\partial u}{\partial r}
+ \frac{1}{r^2}\frac{\partial^2 u}{\partial \theta^2}
+ \lambda u = 0
\tag{1}
\]</span> 如果将极坐标上的方程解 <span
class="math inline">\(u(r,\theta)\)</span> 写成分离变量的形式, <span
class="math inline">\(u(r,\theta) = A(\theta)B(r)\)</span>​,
代入到上述方程中 <span class="math display">\[
AB^{\prime\prime} + \frac{1}{r}AB^{\prime} +
\frac{1}{r^2}A^{\prime\prime}B + \lambda AB = 0
\]</span> <span id="more"></span>方程乘 <span class="math inline">\(r^2\)</span>,
然后将不同变量的函数分离, 并分别放在方程两侧得到 <span
class="math display">\[
\frac{r^2 B^{\prime\prime} + r B^{\prime} + \lambda r^2 B}{B} (r) = -
\frac{A^{\prime\prime}}{A~~} (\theta)
\tag{2}
\]</span> 等号两边的函数依赖于不同的独立变量, 并且等号恒成立,
这就不得不要求方程两边应该等于一个相同的常数 <span
class="math inline">\(C\)</span>. 常数 <span
class="math inline">\(C\)</span> 的确定需要观察方程 (1) 的边界条件:
<span class="math inline">\(A(\theta)\)</span> 是周期为 <span
class="math inline">\(2\pi\)</span> 的函数, 因此常数 <span
class="math inline">\(C\)</span> 必须大于等于 0 (否则依指数衰减), 且等于
<span class="math inline">\(n^2\)</span>, <span
class="math inline">\(n\)</span> 为非零整数(否则就不能以 <span
class="math inline">\(2\pi\)</span> 为周期). 式 (2) 右端方程解得 <span
class="math display">\[
A = c_1 e^{-i n\theta} + c_2 e^{-i n\theta} \quad 或者 \quad
A = a_1 \cos n\theta + a_2 \sin n\theta
\]</span> 式 (2) 左端满足的微分方程, 以及根据式 (1) 得到的对 <span
class="math inline">\(B\)</span> 的约束 <span class="math display">\[
r^2 B^{\prime\prime} + r B^{\prime} + \lambda r^2 B + n^2 B = 0, \quad
B(1) = 0
\tag{3}
\]</span> 这是一个变系数二阶线性齐次常微分方程,
方程的解没办法直接猜出来, 并且还要满足约束 <span
class="math inline">\(B(1) = 0\)</span>, 所以构造 <span
class="math inline">\(B\)</span> 为关于 <span
class="math inline">\(r\)</span> 的级数解形式: <span
class="math display">\[
\mathrm{ANSATZ}\quad B(r) = \sum c_m r^m
\]</span> 代入到方程 (3) 当中, 得到 <span class="math display">\[
\sum c_m m(m-1) r^m + \sum c_m m r^m + \sum \lambda c_m  r^{m+2} + \sum
n^2 c_m r^m \equiv 0
\]</span> 整理一下级数项 <span class="math inline">\(r^m\)</span>
的系数得到 <span class="math display">\[
\sum \left[ c_m m(m-1) + c_m m + \lambda c_{m-2} + n^2 c_m \right] r^m
\equiv 0
\]</span> 级数项系数应恒等于 0, 于是我们就得到了关于系数 <span
class="math inline">\(c_m\)</span> 的递归方程 <span
class="math display">\[
c_m = \frac{-\lambda}{m^2 + n^2} c_{m-2}
\]</span> 特别的, 如果我们令 <span class="math inline">\(n:=0\)</span>
(此时 <span class="math inline">\(A(\theta) \equiv
\mathrm{Const}\)</span>, <span class="math inline">\(u(r,\theta) =
B(r)\)</span> 为径向对称函数), 以及 <span class="math inline">\(c_0 =
1\)</span>, <span class="math inline">\(c_1 = 0\)</span>, 就得到 Bessel
方程 <span class="math display">\[
B(r) = 1 - \frac{\lambda}{2^2} r^2 + \frac{\lambda^2}{2^2 4^2} r^4
- \frac{\lambda^3}{2^2 4^2 6^2} r^6 + \cdots
\tag{4}
\]</span> 令上式 <span class="math inline">\(\lambda=1\)</span>,
就得到零阶 Bessel 函数 (零阶对应 <span
class="math inline">\(n=0\)</span>​) <span class="math display">\[
J_{0}(r) \triangleq 1 - \frac{1}{2^2} r^2 + \frac{1}{2^2 4^2} r^4
- \frac{1}{2^2 4^2 6^2} r^6 + \cdots
\]</span> 以及 <span class="math inline">\(B(r) =
J_{0}(\sqrt{\lambda}~r)\)</span>.</p>
<p>现在我们还没有确定式 (4) 中 <span
class="math inline">\(\lambda\)</span> 可以取哪些数值. <span
class="math inline">\(\lambda\)</span> 应满足 <span
class="math inline">\(B(1)=0\)</span>, 也即 <span
class="math display">\[
B(1) = J_0(\sqrt{\lambda}) = 1 - \frac{\lambda}{2^2} +
\frac{\lambda^2}{2^2 4^2}
- \frac{\lambda^3}{2^2 4^2 6^2} + \cdots
= \sum_{n=0}^{\infty} \frac{(-1)^n}{(n! 2^n)^2} \lambda^n
= 0
\]</span> 上述方程根没有解析表达式, 但是可以类比余弦函数 <span
class="math display">\[
\cos x = \sum_{n=0}^{\infty} \frac{(-1)^n}{(2n)!} x^{2n}
\]</span> 若 <span class="math inline">\(\cos \sqrt{\lambda} =
0\)</span>, 那么 <span class="math inline">\(\sqrt{\lambda} = \pi/2,
3\pi/2, 5\pi/2\ldots\)</span>. 使得 <span
class="math inline">\(J_0(\sqrt{\lambda}) = 0\)</span> 的取值为 <span
class="math display">\[
\sqrt{\lambda} = 2.4,~ 5.5,~ 8.65,~ 11.8,~ 14.9, ...
\]</span> Bessel 函数的前 <span class="math inline">\(n\)</span>
项和的图像为</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202405192100470Bessel.png" alt="image-20240519210015336" style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>偏微分方程</category>
      </categories>
      <tags>
        <tag>构造级数解</tag>
        <tag>振型方程</tag>
        <tag>分离变量法</tag>
      </tags>
  </entry>
  <entry>
    <title>三类方程的基本解</title>
    <url>/math/PDE/%E4%B8%89%E7%B1%BB%E6%96%B9%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%A3/</url>
    <content><![CDATA[<p>基本解只与方程相关, 与边界条件无关. 以下将考虑 Laplace 方程,
热方程和波动方程的基本解.</p>
<p>方程 <span class="math inline">\(L\)</span> 基本解的定义为右端项为
delta 函数的响应: <span class="math display">\[
L[u] = \delta
\]</span></p>
<h2 id="laplace-方程的基本解">Laplace 方程的基本解</h2>
<p>先给出结论: 设 Laplace 方程的基本解为 <span
class="math inline">\(N(x)\)</span> <span class="math display">\[
-\Delta N = \delta
\]</span> 那么对不同的维度, 解 <span class="math inline">\(N(x)\)</span>
为 <span class="math display">\[
\boxed{N(x) = \left\{\begin{array}{cl}
\dfrac{1}{(d-2) S_d} |x|^{2-d}, &amp;d \neq 2\\
- \dfrac{1}{2\pi} \ln|x|, \quad &amp; d = 2
\end{array}\right.}
\]</span> 式中, <span class="math inline">\(S_d\)</span> 为 <span
class="math inline">\(d\)</span> 维单位球的表面积. 分别列出一维,
二维和三维情景下 Laplace 方程的基本解: <span class="math display">\[
\boxed{N(x) = \left\{\begin{array}{cl}
-\dfrac{1}{2} |x|, &amp; d = 1\\
-\dfrac{1}{2\pi} \ln|x|, &amp; d = 2\\
\dfrac{1}{4\pi} \dfrac{1}{|x|}, &amp; d =3
\end{array}\right.}
\]</span>
<img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202406151119398.png" alt="image-20240615111956159" style="zoom:50%;" /></p>
<p>接下来, 我们会用两种方式推导基本解. 第一种方式是利用 Laplace
解的<strong>径向对称性</strong>, 因此假设方程的解 <span
class="math inline">\(u(x)\)</span> 可以写成关于距原点距离为 <span
class="math inline">\(r\)</span> 的函数 <span
class="math inline">\(v(r)\)</span>: <span class="math display">\[
u(x) = v(r), \quad r = |x|
\]</span> 将径向对称解代入到 Laplace 方程中的二阶导数项 <span
class="math display">\[
\frac{\partial v(|x|)}{\partial x_i} = v&#39; \frac{x_i}{|x|}, \quad
\frac{\partial^2 v(|x|)}{\partial x_i^2}
= v&#39;&#39; \frac{x_i^2}{|x|^2} + v&#39; \frac{|x|^2 - x_i^2}{|x|^{3}}
\]</span> 求和得到关于 <span class="math inline">\(r\)</span>
的<strong>常微分方程</strong> <span class="math display">\[
\Delta u = v&#39;&#39; + \frac{(d-1)}{r}v&#39; = 0
\]</span> 当 <span class="math inline">\(d \neq 1\)</span> 时,
上述微分方程的一个不平凡解为 <span class="math display">\[
v&#39; = Ar^{1-d}, \quad v =
\begin{cases}
A \ln r,   &amp;d = 2 \\
B r^{2-d}, &amp;d &gt; 2
\end{cases}
\]</span> 这样, 除了待定常数之外,Laplace
方程基本解的形式是已经确定的了.</p>
<p>另一种, 也是更常规的方法, 是使用 <strong>Fourier 变换</strong>.
方程两端作 Fourier 变换得到 <span class="math display">\[
4 \pi^2 |\xi|^2 \widehat N = 1, \quad |\xi|^2 \triangleq \xi_i \xi_i
\]</span> 所以方程的基本解可以通过 Fourier 逆变换表示为 <span
class="math display">\[
N(x) = \mathscr{F}^{-1}[\widehat N] = \int_{\mathbb{R}^d}
\frac{1}{4\pi^2 |\xi|^2} e^{i2\pi\xi \cdot x} ~\mathrm{d}\xi
\]</span> 注意到 <span class="math inline">\(\widehat{N}\)</span> 是
<span class="math inline">\(\alpha=-2\)</span> 的齐次径向对称函数, 所以
<span class="math inline">\(N\)</span> 是 <span
class="math inline">\(-d-\alpha = -d+2\)</span> 齐次径向对称函数, 因此
<span class="math inline">\(N\)</span> 可以写成 <span
class="math display">\[
N(x) = N(|x|\frac{x}{|x|}) = |x|^{2-d} N_{0}(1)
\]</span> <strong>为确定常数 <span
class="math inline">\(N_0(1)\)</span>, 对 <span
class="math inline">\(\Delta N\)</span> 在球 <span
class="math inline">\(B_{\varepsilon}(0)\)</span> 上积分</strong>,
并应用 Gauss 公式, 得到 <span class="math display">\[
\int_{B_{\varepsilon}} -\Delta N ~\mathrm{d}x = 1
= - \int_{\partial B_{\varepsilon}} n \cdot \nabla N ~\mathrm{d}
\sigma(x)
\]</span> 径向对称函数的法向导数为 <span class="math display">\[
\boxed{\nabla N = N_0&#39;(r)\frac{x_i}{|x|} = N_0&#39;(r) n, \quad n
\cdot \nabla N = N_{0}&#39;(r)}
\]</span> 所以 <span class="math display">\[
1 = - \int_{\partial B_{\varepsilon}} N_{0}&#39; ~\mathrm{d} \sigma(x)
= - N_{0}&#39;(\varepsilon) S_{d} \varepsilon^{d-1}
= (d-2) S_{d} N_0(1)
\]</span> 由此得到 <span class="math display">\[
N(x) = \frac{1}{(d-2) S_{d}} |x|^{2-d}
\]</span></p>
<blockquote>
<p>[!Important]</p>
<p>式中对于 <span class="math inline">\(d=2\)</span> 的情景是不适用的,
不过可以考虑这样 (虽然不令人很信服) 的极限: <span
class="math inline">\(d = 2 + \varepsilon\)</span>, 那么, <span
class="math display">\[
N(x) = \frac{1}{\omega_{1+ \varepsilon} \varepsilon }|x|^{-\varepsilon}
= \frac{1}{2\pi} ~ \frac{1}{ \varepsilon }|x|^{-\varepsilon}
\]</span> 将上式右端项关于 <span
class="math inline">\(\varepsilon\)</span> 渐进展开得到 <span
class="math display">\[
\frac{1}{ \varepsilon }|x|^{-\varepsilon} = \frac{1}{ \varepsilon
}e^{-\varepsilon\ln|x|}
\sim \frac{1}{\varepsilon} ( 1 - \boxed{\varepsilon \ln |x|} +
o(\varepsilon) )
\]</span> 最后得到 <span class="math display">\[
N(x) = -\frac{1}{2\pi} \ln|x|
\]</span></p>
</blockquote>
<blockquote>
<p>[!NOTE]</p>
<p><strong><span class="math inline">\(d=1\)</span>
时的基本解</strong></p>
<p>此时方程为 <span class="math display">\[
-u&#39;&#39; = \delta
\]</span> 该方程在 <span class="math inline">\(x=0\)</span> 处有奇性,
所以分别对 <span class="math inline">\(x&gt;0\)</span> 和 <span
class="math inline">\(x&lt;0\)</span> 区域分别求解得到 <span
class="math display">\[
u = \begin{cases}
c_1 x, &amp; x&lt;0\\
c_2 x, &amp; x&gt;0
\end{cases}
\]</span> <em>基本解中忽略常数项.</em> 为确定积分中出现的常数,
还需要利用如下性质. 首先是对称性, 这要求 <span class="math inline">\(c_1
= -c_2 = c\)</span>. 然后对方程在区间 <span
class="math inline">\((-\varepsilon,\varepsilon)\)</span> 上积分得到
<span class="math display">\[
-\int_{-\varepsilon}^{\varepsilon} u&#39;&#39; ~\mathrm{d}x = 1
\]</span> 分别对 <span class="math inline">\((0,\varepsilon)\)</span> 和
<span class="math inline">\((-\varepsilon,0)\)</span> 两个区间段积分得到
<span class="math display">\[
-u&#39;|_{0^+}^{\varepsilon} - u&#39;|_{-\varepsilon}^{0^-}
= -c + u&#39;(0^+)-u&#39;(0^-)-c = [u&#39;(0)] - 2c = 1
\]</span> 如果设置间断条件 <span class="math inline">\([u&#39;(0)] =
0\)</span>, 那么 <span class="math display">\[
c = -\frac{1}{2}
\]</span></p>
</blockquote>
<h2 id="热方程的基本解">热方程的基本解</h2>
<p>热方程基本解满足的方程和初始条件为 <span class="math display">\[
\left\{\begin{array}{c}
\dfrac{\partial H}{\partial t} = \Delta H \\
H(x,0) = \delta(x)
\end{array}\right.
\]</span> 应用 Fourier 变换, 得到 <span class="math display">\[
\left\{\begin{array}{c}
\dfrac{\mathrm{d} \widehat H}{\mathrm{d} t} + 4 \pi^2 |\xi|^2 \widehat H
\\
\widehat H(0) = 1
\end{array}\right.
\]</span> 求解上述微分方程, 得到 <span class="math display">\[
\widehat H(t) = e^{-4\pi^2 |\xi|^2 t}
\]</span> 所以热方程的基本解为 <span class="math display">\[
\boxed{H(x,t) = \frac{1}{(4\pi t)^{d/2}} e^{- |x|^2/4t}}
\]</span> <img
src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Fundamental_solution_to_the_heat_equation.gif/440px-Fundamental_solution_to_the_heat_equation.gif"
alt="img" /></p>
<p>另一种得到热方程基本解的方式是自相似方法. 如果 <span
class="math inline">\(H(x,t)\)</span> 满足热方程和初始条件, 那么, <span
class="math inline">\(cH(\lambda x, \lambda^2 t)\)</span>
同样也满足热方程. 为保证初始条件一致, <span
class="math inline">\(cH(\lambda x, 0) = c\delta(\lambda x)\)</span>
应等于 <span class="math inline">\(\delta(x)\)</span>, 这要求 <span
class="math inline">\(c = \lambda^d\)</span>. 所以, 对任意 <span
class="math inline">\(\lambda \neq 0\)</span>, <span
class="math display">\[
H(x,t) = \lambda^d H(\lambda x, \lambda^2 t)
\]</span> 如果取 <span class="math inline">\(\lambda =
1/\sqrt{t}\)</span>, 那么 <span class="math display">\[
H(x,t) = t^{-d/2} H(x/\sqrt{t}, 1)
\]</span> 再考虑到热方程关于空间的微分是径向对称的, 所以 <span
class="math inline">\(H(x/\sqrt{t}, 1)\)</span> 可以表示为 <span
class="math inline">\(\mathbb{R}\)</span> 上单变量的函数 <span
class="math inline">\(v(r)\)</span>, <span class="math inline">\(r =
|x|/\sqrt{t}\)</span>: <span class="math display">\[
H(x,t) = t^{-d/2} v(r)
\]</span> 将解代入到热方程 <span class="math inline">\(\partial_t H =
\Delta H\)</span> 中得到 <span class="math display">\[
-\frac{d}{2} t^{-d/2 - 1} v + t^{-d/2} v&#39; \frac{\mathrm{d}
r}{\mathrm{d} t}
= t^{-d/2} (v&#39;&#39;/t + \frac{d-1}{|x|}v&#39;/\sqrt{t})
\]</span> 这就得到微分方程 <span class="math display">\[
v&#39;&#39; + \left(\frac{d-1}{r} + \frac{1}{2} r \right)v&#39; +
\frac{d}{2} v = 0
\]</span> 也即 <span class="math display">\[
(r^{d-1} v&#39;)&#39; + \frac{1}{2} (r^d v)&#39; = 0 \Rightarrow
r^{d-1} v&#39; + \frac{1}{2} r^d v = \mathrm{const}
\]</span> 令常数等于 0, 那么 <span class="math display">\[
v = c e^{-r^2/4}
\]</span></p>
<h2 id="波动方程的基本解">波动方程的基本解</h2>
<p>在波动方程基本解的定义当中, 函数 <span
class="math inline">\(\delta\)</span> 放在了初始速度项: <span
class="math display">\[
\frac{\partial^2 W}{\partial t^2} - \Delta W = 0,\\
W(x, 0) = 0, \\
\partial_t W(x,0) = \delta
\]</span></p>
]]></content>
      <categories>
        <category>偏微分方程</category>
      </categories>
      <tags>
        <tag>基本解</tag>
        <tag>Laplace 方程</tag>
        <tag>热方程</tag>
      </tags>
  </entry>
  <entry>
    <title>泊松公式求解 Laplace 方程</title>
    <url>/math/PDE/%E6%B3%8A%E6%9D%BE%E5%85%AC%E5%BC%8F%E6%B1%82%E8%A7%A3-Laplace-%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<p>考虑在圆盘 <span class="math inline">\(\{(x,y) \mid x^2+y^2 \leq
1\}\)</span> 上的 Laplace 方程: <span class="math display">\[
\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} =
0
\tag{1}
\]</span> 以及圆盘边界条件 <span class="math display">\[
u(1,\theta) := u_0(\theta)
\]</span> <span id="more"></span>我们希望构造一个用级数表示的 <span
class="math inline">\(u\)</span>: <span class="math display">\[
u(x,y) = a_0 + a_1u_1(x,y)+ a_2u_2(x,y) + \cdots
\]</span> 或者使用极坐标 <span class="math display">\[
u(r,\theta) = b_0 + b_1u_1(r,\theta) + b_2u_2(r,\theta) + \cdots
\]</span> 式中的函数 <span class="math inline">\(u_i\)</span> 总是满足
Laplace 方程 <span class="math display">\[
\frac{\partial^2 u_i}{\partial x^2} + \frac{\partial^2 u_i}{\partial
y^2} = 0
\]</span> 这样, 在边界处得到 <span class="math display">\[
u(1,\theta) = b_0 + b_1u_1(1,\theta) + b_2u_2(1,\theta) + \cdots
\]</span> 之后可以调整系数 <span class="math inline">\(b_i\)</span>
与给定的边界条件 <span class="math inline">\(u_0(\theta)\)</span> 匹配.
不过首先需要考察的是, 怎样的函数 <span
class="math inline">\(u_i\)</span> 可以满足 Lapalce 方程 (1)? 可以验证,
函数 <span class="math inline">\((x + iy)^n\)</span>
的实部与虚部总是满足方程 (1) 的, 这是因为对 <span
class="math inline">\(y\)</span> 求二次导数, 得到系数 <span
class="math inline">\(i^2=-1\)</span>, 正好与关于 <span
class="math inline">\(x\)</span> 的二次导数项消掉. 因此, 函数 <span
class="math inline">\(u_i\)</span> 可以是 <span class="math display">\[
\begin{aligned}
u_i(x,y)&amp;: 1,~ x,~ y,~ x^2-y^2,~ 2xy, \ldots \\
u_i(r,\theta)&amp;: 1,~ r\cos \theta,~ r\sin \theta,~ r^2\cos 2\theta,~
r^2\sin 2\theta, \dots
\end{aligned}
\]</span> 如果将方程解 <span class="math inline">\(u\)</span>
表示成关于极坐标的函数: <span class="math display">\[
u(r,\theta) = \frac{a_0}{2} + a_1 r \cos \theta + b_1 r \sin \theta
+ a_2 r^2 \cos 2\theta + b_2 r^2 \sin 2\theta
+ \cdots
\tag{$\star$}
\]</span> 并令方程解在边界上等于 <span
class="math inline">\(u_0\)</span>: <span class="math display">\[
u(1,\theta) = \frac{a_0}{2} + a_1 \cos \theta + b_1 \sin \theta
+ a_2 \cos 2\theta + b_2 \sin 2\theta
+ \cdots
\equiv u_0(\theta)
\]</span> 注意到 <span class="math inline">\(u_0\)</span> 是周期为 <span
class="math inline">\(2\pi\)</span> 的函数, 因此式 (<span
class="math inline">\(\star\)</span>) 中的系数恰好是函数 <span
class="math inline">\(u_0\)</span> 的 Fourier 级数展开的系数. 将 Fourier
系数的表达式代入到式 (<span class="math inline">\(\star\)</span>) 中得到
<span class="math display">\[
\begin{aligned}
u(r,\theta) &amp;= \frac{1}{2\pi} \int_{0}^{2\pi} u_0(\varphi)
~\mathrm{d} \varphi
+ \sum_{k=1}^{\infty} \left( \frac{1}{\pi} \int_{0}^{2\pi} u_0(\varphi)
\cos k\varphi ~\mathrm{d}\varphi \right)r^k \cos k\theta
+ \sum_{k=1}^{\infty} \left( \frac{1}{\pi} \int_{0}^{2\pi} u_0(\varphi)
\sin k\varphi ~\mathrm{d}\varphi \right)r^k \sin k\theta \\
&amp;= \frac{1}{2\pi} \int_{0}^{2\pi} u_0(\varphi) ~\mathrm{d} \varphi
+ \frac{1}{\pi} \sum_{k=1}^{\infty} \int_{0}^{2\pi} u_0(\varphi) r^k
\left( \cos k\varphi \cos k\theta  + \sin k\varphi \sin
k\theta\right)~\mathrm{d}\varphi \\
&amp;= \frac{1}{2\pi} \int_{0}^{2\pi} u_0(\varphi) ~\mathrm{d} \varphi
+ \frac{1}{\pi} \int_{0}^{2\pi} u_0(\varphi) \sum_{k=1}^{\infty} r^k
\cos k(\varphi-\theta) ~\mathrm{d}\varphi
\end{aligned}
\]</span> 考察上式中的级数和 <span class="math display">\[
\begin{aligned}
\sum_{k=1}^{\infty} r^k \cos k(\varphi-\theta)
&amp;=\sum_{k=1}^{\infty} \mathrm{Re}~  \left( r e^{i (\varphi-\theta)}
\right)^k
= \mathrm{Re}~  \sum_{k=1}^{\infty} \left( r e^{i (\varphi-\theta)}
\right)^k \\
&amp;= \mathrm{Re} \lim_{n \rightarrow \infty} \frac{ 1-\left( r e^{i
(\varphi-\theta)} \right)^n }{ 1-r e^{i (\varphi-\theta)} } r e^{i
(\varphi-\theta)} \\
&amp;= \mathrm{Re} \frac{ r e^{i (\varphi-\theta)} }{ 1-r e^{i
(\varphi-\theta)} } \\
&amp;= \frac{r\cos(\varphi-\theta) - r^2}{1-2r\cos(\varphi-\theta)+r^2}
\end{aligned}
\]</span> 再代入到 <span class="math inline">\(u(r,\theta)\)</span>
的表达式当中得到 <span class="math display">\[
u(r,\theta) = \frac{1}{2\pi} \int_{0}^{2\pi} u_0(\varphi) \frac{1 -
r^2}{1-2r\cos(\varphi-\theta)+r^2} ~\mathrm{d}\varphi
\tag{$\clubsuit$}
\]</span> 上述推导默认了求和号与积分是可以交换顺序的 (所以并不太严谨),
但是我们可以对式 (<span class="math inline">\(\clubsuit\)</span>)
做一些验证. 当 <span class="math inline">\(r=0\)</span> 时, 根据式
(<span class="math inline">\(\clubsuit\)</span>)
得到圆心的函数值为沿边界的积分平均: <span class="math display">\[
u(0,\theta) = \frac{1}{2\pi} \int_{0}^{2\pi} u_0(\varphi)
~\mathrm{d}\varphi
\]</span> 这对于稳态方程是正确的. 此外,
如果将积分项中的分式写成直角坐标的形式 <span class="math display">\[
\frac{1 - r^2}{1-2r\cos(\varphi-\theta)+r^2}
\rightarrow
\frac{1-|\mathbf{x}|^2}{\mathrm{d}^2(\mathbf{x},\mathbf{x}_{\varphi})}
\]</span> 当 <span class="math inline">\(\mathbf{x}\)</span>
趋近于边界点 <span class="math inline">\(\mathbf{x}_{\varphi_0}\)</span>
时, 上式的函数趋近于函数 <span class="math inline">\(\delta(\mathbf{x} -
\mathbf{x}_{\varphi_0})\)</span> , 这可以通过验证 <span
class="math display">\[
\frac{1}{2\pi} \int_0^{2\pi} \frac{1 - r^2}{1 + r^2 - 2r\cos\varphi}
~\mathrm{d}\varphi = 1
\]</span> 以及当 <span class="math inline">\(r=1\)</span> 时, 对任意的
<span class="math inline">\(\varphi \neq 0\)</span>, 积分项 <span
class="math display">\[
\frac{1 - r^2}{1 + r^2 - 2r\cos\varphi} \equiv 0
\]</span></p>
]]></content>
      <categories>
        <category>偏微分方程</category>
      </categories>
      <tags>
        <tag>Laplace 方程</tag>
        <tag>Dirichlet 边界</tag>
        <tag>圆盘区域</tag>
        <tag>Fourier 级数</tag>
        <tag>Poisson 公式</tag>
      </tags>
  </entry>
  <entry>
    <title>一些复积分中的定理和公式</title>
    <url>/math/complex-analysis/%E4%B8%80%E4%BA%9B%E5%A4%8D%E7%A7%AF%E5%88%86%E4%B8%AD%E7%9A%84%E5%AE%9A%E7%90%86%E5%92%8C%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p><strong><em>参考文献: Gilbert Strang, Introduction to applied
mathematics</em></strong></p>
<h2 id="解析函数在曲线上的积分-cauchy-定理">解析函数在曲线上的积分:
Cauchy 定理</h2>
<p>首先, 我们先计算一些简单的复积分例子做一下热身:</p>
<div class="note primary no-icon"><h5 id="例-1">例 1</h5>
<p>函数 <span class="math inline">\(f(z) = z^2\)</span> 在圆 <span
class="math inline">\(\odot:z=Re^{i \theta}\)</span> 上的积分为 <span
class="math display">\[
\int_{\odot} f(z) ~\mathrm{d}z
= \int_{0}^{2\pi} R^2 e^{i2\theta} i R e^{i\theta} ~\mathrm{d}\theta
= \frac{R^3}{3} \left. e^{i3\theta}\right|_{0}^{2\pi}
= 0
\]</span></p>
<h5 id="例-2">例 2</h5>
<p>函数 <span class="math inline">\(f(z) = z^{1/2}\)</span> 在圆 <span
class="math inline">\(\odot:z=Re^{i \theta}\)</span> 上的积分为 <span
class="math display">\[
\int_{\odot} f(z) ~\mathrm{d}z
= \int_{0}^{2\pi} R^{1/2} e^{i\theta/2} i R e^{i\theta}
~\mathrm{d}\theta
= \frac{R^{3/2}}{3/2} \left. e^{i3\theta/2}\right|_{0}^{2\pi}
= -\frac{4}{3}R^{3/2}
\]</span></p>
<h5 id="例-3">例 3</h5>
<p>函数 <span class="math inline">\(f(z) = 1/z\)</span> 在圆 <span
class="math inline">\(\odot:z=Re^{i \theta}\)</span> 上的积分为 <span
class="math display">\[
\int_{\odot} f(z) ~\mathrm{d}z
= \int_{0}^{2\pi} \frac{1}{R e^{i\theta}} i R e^{i\theta}
~\mathrm{d}\theta
= 2\pi i
\]</span></p>
</div>
<span id="more"></span>
<p>上面的算例当然是特地设计的,
目的是引出一般的解析函数在闭曲线上的积分定理, 也即 <strong>Cauchy
定理</strong>:</p>
<div class="note success no-icon"><h5 id="cauchys-theorem">Cauchy's Theorem</h5>
<p>If <span class="math inline">\(f\)</span> is analytic in a simply
connected region containing the closed curve <span
class="math inline">\(C\)</span>, then <span class="math display">\[
\int_C f(z) \mathrm{d}z = 0
\tag{3}
\]</span></p>
</div>
<p>通过该定理, 我们可以直接得到例 1 的结果, 因为圆盘 <span
class="math inline">\(S:x^2 + y^2 \leq R^2\)</span> 包含曲线 <span
class="math inline">\(C\)</span>, 并且函数 <span
class="math inline">\(f(z)=z^2\)</span> 在 <span
class="math inline">\(S\)</span> 上是解析的.</p>
<p>例 2 和例 3 是作为 Cauchy 定理的补充说明:</p>
<ul>
<li>简单连通区域 (simply connected region)
是<strong>没有孔洞</strong>的区域. 例如, 函数 <span
class="math inline">\(f(z)=1/z\)</span> 在区域 <span
class="math inline">\(1/2 &lt; |z| &lt; 2\)</span> 之间是解析的,
并且该圆环区域包含圆 <span class="math inline">\(\odot\)</span> , 但是,
该区域不是简单连通的. 包含圆 <span class="math inline">\(\odot\)</span>
的区域必定包含点 <span class="math inline">\(z=0\)</span>, 而函数在
<span class="math inline">\(z=0\)</span> 处不是解析的. 之后会看到,
正是在这一点的奇异性, 使得 <span class="math inline">\(1/z\)</span>
在曲线 <span class="math inline">\(C\)</span> 上的积分不等于 0.</li>
<li>函数 <span class="math inline">\(f\)</span>
也必须是<strong>单值</strong>的, 否则式 (3) 的积分可能不等于 0,
我们已经通过例 3 说明了这一点.</li>
</ul>
<p>这一定理的证明需要用到解析函数最重要的性质:
<strong>解析函数的实部与虚部 <span class="math inline">\(u\)</span>
<span class="math inline">\(v\)</span>​ 满足 Cauchy-Riemann 条件</strong>
<span class="math display">\[
\boxed{
- \frac{\partial v}{\partial x} = \frac{\partial u}{\partial y}, \quad
\frac{\partial u}{\partial x} = \frac{\partial v}{\partial y}
}
\]</span> 我们将复积分 (3) 分成实部与虚部两部分: <span
class="math display">\[
\int_C f(z) ~\mathrm{d}z = \int_C (u + iv)(\mathrm{d}x + i\mathrm{d}y)
= \int_C u\mathrm{d}x - v\mathrm{d}y
+ i\int_C v\mathrm{d}x + u\mathrm{d}y
\]</span> 第二类曲线积分可以通过 Stokes 公式转换到曲线内部区域上的积分:
<span class="math display">\[
\int_C f_1 ~\mathrm{d}x + f_2 ~\mathrm{d}y
= \iint_{S} \mathrm{curl~}f ~\mathrm{d}x \mathrm{d}y, \quad
\mathrm{curl~}f = \begin{vmatrix}
\partial/\partial x &amp; \partial/\partial y \\
f_1 &amp; f_2
\end{vmatrix}
\]</span> 所以 <span class="math display">\[
\int_C u\mathrm{d}x - v\mathrm{d}y
= \iint_{S} - \frac{\partial v}{\partial x} - \frac{\partial u}{\partial
y} ~\mathrm{d}x\mathrm{d}y,\quad
\int_C v\mathrm{d}x + u\mathrm{d}y
= \iint_{S} \frac{\partial u}{\partial x} - \frac{\partial v}{\partial
y} ~\mathrm{d}x\mathrm{d}y
\]</span> 再根据 Cauchy-Riemann 条件, 就得到了定理式 (3) 的结论.</p>
<p>需要补充说明的是, Cauchy 定理反过来并不成立, 也即如果某一函数 <span
class="math inline">\(f\)</span> 对复平面任意环绕闭合曲线 <span
class="math inline">\(C\)</span> 的积分都等于 0, 这也不能确定函数 <span
class="math inline">\(f\)</span> 在复平面上就是解析的, 比如说:</p>
<div class="note primary no-icon"><h5 id="例-4">例 4</h5>
<p>函数 <span class="math inline">\(f(z) = 1/z^n\)</span>, <span
class="math inline">\(n&gt;1\)</span> 在圆 <span
class="math inline">\(\odot:z=Re^{i \theta}\)</span> 上的积分为 <span
class="math display">\[
\int_{\odot} f(z) ~\mathrm{d}z
= i R^{1-n} \int_{0}^{2\pi} e^{i (1-n)\theta} ~\mathrm{d}\theta
= 0
\]</span></p>
</div>
<h2 id="cauchy-积分公式">Cauchy 积分公式</h2>
<p>现在我们知道, 解析函数在闭合曲线上的积分结果等于 0.
接下来我们考察一下, 如果函数在闭合曲线 <span
class="math inline">\(C\)</span> 围成的区域 <span
class="math inline">\(S\)</span> 上个别点处不解析
(这样的点称为<strong>奇点</strong>),
那么沿闭合曲线积分会得到什么结果.</p>
<p>从例 2 可以看到, 在 <span class="math inline">\(z=0\)</span>
处不解析的函数 <span class="math inline">\(f(z) = 1/z\)</span>, 沿圆
<span class="math inline">\(C\)</span> 的积分等于 <span
class="math inline">\(2\pi i\)</span>, 与半径 <span
class="math inline">\(R\)</span> 无关. 所以可以合理地猜想
(虽然早就知道结论了), 是否对任意的环绕 <span
class="math inline">\(z=0\)</span> 的闭合曲线 <span
class="math inline">\(C\)</span>, <span
class="math inline">\(1/z\)</span> 的积分结果都是一样的呢? 有如下结论:
<span class="math display">\[
\boxed{
\int_C \frac{1}{z-a} ~\mathrm{d}z = 2\pi i, \quad \forall \text{~closed
curve~} C \text{~around~} a
}
\tag{8}
\]</span> 证明只需要看下面这一张图. 环绕圆 <span
class="math inline">\(\odot\)</span> 与曲线 <span
class="math inline">\(C\)</span> 的积分为 <span class="math display">\[
I = \int_C \frac{1}{z-a} ~\mathrm{d}z
- \int_{\odot} \frac{1}{z-a} ~\mathrm{d}z
\]</span> 同样, 该积分也可以看作是环绕图中阴影区域做的积分.
因为阴影区域不包含奇点, 所以根据 Cauchy 定理, 积分等于 0: <span
class="math display">\[
\int_C \frac{1}{z-a} ~\mathrm{d}z - \int_{\odot} \frac{1}{z-a}
~\mathrm{d}z = 0
\]</span>
<img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202405261829260.png" alt="image-20240526182910161" style="zoom: 50%;" /></p>
<p>上述证明过程同样也可以将例 4 的结果推广到任意环绕奇点的闭合曲线 <span
class="math inline">\(C\)</span> 上: <span class="math display">\[
\int_C \frac{1}{(z-a)^n} ~\mathrm{d}z = 0, \quad \forall n&gt;1
\]</span> 式 (8) 可以说是复积分中最重要的积分,
因为我们还可以将它进一步地推广. 对任意在区域 <span
class="math inline">\(S\)</span> 上解析的函数 <span
class="math inline">\(f(z)\)</span>, <span
class="math inline">\(f(z)/(z-a)\)</span> 在 <span
class="math inline">\(z=a\)</span> 处奇异. 但是我们可以构造函数 <span
class="math inline">\(F(z)\)</span>: <span class="math display">\[
F(z) = \frac{f(z) - f(a)}{z-a}
\]</span> 函数 <span class="math inline">\(F\)</span> 在 <span
class="math inline">\(z=a\)</span> 处是解析的 (用专业的术语说, <span
class="math inline">\(z=a\)</span> 是函数 <span
class="math inline">\(F(z)\)</span> 的可去奇点), 因此在区域 <span
class="math inline">\(S\)</span> 中, 包含奇点 <span
class="math inline">\(z=a\)</span> 的闭合曲线 <span
class="math inline">\(C\)</span> 上的积分等于 0: <span
class="math display">\[
\int_{C} F(z) ~\mathrm{d}z = 0 \quad \Rightarrow \quad
\int_C \frac{f(z)}{z-a} ~\mathrm{d}z - 2\pi i f(a) = 0
\]</span> 这样我们就得到了 <strong>Cauchy 积分公式:</strong></p>
<div class="note success no-icon"><h5 id="cauchys-integral-formula">Cauchy's integral formula</h5>
<p>If <span class="math inline">\(a\)</span> is any point inside the
simple closed curve <span class="math inline">\(C\)</span>, and <span
class="math inline">\(f\)</span> is analytic inside and on <span
class="math inline">\(C\)</span>, then <span class="math display">\[
f(a) = \frac{1}{2\pi i} \int_C \frac{f(z)}{z-a} ~\mathrm{d}z
\tag{10}
\]</span></p>
</div>
<p>以下摘自教材中对公式 (10) 的解释:</p>
<blockquote>
<p>To know <span class="math inline">\(f\)</span> on <span
class="math inline">\(C\)</span> is to know <span
class="math inline">\(f\)</span> everywhere inside; there is not much
freedom for analytic functions. Equation (8) was the special case <span
class="math inline">\(f=1\)</span>​.</p>
<p>知道 <span class="math inline">\(f\)</span> 在曲线 <span
class="math inline">\(C\)</span> 上的值, 就等于知道 <span
class="math inline">\(f\)</span> 在曲线内部每一点处的值.
对于解析函数而言, 没有太多可自由发挥的空间. 式 (8) 是上式 <span
class="math inline">\(f \equiv 1\)</span> 的特例.</p>
</blockquote>
<p>知道解析函数 <span class="math inline">\(f\)</span> 在曲线 <span
class="math inline">\(C\)</span> 上的值, 还可以确定内部每一点的导数值,
如果将式 (10) 看作是关于 <span class="math inline">\(a\)</span> 的函数,
两边对 <span class="math inline">\(a\)</span> 求导数得到 <span
class="math display">\[
f&#39;(a) = \frac{1}{2\pi i} \int_C \frac{f(z)}{(z-a)^2} ~\mathrm{d}z
\tag{12}
\]</span> 由此还可以推广到任意高阶导数. 所以说, 解析函数性质是非常好的,
但因此解析函数的性态会受到诸多限制. 应用 Cauchy 积分公式,
可以直接得到一些对一般解析函数定性上的限制, 比如说,</p>
<div class="note success no-icon"><h5 id="解析函数的极值原理">解析函数的极值原理</h5>
<p>如果函数 <span class="math inline">\(f\)</span> 是解析的, 那么 <span
class="math inline">\(|f|\)</span> 的最大值只会在边界上取到.</p>
</div>
<p>在这里我们只给出边界为圆的证明. 考虑以点 <span
class="math inline">\(z=a\)</span> 为中心, 半径为 <span
class="math inline">\(R\)</span> 的圆 <span
class="math inline">\(\odot\)</span>, 根据式 (10) 有 <span
class="math display">\[
f(a) = \frac{1}{2\pi } \int_{0}^{2\pi} f(a + R e^{i\theta})
~\mathrm{d}\theta
\]</span> 上式右端恰好等于 <span class="math inline">\(f(z)\)</span>
在圆 <span class="math inline">\(\odot\)</span> 上的积分平均. 因此,
除非在圆 <span class="math inline">\(\odot\)</span> 上 <span
class="math inline">\(f \equiv \mathrm{const}\)</span>,
否则必然存在某一点 <span class="math inline">\(z_0\)</span>, 使得 <span
class="math inline">\(|f(z_0)| &gt; |f(a)|\)</span>. 对上式取实部,
就可以用来说明 Laplace 方程的极值原理.</p>
<p>如果更进一步， 考虑式 (12) 在圆上的曲线积分: <span
class="math display">\[
f&#39;(a) = \frac{1}{2\pi i} \int_{\odot} \frac{f(z)}{(z-a)^2}
~\mathrm{d}z
= \frac{1}{2\pi} \int_{0}^{2\pi} \frac{f(a + R e^{i\theta})}{R
e^{i\theta}}  ~\mathrm{d}\theta
\]</span> 按照与极值原理证明相同的方法, 点 <span
class="math inline">\(a\)</span> 的导数模 <span
class="math inline">\(|f&#39;(a)| &lt; |f(z_0)|/R\)</span>, 其中 <span
class="math inline">\(z_0\)</span> 为任意环绕点 <span
class="math inline">\(a\)</span> 曲线上的某一点. 在对 <span
class="math inline">\(|f&#39;(a)|\)</span>
的估计式右端出现了与曲线尺寸相关的参数 (半径 <span
class="math inline">\(R\)</span>), 如果 <span
class="math inline">\(f\)</span> 在整个复平面有界, 那么 <span
class="math inline">\(|f&#39;(a)| &lt; C/R\)</span> 对任意 <span
class="math inline">\(R\)</span> 成立, 这就等价于 <span
class="math display">\[
f&#39;(a) \equiv 0, \quad \forall a \in \mathbb{C}
\]</span> 所以 <span class="math inline">\(f\)</span> 只能是常数. 这就是
Liouville 定理:</p>
<div class="note success no-icon"><h5 id="liouville-定理">Liouville 定理</h5>
<p>如果函数 <span class="math inline">\(f\)</span>
是在整个复平面上<strong>解析</strong>且<strong>有界</strong>, 那么 <span
class="math inline">\(f\)</span> 一定是常数.</p>
</div>
<p>Liouville 定理反过来可以说明, 如果函数 <span
class="math inline">\(f\)</span> 在整个复平面上有界, 并且不等于常数,
那么函数 <span class="math inline">\(f\)</span> 在复平面上必定存在极点.
例如, 函数 <span class="math inline">\(f(z) = 1/(1+z^2)\)</span>
在整个复平面上的模值小于等于 1. 虽然在实数轴上, 函数 <span
class="math inline">\(1/(1+x^2)\)</span> 都是有意义的,
但是如果放到整个复平面上来看, 函数 <span
class="math inline">\(f(z)\)</span> 存在两个极点, <span
class="math inline">\(z=i\)</span> 和 <span
class="math inline">\(z=-i\)</span>.</p>
]]></content>
      <categories>
        <category>复分析</category>
      </categories>
      <tags>
        <tag>Stokes 公式</tag>
        <tag>Cauchy 定理</tag>
        <tag>Cauchy 积分公式</tag>
        <tag>极值原理</tag>
        <tag>Liouville 定理</tag>
      </tags>
  </entry>
  <entry>
    <title>留数定理计算积分</title>
    <url>/math/complex-analysis/%E7%95%99%E6%95%B0%E5%AE%9A%E7%90%86%E8%AE%A1%E7%AE%97%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>复分析</category>
      </categories>
      <tags>
        <tag>留数定理</tag>
      </tags>
  </entry>
  <entry>
    <title>解析函数与 Laplace 方程</title>
    <url>/math/complex-analysis/%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E4%B8%8E-Laplace-%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<p><strong><em>参考文献: Gilbert Strang, Introduction to applied
mathematics</em></strong></p>
<p>在这篇文章中, 我将从求解微分方程出发, 只引入必要的复分析方法作为工具.
此外, 因为复数 <span class="math inline">\(z\)</span> <span
class="math display">\[
z = x + iy, \quad x,y \in \mathbb{R}
\]</span> 只包含两个实数变量,
所以方程的定解域也限制在二维平面上.<span id="more"></span></p>
<p>待求解的微分方程为 Laplace 方程: <span class="math display">\[
\frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} =
0
\]</span> 我们断言: <strong>函数 <span class="math inline">\(f(z) = f(x
+ iy)\)</span> 自动满足 Laplace 方程.</strong> 这是因为根据链式法则, 对
<span class="math inline">\(x\)</span> 的二阶偏导数为 <span
class="math display">\[
\frac{\partial f}{\partial x} = \frac{\mathrm{d}f}{\mathrm{d}z}
\frac{\partial z}{\partial x}
= \frac{\mathrm{d}f}{\mathrm{d}z}, \quad
\frac{\partial^2 f}{\partial x^2} = \frac{\mathrm{d}^2f}{\mathrm{d}z^2}
\frac{\partial z}{\partial x}
= \frac{\mathrm{d}^2f}{\mathrm{d}z^2}
\]</span> 而在对 <span class="math inline">\(y\)</span> 求偏导数时,
会多出 <span class="math inline">\(i^2 = -1\)</span> 的因子: <span
class="math display">\[
\frac{\partial f}{\partial y} = \frac{\mathrm{d}f}{\mathrm{d}z}
\frac{\partial z}{\partial y}
= i\frac{\mathrm{d}f}{\mathrm{d}z}, \quad
\frac{\partial^2 f}{\partial y^2} = (i^2)
\frac{\mathrm{d}^2f}{\mathrm{d}z^2}
= - \frac{\mathrm{d}^2f}{\mathrm{d}z^2}
\]</span> 所以有 <span class="math display">\[
i \frac{\partial f}{\partial x} = \frac{\partial f}{\partial y}, \quad
\frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} =
0
\tag{1}
\]</span> 但是, <span class="math inline">\(f(x+iy)\)</span>
给出的是复数形式的解, 而我们感兴趣的是实数域 <span
class="math inline">\((x,y) \in \mathbb{R}^2\)</span> 上的解. 事实上,
如果我们将函数 <span class="math inline">\(f\)</span>
写成实数与虚数两部分: <span class="math display">\[
f(x+iy) = u(x,y) + i v(x,y), \quad u,v: \mathbb{R}^2 \mapsto \mathbb{R}
\]</span> 那么 <span class="math inline">\(u\)</span>, <span
class="math inline">\(v\)</span> 均满足 Laplace 方程.</p>
<div class="note primary no-icon"><h5 id="验证-fz-的实部和虚部满足-laplace-方程">验证 <span
class="math inline">\(f(z)\)</span> 的实部和虚部满足 Laplace 方程</h5>
<p><span class="math display">\[
\frac{\partial^2 f}{\partial x^2} = \frac{\partial^2 u}{\partial x^2} +
i \frac{\partial^2 v}{\partial x^2}, \quad
\frac{\partial^2 f}{\partial y^2} = \frac{\partial^2 u}{\partial y^2} +
i \frac{\partial^2 v}{\partial y^2}, \quad
\Delta f = \Delta u + i\Delta v
\]</span></p>
<p>而函数 <span class="math inline">\(f\)</span> 满足 Laplace 方程, 所以
<span class="math display">\[
\Re (\Delta f)=0, \quad
\Im (\Delta f)=0
\]</span> 这就得到 <span class="math display">\[
\Delta u = 0, \quad \Delta v = 0
\]</span> 我们还可以验算一个不平凡的算例, 比如 <span
class="math inline">\(f(z) = z^3\)</span>, <span class="math display">\[
f(x+iy) = x^3-3xy^2 + i (3x^2y - y^3)
\]</span> 所以, 函数 <span class="math inline">\(f\)</span> 的实部 <span
class="math inline">\(u(x,y) = x^3 - 3xy^2\)</span> 验算结果为 <span
class="math display">\[
\frac{\partial^2 u}{\partial x^2} = 6x, \quad \frac{\partial^2
u}{\partial y^2} = -6x
\Rightarrow \Delta u = 0
\]</span> 以及函数 <span class="math inline">\(f\)</span> 的虚部 <span
class="math inline">\(v(x,y) = 3x^2y - y^3\)</span> 验算结果为 <span
class="math display">\[
\frac{\partial^2 v}{\partial x^2} = 6y, \quad \frac{\partial^2
v}{\partial y^2} = -6y
\Rightarrow \Delta v = 0
\]</span> 最后一个例子是在求解圆盘上的 Laplace 方程时,
我们给出解的级数形式为 <span class="math display">\[
u(r,\theta) = \frac{a_0}{2} + a_1 r \cos \theta + b_1 r \sin \theta
+ a_2 r^2 \cos 2\theta + b_2 r^2 \sin 2\theta
+ \cdots
\]</span> 级数项 <span class="math inline">\(r^n\cos n \theta\)</span>,
<span class="math inline">\(r^n \sin n\theta\)</span> 自动满足 Laplace
方程, 这是因为它们分别来自于 <span class="math inline">\(f(z) =
z^n\)</span> 的实部和虚部.</p>
</div>
<p>需要强调的是, <strong>并不是所有的函数都可以写成某一个关于复数 <span
class="math inline">\(z\)</span> 函数的实部或者虚部</strong>, 这样的话,
所有的函数都会满足 Laplace 方程, 那么求解该方程的行为就变成平凡的了.
例如函数 <span class="math inline">\(u(x,y) = x^2 + y^2\)</span>,
可以快速验证 <span class="math inline">\(\Delta u =4 \neq
0\)</span>.</p>
<div class="note info no-icon"><p>任意函数 <span class="math inline">\(f(x,y)\)</span> 均可以表示为
<span class="math inline">\(f(z,\bar z)\)</span>, 如果使用变量替换 <span
class="math display">\[
x = \frac{z + \bar z}{2}, \quad y = \frac{z - \bar z}{2i}
\]</span> 例如 <span class="math inline">\(u(x,y)=x^2 + y^2\)</span>
写成关于 <span class="math inline">\((z, \bar z)\)</span> 的函数为 <span
class="math inline">\(u(z, \bar z) = z \bar z\)</span>.</p>
</div>
<p>现在的问题是, 如果给定 <span class="math inline">\(u\)</span> 和
<span class="math inline">\(v\)</span>, 怎样才能确定组合 <span
class="math inline">\(u + iv\)</span> 是不是一个解析函数? 这就需要用到式
(1) 中一阶导数的结果: <span class="math display">\[
i \frac{\partial f}{\partial x} = \frac{\partial f}{\partial y}
\]</span> 将 <span class="math inline">\(f = u + iv\)</span> 代入得到
<span class="math display">\[
- \frac{\partial v}{\partial x} + i \frac{\partial u}{\partial x}
= \frac{\partial u}{\partial y} + i\frac{\partial v}{\partial y}
\]</span> 令方程左右两端实部与虚部分别相等, 就得到
<strong>Cauchy-Riemann 条件:</strong> <span class="math display">\[
\boxed{
- \frac{\partial v}{\partial x} = \frac{\partial u}{\partial y}, \quad
\frac{\partial u}{\partial x} = \frac{\partial v}{\partial y}
}
\]</span> 最终总结如下:</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202405192337811analytical.png" alt="image-20240519233712661" style="zoom: 67%;" /></p>
]]></content>
      <categories>
        <category>复分析</category>
      </categories>
      <tags>
        <tag>Laplace 方程</tag>
        <tag>解析函数</tag>
        <tag>Cauchy-Riemann 条件</tag>
      </tags>
  </entry>
  <entry>
    <title>德语中不规则动词变位分组</title>
    <url>/lang/%E5%BE%B7%E8%AF%AD%E4%B8%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E5%8F%98%E4%BD%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h2
id="不规则动词的过去时与过去分词词尾变化">不规则动词的过去时与过去分词词尾变化</h2>
<p>在介绍不规则动词变位之前,
首先介绍动词过去时与过去分词随人称的词尾变化. (第二)
过去分词<strong>不会再随人称发生变换</strong>,
但是不定式和过去时的动词的词尾还是会随人称变化的,
过去时的词尾变化一般为</p>
<table>
<thead>
<tr class="header">
<th>人称</th>
<th>词尾变化</th>
<th>人称</th>
<th>词尾变化</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ich</td>
<td>-</td>
<td>wir</td>
<td>-en</td>
</tr>
<tr class="even">
<td>du</td>
<td>-st</td>
<td>ihr</td>
<td>-t</td>
</tr>
<tr class="odd">
<td>er/sie/es</td>
<td>-</td>
<td>sie/Sie</td>
<td>-en</td>
</tr>
</tbody>
</table>
<p>不定式的词尾变化与过去时稍有不同, 这体现在第一和第三人称单数情景.
不定式第一人称单数 (ich) 词干后加 -e, 第三人称单数 (er/sie/es) 词干后加
-t, 而过去时的第一和第三人称单数词尾不加任何东西,
这有些类似于情态动词的词尾变化
(情态动词的现在时也是第一第三人称单数词尾相同).<span id="more"></span></p>
<h2 id="不规则动词变位分组">不规则动词变位分组</h2>
<p>按照不定式-过去时-过去分词中元音的变化规律, 一共分成如下七组动词:</p>
<h3 id="第一组动词">第一组动词</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">不定式 (ei)</th>
<th style="text-align: left;">过去时 (ie)</th>
<th style="text-align: left;">过去分词 (ie)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bleiben</td>
<td style="text-align: left;">blieb</td>
<td style="text-align: left;">(ist) geblieben</td>
</tr>
<tr class="even">
<td style="text-align: left;">schreiben</td>
<td style="text-align: left;">schrieb</td>
<td style="text-align: left;">geschrieben</td>
</tr>
<tr class="odd">
<td style="text-align: left;">treiben</td>
<td style="text-align: left;">trieb</td>
<td style="text-align: left;">getrieben</td>
</tr>
<tr class="even">
<td style="text-align: left;">steigen ==爬,上升==</td>
<td style="text-align: left;">stieg</td>
<td style="text-align: left;">(ist) gestiegen</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>vergleich</em></td>
<td style="text-align: left;"><em>verglich</em></td>
<td style="text-align: left;"><em>verglichen</em> ==比较, 对比==</td>
</tr>
</tbody>
</table>
<h3 id="第二组动词">第二组动词</h3>
<table>
<thead>
<tr class="header">
<th>不定式 (ie)</th>
<th>过去时 (o)</th>
<th>过去分词 (o)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fliegen</td>
<td>flog</td>
<td>geflogen</td>
</tr>
<tr class="even">
<td>riechen ==嗅, 闻==</td>
<td>roch</td>
<td>gerochen</td>
</tr>
<tr class="odd">
<td>schieben</td>
<td>schob</td>
<td>geschoben</td>
</tr>
<tr class="even">
<td>schließen</td>
<td>schloss</td>
<td>geschlossen</td>
</tr>
<tr class="odd">
<td>ziehen</td>
<td>zog</td>
<td>gezogen</td>
</tr>
<tr class="even">
<td>verbieten</td>
<td>verbot</td>
<td>verboten</td>
</tr>
</tbody>
</table>
<h3 id="第三组动词">第三组动词</h3>
<p>这一组动词类似于英语的变化, 过去分词元音有两种可能的变形: o oder
u</p>
<table>
<thead>
<tr class="header">
<th>不定式 (i)</th>
<th>过去时 (a)</th>
<th>过去分词 (o/u)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>beginnen</td>
<td>begann</td>
<td>begonnen</td>
</tr>
<tr class="even">
<td>gewinnen</td>
<td>gewann</td>
<td>gewonnen</td>
</tr>
<tr class="odd">
<td>schwimmen</td>
<td>schwamm</td>
<td>geschwommen</td>
</tr>
<tr class="even">
<td>finden</td>
<td>fand</td>
<td>gefunden</td>
</tr>
<tr class="odd">
<td>singen</td>
<td>sang</td>
<td>gesungen</td>
</tr>
<tr class="even">
<td>trinken</td>
<td>trank</td>
<td>getrunken</td>
</tr>
<tr class="odd">
<td>verbinden</td>
<td>verband</td>
<td>verbunden (连接, 包扎)</td>
</tr>
</tbody>
</table>
<h3 id="第四组动词">第四组动词</h3>
<table>
<thead>
<tr class="header">
<th>不定式 (e)</th>
<th>过去时 (a)</th>
<th>过去分词 (o)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>empfehlen</td>
<td>empfahl</td>
<td><strong>empfohlen</strong></td>
</tr>
<tr class="even">
<td>helfen</td>
<td>half</td>
<td>geholfen</td>
</tr>
<tr class="odd">
<td>nehmen</td>
<td>nahm</td>
<td>genommen</td>
</tr>
<tr class="even">
<td>sprechen</td>
<td>sprach</td>
<td>gesprochen</td>
</tr>
<tr class="odd">
<td>treffen ==遇见==</td>
<td>traf</td>
<td>getroffen</td>
</tr>
</tbody>
</table>
<h3 id="第五组动词">第五组动词</h3>
<table>
<thead>
<tr class="header">
<th>不定式 (i/ie/e)</th>
<th>过去时 (a)</th>
<th>过去分词 (e)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bitten</td>
<td>bat</td>
<td>gebeten</td>
</tr>
<tr class="even">
<td>liegen</td>
<td>lag</td>
<td>gelegen</td>
</tr>
<tr class="odd">
<td>sitzen</td>
<td>saß</td>
<td>gesessen</td>
</tr>
<tr class="even">
<td>essen</td>
<td>aß</td>
<td>gegessen</td>
</tr>
<tr class="odd">
<td>vergessen</td>
<td>vergaß</td>
<td>vergessen</td>
</tr>
<tr class="even">
<td>geben</td>
<td>gab</td>
<td>gegeben</td>
</tr>
<tr class="odd">
<td>lesen</td>
<td>laß</td>
<td>gelesen</td>
</tr>
<tr class="even">
<td>sehen</td>
<td>sah</td>
<td>gesehen</td>
</tr>
</tbody>
</table>
<h3 id="第六组动词">第六组动词</h3>
<table>
<thead>
<tr class="header">
<th>不定式 (a)</th>
<th>过去时 (u)</th>
<th>过去分词 (a)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ein/laden</td>
<td>lud ein</td>
<td>eingeladen</td>
</tr>
<tr class="even">
<td>fahren</td>
<td>fuhr</td>
<td>gefahren</td>
</tr>
<tr class="odd">
<td>waschen</td>
<td>wusch</td>
<td>gewaschen</td>
</tr>
</tbody>
</table>
<h3 id="第七组动词">第七组动词</h3>
<p>不定式与过去分词的<strong>元音相同</strong>, 过去时元音变为 ie/i</p>
<table>
<thead>
<tr class="header">
<th>不定式 (a/u/au/ei)</th>
<th>过去时 (ie/i)</th>
<th>过去分词 (a/u/au/ei)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>an/fangen</td>
<td>fing an</td>
<td>angefangen</td>
</tr>
<tr class="even">
<td>braten</td>
<td>briet</td>
<td>gebraten</td>
</tr>
<tr class="odd">
<td>gefallen</td>
<td>gefiel</td>
<td>gefallen</td>
</tr>
<tr class="even">
<td>hängen</td>
<td>hing</td>
<td>gehangen</td>
</tr>
<tr class="odd">
<td>heißen</td>
<td>hieß</td>
<td>geheißen</td>
</tr>
<tr class="even">
<td>laufen</td>
<td>lief</td>
<td>gelaufen</td>
</tr>
<tr class="odd">
<td>raten ==建议==</td>
<td>riet</td>
<td>geraten</td>
</tr>
<tr class="even">
<td>rufen</td>
<td>rief</td>
<td>gerufen</td>
</tr>
<tr class="odd">
<td>schlafen</td>
<td>schlief</td>
<td>geschlafen</td>
</tr>
</tbody>
</table>
<p>此外还有三组动词没有办法按照元音分类, 需要特别记忆.</p>
<h3 id="过去分词为--t-的强动词">过去分词为 -t 的强动词</h3>
<table>
<thead>
<tr class="header">
<th>不定式</th>
<th>过去时</th>
<th>过去分词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bringen</td>
<td>brachte</td>
<td>gebracht</td>
</tr>
<tr class="even">
<td>denken</td>
<td>dachte</td>
<td>gedacht</td>
</tr>
<tr class="odd">
<td>haben</td>
<td>hatte</td>
<td>gehabt</td>
</tr>
<tr class="even">
<td>kennen</td>
<td>kannte</td>
<td>gekannt</td>
</tr>
<tr class="odd">
<td>nennen</td>
<td>nannte</td>
<td>genannt</td>
</tr>
<tr class="even">
<td>rennen ==奔跑==</td>
<td>rannte</td>
<td>gerannt</td>
</tr>
<tr class="odd">
<td>wenden ==翻转==</td>
<td>wandte</td>
<td>gewandt</td>
</tr>
<tr class="even">
<td>wissen</td>
<td><strong>wusste</strong></td>
<td>gewusst</td>
</tr>
</tbody>
</table>
<h3 id="情态动词">情态动词</h3>
<table>
<thead>
<tr class="header">
<th>不定式</th>
<th>过去时</th>
<th>过去分词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dürfen</td>
<td>durfte</td>
<td>gedurft</td>
</tr>
<tr class="even">
<td>können</td>
<td>konnte</td>
<td>gekonnt</td>
</tr>
<tr class="odd">
<td>müssen</td>
<td>musste</td>
<td>gemusst</td>
</tr>
<tr class="even">
<td>sollen</td>
<td>sollte</td>
<td>gesollt</td>
</tr>
<tr class="odd">
<td>wollen</td>
<td>wollte</td>
<td>gewollt</td>
</tr>
<tr class="even">
<td>mögen</td>
<td>mochte</td>
<td>gemocht</td>
</tr>
</tbody>
</table>
<h3 id="非常不规则的动词">非常不规则的动词</h3>
<table>
<thead>
<tr class="header">
<th>不定式</th>
<th>过去时</th>
<th>过去分词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>gehen</td>
<td>ging</td>
<td>gegangen</td>
</tr>
<tr class="even">
<td>kommen</td>
<td>kam</td>
<td>gekommen</td>
</tr>
<tr class="odd">
<td>sein</td>
<td>war</td>
<td>gewesen</td>
</tr>
<tr class="even">
<td>stehen</td>
<td>stand</td>
<td>gestanden</td>
</tr>
<tr class="odd">
<td>tun</td>
<td>tat</td>
<td><strong>getan</strong></td>
</tr>
<tr class="even">
<td>werden</td>
<td>wurde</td>
<td>geworden</td>
</tr>
</tbody>
</table>
<h2 id="werden-sein-的动词变位">werden sein 的动词变位</h2>
<p>werden sein 动词的过去时随人称变化较大, 需要特别注意.</p>
<h4 id="werden-的动词变位">werden 的动词变位</h4>
<table>
<thead>
<tr class="header">
<th>人称</th>
<th>不定式</th>
<th>过去时</th>
<th>过去分词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ich</td>
<td>werde</td>
<td>wurde</td>
<td>geworden</td>
</tr>
<tr class="even">
<td>du</td>
<td>wirst</td>
<td>wurdest</td>
<td>geworden</td>
</tr>
<tr class="odd">
<td>er/sie/es</td>
<td>wird</td>
<td>wurde</td>
<td>geworden</td>
</tr>
<tr class="even">
<td>wir</td>
<td>werden</td>
<td>wurden</td>
<td>geworden</td>
</tr>
<tr class="odd">
<td>ihr</td>
<td>werdet</td>
<td>wurdet</td>
<td>geworden</td>
</tr>
<tr class="even">
<td>sie/Sie</td>
<td>werden</td>
<td>wurden</td>
<td>geworden</td>
</tr>
</tbody>
</table>
<h4 id="sein-的动词变位">sein 的动词变位</h4>
<table>
<thead>
<tr class="header">
<th>人称</th>
<th>不定式</th>
<th>过去时</th>
<th>过去分词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ich</td>
<td>bin</td>
<td>war</td>
<td>gewesen</td>
</tr>
<tr class="even">
<td>du</td>
<td>bist</td>
<td>warst</td>
<td>gewesen</td>
</tr>
<tr class="odd">
<td>er/sie/es</td>
<td>ist</td>
<td>war</td>
<td>gewesen</td>
</tr>
<tr class="even">
<td>wir</td>
<td>sind</td>
<td>waren</td>
<td>gewesen</td>
</tr>
<tr class="odd">
<td>ihr</td>
<td>seid</td>
<td>wart</td>
<td>gewesen</td>
</tr>
<tr class="even">
<td>sie/Sie</td>
<td>sind</td>
<td>waren</td>
<td>gewesen</td>
</tr>
</tbody>
</table>
<h2 id="使用-sein-引导完成时的常见动词">使用 sein
引导完成时的常见动词</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td>睡觉相关 <br />(一觉醒来竟与世界为敌)</td>
<td>aufstehen ==起床==; aufwachen ==睡醒==; einschlafen ==入睡==;</td>
</tr>
<tr class="even">
<td>走, 跑, 开车, 飞, 来,
爬<br />以及与之相关的可分动词<br />旅游常用</td>
<td>gehen: aus/ ==外出==<br />laufen: <br />fahren: ab/
==启程==<br />fliegen: ab/ ==起飞==<br />kommen: an/ ==抵达==; mit/
==一起去==<br />steigen: aus/ ==下车==; um/ ==换乘==</td>
</tr>
<tr class="odd">
<td>运动</td>
<td>schwimmen; spazieren<br /><em>hat gejoggt</em></td>
</tr>
<tr class="even">
<td>搬家</td>
<td>umziehen ==搬家==; ausziehen ==搬出去==</td>
</tr>
<tr class="odd">
<td>逗留某地</td>
<td>sein: ich bin gewesen.<br />bleiben: ich bin geblieben.</td>
</tr>
<tr class="even">
<td>发生肾么事了</td>
<td>passieren: Was ist denn passiert?<br />explodieren ==爆炸==</td>
</tr>
<tr class="odd">
<td>生老病死</td>
<td>waschen ==成长==; sterben ==逝世==</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>动词变位</tag>
      </tags>
  </entry>
  <entry>
    <title>德语中只跟第三格和第四格的介词</title>
    <url>/lang/%E5%BE%B7%E8%AF%AD%E4%B8%AD%E5%8F%AA%E8%B7%9F%E7%AC%AC%E4%B8%89%E6%A0%BC%E5%92%8C%E7%AC%AC%E5%9B%9B%E6%A0%BC%E7%9A%84%E4%BB%8B%E8%AF%8D/</url>
    <content><![CDATA[<p>主要参考:</p>
<ul>
<li>德语语法活学活用, Friederike Jin, Ute Voß</li>
<li>实用英语德语比较语法, 芦力军, 外研社</li>
</ul>
<h3 id="只跟第三格的介词">只跟第三格的介词</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>aus</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作为<strong>空间介词</strong>, 基本含义是: 从某个封闭空间中出来,
类似于 out of</td>
<td>Die Mutter nimmt die Wäsche <strong>aus</strong> dem Korb.
==篮子==</td>
</tr>
<tr class="even">
<td>表示来自于某个地方, 类似于 come from, 中性国家,
以及城市之前不加冠词</td>
<td>Ich komme <strong>aus</strong> China/JiangSu/der Schweiz.</td>
</tr>
<tr class="odd">
<td>来自于某个时代</td>
<td>Er singt ein Lied <strong>aus</strong> alten Zeiten.</td>
</tr>
<tr class="even">
<td>由 … 做成, 类似于 made out of</td>
<td>Ich kaufe einen Koffer <strong>aus</strong> Holz.
<br />==我买了一个木制的箱子==</td>
</tr>
<tr class="odd">
<td>表示原因</td>
<td>Er half ihr <strong>aus</strong> Mitleid. ==同情==</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>von</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作为<strong>空间介词</strong>, 基本含义是: 从 … 过来, 但语感上不像
aus 那么具体, 指代大方向</td>
<td>von der Schule / dem Arzt / dem Strand ==海滩== / dem Fußballplatz /
Tomas / dem Picknick / zu Hause</td>
</tr>
<tr class="even">
<td>还可以与其它介词 (bis nach zu) 连用, 表示从 … 到 …</td>
<td>1. Das Auto fährt <strong>von</strong> Leipzig <strong>bis</strong>
Dresden. <br />2. Wir fliegen <strong>von</strong> Berlin
<strong>nach</strong> Moskau.<br />3. Das Kind läuft
<strong>vom</strong> Vater <strong>zur</strong> Mutter.</td>
</tr>
<tr class="odd">
<td>作为<strong>时间介词</strong>, 基本含义是: 从 … 开始, 还可以与 bis
连用, 表示一段时间区间</td>
<td>1. <strong>Von</strong> wann <strong>bis</strong> wann …<br />2.
<strong>Von</strong> acht Uhr <strong>ab</strong> bin ich wieder zu
Hause.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>zu</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作为<strong>空间介词</strong>, 基本含义是: 到 … 去. zu 后的地点更
“日常化”<br /><strong><em>! 注意与 nach 进行区分</em></strong></td>
<td>1. Wir gehen <strong>zum</strong> Bahnhof / Station.<br />2. Heute
fahren wir <strong>zu</strong> meinen Eltern / dem Arzt / der
Nachbarin.<br />3. Kommt ihr heute <strong>Zum</strong> Frühstück /
Abendessen?</td>
</tr>
<tr class="even">
<td>zu 也可以作为<strong>时间介词</strong>, 表示在 … 时候</td>
<td>1. Zum Frühstück esse ich immer ein Ei.<br />2. Er hat uns zum
Jahresende besucht.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>nach</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作为<strong>空间介词</strong>, 基本含义是: 到 … 去, 后面一般跟 国家
城市 方向<br /><strong><em>! 注意与 zu 进行区分</em></strong></td>
<td>1. Ich möchte nach Deutschland fahren.<br />2. Wir fahren nach
Süden. ==南方==</td>
</tr>
<tr class="even">
<td>作为<strong>时间介词</strong>, 基本含义是在 … 之后</td>
<td>Nach dem Essen geht sie immer spazieren.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>bei</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作为<strong>空间介词</strong>, 基本含义是: 在 … 旁边</td>
<td>1. Er saß bei seiner Freundin.<br />2. Das Haus steht bei einem
Springbrunnen.<br />3. Sie wohnt bei ihren Eltern.<br />4. Augsburg
liegt bei München.</td>
</tr>
<tr class="even">
<td>引申义有在 … 情况下</td>
<td>Bei Regen fällt die Veranstaltung aus.</td>
</tr>
<tr class="odd">
<td>以及 在 … 时候</td>
<td>Beim Essen soll man nicht sprechen.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>mit</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mit 类似于英语的 with, 后面加人表示和 … 一起, 加物表示工具</td>
<td>1. Ich fahre mit meinem Freund in den Urlaub.<br />2. Ich schreibe
mit dem Bleistift.<br />3. Wir fahren mit dem Bus.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>seit</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作为时间介词, 表示 从 … 以来, 持续到至今, 也许一直持续下去</td>
<td>1. Seit drei Monaten liegt seine Frau im Krankenhaus.<br />2. Seit
einem Jahr wohne ich in Berlin.</td>
</tr>
</tbody>
</table>
<h3 id="只跟第四格的介词">只跟第四格的介词</h3>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th>für</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>表示目的<br /><strong><em>$ 与英语中的 for 作对比</em></strong></td>
<td>1. Dieses Geschenk ist für meinen Bruder.<br />2. Der Fisch ist für
dich!</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>durch</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作为空间介词, 基本的含义是穿过</td>
<td>Wir fahren mit dem Bus durch diese Stadt.</td>
</tr>
<tr class="even">
<td>作为时间介词, 表示经过一段时间 (或者从空间介词的意义上理解, “穿过”
一段时间)</td>
<td>Die Soldaten marschierten durch die ganze Nacht.
==战士整夜行军==</td>
</tr>
<tr class="odd">
<td>通过 ( 考试, 对话 ) 等引申义</td>
<td>Ich bin durch die Prüfung gefallen.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>um</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>空间介词中最基本的含义是 环绕</td>
<td>1. Der Wagen ==汽车== fährt um die Ecke.<br />2. Die Studenten sind
um den Dozenten versammelt.<br />一些可分动词也体现环绕的含义: um/fahren
==绕…而行== um/fangen ==抱住== um/hören ==向许多人闻询== um/schauen
==环视==</td>
</tr>
<tr class="even">
<td>作为时间介词, 后面加钟表时间</td>
<td>Kommen Sie bitte um 10 Uhr.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>gegen</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作为空间介词, 表示对抗与冲撞的方向</td>
<td>1. Das Auto ist gegen einen Baum gefahren.<br />2. Er schlug mit der
Faust ==拳头== gegen die Tür.</td>
</tr>
<tr class="even">
<td>作为空间介词, 表示大约</td>
<td>Der Zug kommt gegen 19.00 Uhr an.</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>ohne</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>类似于英语中的 without<br /><strong>! ohne
后面名词一般不加冠词</strong></td>
<td>1. Das Zimmer kostet ohne Frühstück 5.00 Euro.<br />2. Er fährt ohne
seine Kinder in den Urlaub.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于 Hause 的固定搭配</p>
<table>
<thead>
<tr class="header">
<th>问句</th>
<th>回答</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Wo bist du?</td>
<td>Ich bin <strong>zu Hause</strong>. ==我在家==</td>
</tr>
<tr class="even">
<td>Woher kommst du?</td>
<td>Ich komme von <strong>zu Hause</strong>. ==我从家过来==</td>
</tr>
<tr class="odd">
<td>Wohin gehst du?</td>
<td>Ich gehe <strong>nach Hause</strong>. ==我回家==</td>
</tr>
</tbody>
</table>
</blockquote>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>德语介词</tag>
      </tags>
  </entry>
  <entry>
    <title>德语动词相关语法点</title>
    <url>/lang/%E5%BE%B7%E8%AF%AD%E5%8A%A8%E8%AF%8D%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95%E7%82%B9/</url>
    <content><![CDATA[<h2 id="加第三格补足语的常见动词">加第三格补足语的常见动词</h2>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>动词</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>danken</td>
<td>Er <strong>dankt</strong> mir für das Geburtstagsgeschenk.</td>
</tr>
<tr class="even">
<td>fehlen</td>
<td>Ein Spieler <strong>fehlt</strong> uns./Uns <strong>fehlt</strong>
noch ein Spieler.<br />Deutschland <strong>gefällt</strong> mir sehr
gut. Aber meine Heimat und meine Freunde <strong>fehlen</strong> mir
sehr.</td>
</tr>
<tr class="odd">
<td>helfen</td>
<td>Ich muss Sabina (ihr) bei ihrer Hausaufgabe
<strong>helfen</strong></td>
</tr>
<tr class="even">
<td>antworten</td>
<td>Der Lehrer fragt den Schüler. Aber er <strong>antwortet</strong> ihm
nicht.</td>
</tr>
<tr class="odd">
<td>gratulieren</td>
<td>Sigrid hat heute Geburtstag. Wir müssen ihr
<strong>gratulieren</strong>.</td>
</tr>
<tr class="even">
<td>glauben</td>
<td>Martin lügt immer. Ich <strong>glaube</strong> ihm kein einziges
Wort mehr.</td>
</tr>
<tr class="odd">
<td>zuhören ==仔细听==</td>
<td>Ich werde wütend ==生气的==, wenn du mir nicht
<strong>zuhörst</strong>!</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<p>这其中还有一类特殊的动词, 是物作为主语, 因此单独列出来</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>动词</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>passen</td>
<td>Der Pullover <strong>passt</strong> meinem Mann gut.</td>
</tr>
<tr class="even">
<td>gefallen</td>
<td>Die Farbe <strong>gefällt</strong> ihm auch sehr.</td>
</tr>
<tr class="odd">
<td>schmecken</td>
<td>Deine Obsttorte ==水果馅饼== <strong>schmeckt</strong> meinem Mann
außerordentlich gut.</td>
</tr>
<tr class="even">
<td>gehört</td>
<td>Von wem ist das Buch? Astrid, <strong>gehört</strong> es dir?</td>
</tr>
<tr class="odd">
<td>stehen</td>
<td>Blau <strong>steht</strong> dir sehr gut!</td>
</tr>
</tbody>
</table>
<p>以及类似结构的常用表达方式:</p>
<ul>
<li>Es tut <strong>mir</strong> leid.</li>
<li>Wie geht es <strong>Ihnen</strong>?</li>
</ul>
<h2 id="支配双宾语的动词">支配双宾语的动词</h2>
<p>支配双宾语的动词, 宾语的摆放顺序为: <strong>名三四, 代四三,
代词放在名词前.</strong></p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>动词</th>
<th>例句 (三格使用( )圈出, 四格使用<u>下划线</u>表示)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>schreiben</td>
<td>Der Mann schreibt (seiner Freundin) <u>eine E-Mail</u>.</td>
</tr>
<tr class="even">
<td>geben</td>
<td>Dr. König gebt (deiner Frau) <u>Tabletten</u>. ==药片, pl.==</td>
</tr>
<tr class="odd">
<td>zeigen</td>
<td>Wir zeigen (den Gästen) <u>das Haus</u>.</td>
</tr>
<tr class="even">
<td>kaufen</td>
<td>Der Vater kauft (dem Sohn) <u>einen Computer</u>.</td>
</tr>
<tr class="odd">
<td>schenken</td>
<td>Die Mutter schenkt (der Tochter) <u>eine Puppe</u>.</td>
</tr>
<tr class="even">
<td>verkaufen</td>
<td>Ich verkaufe (meinem Freund) <u>ein Auto</u>.</td>
</tr>
<tr class="odd">
<td>servieren</td>
<td>Er serviert (seinen Freunden) <u>Kaffee</u>.</td>
</tr>
<tr class="even">
<td>kochen</td>
<td>Sie kocht (dem Kind) <u>eine Suppe</u>.</td>
</tr>
<tr class="odd">
<td>bringen</td>
<td>Er bringt (uns) <u>das Essen</u>.</td>
</tr>
<tr class="even">
<td>empfehlen</td>
<td>Sie empfiehlt (mir) <u>den Roman</u>.</td>
</tr>
<tr class="odd">
<td>erklären</td>
<td>Erklärst du (ihm) <u>die Grammatik</u>?</td>
</tr>
<tr class="even">
<td>wünschen</td>
<td>Ich wünsche (dir) <u>einen Guten Tag</u>!</td>
</tr>
</tbody>
</table>
<h2 id="与介词搭配的动词">与介词搭配的动词</h2>
<p>动词与介词的搭配, 支配第四格</p>
<table>
<thead>
<tr class="header">
<th>动词</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sich freuen <strong>auf</strong> (未来的事情)</td>
<td></td>
</tr>
<tr class="even">
<td>sich freuen <strong>über</strong> (过去或现在发生的事情)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="静态-动态动词对">静态-动态动词对</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWFzeWdlcm1hbmdyYW1tYXJzdG9yaWVzLmRlL2dyYW1tYXRpay9zZXR6ZW4tc3RlbGxlbi1sZWdlbi1oYWVuZ2VuLw==">setzen,
stellen, legen, sitzen, stehen, liegen, hängen<i class="fa fa-external-link-alt"></i></span></p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>静态</th>
<th>例句</th>
<th>动态</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="https://www.easygermangrammarstories.de/attachments/Image/liegen-wo.jpg?template=generic" alt="liegen - wo?" style="zoom:50%;" /></td>
<td>Das Buch <strong>liegt</strong> <u>auf dem Bett</u>.<br />Das Buch
hat <u>auf dem Bett</u> <strong>gelegen</strong>.</td>
<td><img src="https://www.easygermangrammarstories.de/attachments/Image/legen-wohin.jpg?template=generic" alt="legen - wohin?" style="zoom: 50%;" /></td>
<td>Die Frau <strong>legt</strong> das Buch <u>auf das
Bett</u>.<br />Die Frau hat das Buch <u>auf das Bett</u>
<strong>gelegt</strong>.</td>
</tr>
<tr class="even">
<td><img src="https://www.easygermangrammarstories.de/attachments/Image/haengen-wo-intransitiv.jpg?template=generic" alt="hängen (intransitiv) wo?" style="zoom:50%;" /></td>
<td>Das Bild <strong>hängt</strong> <u>an der Wand</u>.<br />Das Bild
hat <u>an der Wand</u> <strong>gehangen</strong>.</td>
<td><img src="https://www.easygermangrammarstories.de/attachments/Image/haengen-wohin-transitiv.jpg?template=generic" alt="hängen (transitiv) wohin?" style="zoom:50%;" /></td>
<td>Die Frau <strong>hängt</strong> das Bild <u>an die
Wand</u>.<br />Die Frau hat das Bild <u>an die Wand</u>
<strong>gehängt</strong>.</td>
</tr>
<tr class="odd">
<td><img src="https://www.easygermangrammarstories.de/attachments/Image/stehen-wo.jpg?template=generic" alt="stehen - wo?" style="zoom:50%;" /></td>
<td>Die Vase <strong>steht</strong> <u>auf dem Tisch</u>.<br />Die Vase
hat <u>auf dem Tisch</u> <strong>gestanden</strong>.</td>
<td><img src="https://www.easygermangrammarstories.de/attachments/Image/stellen-wohin_1.jpg?template=generic" alt="stellen - wohin?" style="zoom:50%;" /></td>
<td>Die Frau <strong>stellt</strong> die Vase <u>auf den
Tisch</u>.<br />Die Frau hat die Vase <u>auf den Tisch</u>
<strong>gestellt</strong>.</td>
</tr>
<tr class="even">
<td><img src="https://www.easygermangrammarstories.de/attachments/Image/sitzen-wo_1.jpg?template=generic" alt="sitzen - wo?" style="zoom:50%;" /></td>
<td>Das Kind <strong>sitzt</strong> <u>auf dem Stuhl</u>.<br />Das Kind
hat auf dem Stuhl <strong>gesessen</strong>.</td>
<td><img src="https://www.easygermangrammarstories.de/attachments/Image/setzen-wohin.jpg?template=generic" alt="setzen - wohin?" style="zoom:50%;" /></td>
<td>Die Frau <strong>setzt</strong> das Kind <u>auf den
Stuhl</u>.<br />Die Frau hat das Kind <u>auf den Stuhl</u>
<strong>gesetzt</strong>.</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>德语动词</tag>
      </tags>
  </entry>
  <entry>
    <title>德语语法点拾碎</title>
    <url>/lang/%E5%BE%B7%E8%AF%AD%E8%AF%AD%E6%B3%95%E7%82%B9%E6%8B%BE%E7%A2%8E/</url>
    <content><![CDATA[<h2 id="物主代词和人称代词">物主代词和人称代词</h2>
<table>
<thead>
<tr class="header">
<th>第一格</th>
<th>第四格</th>
<th>第三格</th>
<th>物主代词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ich</td>
<td>mich</td>
<td>mir</td>
<td>mein-</td>
</tr>
<tr class="even">
<td>du</td>
<td>dich</td>
<td>dir</td>
<td>dein-</td>
</tr>
<tr class="odd">
<td>er</td>
<td>ihn</td>
<td>ihm</td>
<td>sein-</td>
</tr>
<tr class="even">
<td>es</td>
<td>es</td>
<td>ihm</td>
<td>sein-</td>
</tr>
<tr class="odd">
<td>sie</td>
<td>sie</td>
<td>ihr</td>
<td>ihr-</td>
</tr>
<tr class="even">
<td>Sie</td>
<td>Sie</td>
<td>Ihnen</td>
<td>Ihr-</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>第一格</th>
<th>第四格</th>
<th>第三格</th>
<th>物主代词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wir</td>
<td>uns</td>
<td>uns</td>
<td>unser-</td>
</tr>
<tr class="even">
<td>ihr</td>
<td>euch</td>
<td>euch</td>
<td>euer-</td>
</tr>
<tr class="odd">
<td>sie</td>
<td>sie</td>
<td>ihnen</td>
<td>ihr-</td>
</tr>
<tr class="even">
<td>Sie</td>
<td>Sie</td>
<td>Ihnen</td>
<td>Ihr-</td>
</tr>
</tbody>
</table>
<p>物主代词除了要记住词干随人称的变化形式之外, 还要注意词尾的变化,
这与冠词的词尾变化是一样的.<span id="more"></span></p>
<h2 id="不定代词-man-和-ein-">不定代词 man 和 ein-</h2>
<p>不定代词 man 类似于 “人们”, “人家”, 虽然表示一群人的概念,
但是动词变位仍是<strong>第三人称单数</strong>. man 是有格的变化的:</p>
<table>
<thead>
<tr class="header">
<th>Nom.</th>
<th>Akk.</th>
<th>Dat.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>man</td>
<td>einen</td>
<td>einem</td>
</tr>
</tbody>
</table>
<p><strong>z.B.</strong> Bei Frau Kant gibt es so viele Verbote.
<strong>Man</strong> darf fast ganz nichts machen. Das geht
<strong>einem</strong> ganz schön auf die Nerven.</p>
<p>ein- kein- 表示前文提到的, 泛指的单数/否定代词, 词性与前文保持一致,
格的变化需要看代词所在的语境. 关于格和单复数的变化规律为:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>阳性</th>
<th>中性</th>
<th>阴性</th>
<th>复数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nom.</td>
<td>einer keiner</td>
<td>eins keins</td>
<td>eine keine</td>
<td>- keine</td>
</tr>
<tr class="even">
<td>Akk.</td>
<td>einen keinen</td>
<td>eins keins</td>
<td>eine keine</td>
<td>- keine</td>
</tr>
<tr class="odd">
<td>Dat.</td>
<td>einem keinem</td>
<td>einem keinem</td>
<td>einer keiner</td>
<td>- keinen</td>
</tr>
</tbody>
</table>
<h2 id="关于-hause-的固定搭配">关于 Hause 的固定搭配</h2>
<table>
<thead>
<tr class="header">
<th>问句</th>
<th>回答</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Wo bist du?</td>
<td>Ich bin <strong>zu Hause</strong>. ==我在家==</td>
</tr>
<tr class="even">
<td>Woher kommst du?</td>
<td>Ich komme von <strong>zu Hause</strong>. ==我从家过来==</td>
</tr>
<tr class="odd">
<td>Wohin gehst du?</td>
<td>Ich gehe <strong>nach Hause</strong>. ==我回家==</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>德语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>韦伯谈学者的人格</title>
    <url>/lang/%E9%9F%A6%E4%BC%AF%E8%B0%88%E5%AD%A6%E8%80%85%E7%9A%84%E4%BA%BA%E6%A0%BC/</url>
    <content><![CDATA[<p>在《学术作为一种志业》演讲中，韦伯谈到了个性（Persönlichkeit），并与流行观念中的个人体验（Erleben）进行辨析：</p>
<blockquote>
<p>今天我们在每一个街角和每一份杂志里，都可看到这种偶像崇拜。这些偶像就是「个性」和「个人体验」。两者有着密切的联系，占上风的想法是，后者就等于前者并隶属于前者。人们不畏困苦，竭力要「有所体验」，因为这就是「个性」应有的生活风格，如果没有成功，至少也要装成有这种天纵之才的样子。过去人们只把这称为「体会」或——用老百姓的德语说——「感觉」。我想，对于「个性」是什么东西，它意味着什么，人们已经有了更为恰当的理解。</p>
<p>《学术与政治》——韦伯，冯克利译本（以下简称<strong>冯本</strong>）</p>
</blockquote>
<span id="more"></span>
<p>在另一个译本中（钱永祥等，广西师范大学出版社，2004，以下简称<strong>广本</strong>），Persönlichkeit
被翻译为「人格」：</p>
<blockquote>
<p>我们从事学术研究时是否有灵感，靠的是人所不能测知的命运，此外就是靠「天赋」。目前流行一种心态，把这项无可置疑的真理，变成崇拜偶像的借口，这些偶像就是「人格」与「个人体验」。这种崇拜充斥大街小巷与各种报刊，在年轻人的圈子里，尤为风行，这是可以理解的。这两个偶像彼此紧密联系在一起：一般认为，「个人体验」构成人格，并为人格本质的一部分。于是人们使尽解数，努力去「体验」生活。因为他们相信，这才是一个「人格」应有的生活方式。即使「体验」生活没有成功，也得装出一副有异禀的样子。从前德文把「个人体验」称为「感动」，我认为在当时人们对人格及其代表的意义，有更恰当的了解。</p>
</blockquote>
<p>对比一下，感觉冯的译本翻译更加流畅，但也正因为流畅，稍微牺牲了一点点准确度；广本的翻译更直接一些。比如这一句：</p>
<blockquote>
<p>Beide sind eng verbunden: die Vorstellung herrscht, das letztere
mache die erstere aus und gehöre zu ihr.</p>
</blockquote>
<p>aus/machen
由……构成，或者在这里可以翻译为：个人体验是个性的要素。冯的译本感觉没有把这两者的关系翻译清楚。</p>
<p>还有这一个词：感觉（Sensation），德语中直译为感觉的词语还有
Empfindung 和 Gefühl，Sensation
相对于这两个词语，似乎更多了一层情感上的强烈的刺激，可以对比这些例句：</p>
<blockquote>
<p>Dieses Gefühl(Diese Empfindung) ist kaum ausdrückbar.
这种感情难以言表</p>
<p>Der erste Flug zum Mond war eine echte Sensation.
首次飞往月球是一件真正轰动的事件</p>
</blockquote>
<p>所以，相对于冯本中的「感觉」，我认为广本中的「感动」更能表现出体验带来的情绪上的刺激。</p>
<p>再说这一句</p>
<blockquote>
<p>Früher nannte man dieses „Erlebnis“ auf deutsch: „Sensation“. Und von
dem, was „Persönlichkeit“ sei und bedeute, hatte man eine – ich glaube –
zutreffendere Vorstellung.</p>
</blockquote>
<p>我认为冯本对这句的翻译自由发挥得过了头，Erleben 是动词 erleben
直接大写首字母，作为表示这个动作本身的名词，与 Erlebnis
语感上差别不太大，冯本是将 Erleben 和 Sensation
看作是不需要区别词义的近义词。最后的 “hatte man eine zutreffendere
Vorstellung”，我认为冯本中的「已经」没有突出过去与现在的对比状况。</p>
<p>讲了这么多冯本的坏话，还是得夸一下它：我觉得「天纵之才」这句翻译真是太妙了。</p>
<p>最后再把这一段的原文给贴上：</p>
<blockquote>
<p>Nun: ob jemand wissenschaftliche Eingebungen hat, das hängt ab von
uns verborgenen Schicksalen, außerdem aber von „Gabe“. Nicht zuletzt auf
Grund jener zweifellosen Wahrheit hat nun eine ganz begreiflicherweise
gerade bei der Jugend sehr populäre Einstellung sich in den Dienst
einiger Götzen gestellt, deren Kult wir heute an allen Straßenecken und
in allen Zeitschriften sich breit machen finden. Jene Götzen sind: die
„Persönlichkeit“ und das „Erleben“. Beide sind eng verbunden: die
Vorstellung herrscht, das letztere mache die erstere aus und gehöre zu
ihr. Man quält sich ab, zu „erleben“, – denn das gehört ja zur
standesgemäßen Lebensführung einer Persönlichkeit –, und gelingt es
nicht, dann muß man wenigstens so tun, als habe man diese Gnadengabe.
Früher nannte man dieses „Erlebnis“ auf deutsch: „Sensation“. Und von
dem, was „Persönlichkeit“ sei und bedeute, hatte man eine – ich glaube –
zutreffendere Vorstellung.</p>
</blockquote>
<p>下一段，我的感觉是两个译本意思差别不大，冯本要更流畅一些。相较之下，我更喜欢冯的译本。</p>
<blockquote>
<p><em>冯本</em></p>
<p>女士们，先生们！在科学的领地，个性是只有那些全心服膺他的学科要求的人才具备的，不唯在科学中如此。我们不知道有哪位伟大的艺术家，他除了献身于自己的工作，完全献身于自己的工作，还会做别的事情。即使具有歌德那种层次的人格，如果仅就他的艺术而言，如果他任性地想把自己的「生活」也变成一件艺术品，后果会不堪设想。若是有人对此有所怀疑，那就让他至少把自己当作歌德试试看吧。人们至少会同意，即使像他这种千年一遇的人物，这样的任性也要付出代价。</p>
</blockquote>
<blockquote>
<p><em>广本</em></p>
<p>各位贵宾们！在学问的领域里，唯有那纯粹向具体工作献身的人，才有「人格」。不仅研究学问如此，就我们所知，伟大的艺术家，没有一个不是把全部心力放在工作上；工作就是他的一切。就艺术家的艺术而论，即使「人格」伟大如歌德者，要想把「生活」变成一件艺术品，都会对艺术造成伤害。如果有人怀疑这一点，他必须是歌德，才能胆敢让自己拥有这种自由。至少，每个人都会同意，即使在像歌德这种千年一见的人身上，这种自由也必须付出代价。</p>
</blockquote>
<blockquote>
<p><em>原文</em></p>
<p>Verehrte Anwesende! „Persönlichkeit“ auf wissenschaftlichem Gebiet
hat nur der, der rein der Sache dient. Und nicht nur auf
wissenschaftlichem Gebiet ist es so. Wir kennen keinen großen Künstler,
der je etwas anderes getan hätte, als seiner Sache und nur ihr zu
dienen. Es hat sich, soweit seine Kunst in Betracht kommt, selbst bei
einer Persönlichkeit vom Range Goethes gerächt, daß er sich die Freiheit
nahm: sein „Leben“ zum Kunstwerk machen zu wollen. Aber mag man das
bezweifeln, – jedenfalls muß man eben ein Goethe sein, um sich das
überhaupt erlauben zu dürfen, und wenigstens das wird jeder zugeben:
unbezahlt ist es auch bei jemand wie ihm, der alle Jahrtausende einmal
erscheint, nicht geblieben.</p>
</blockquote>
<p>接下来的这一段，作为警句自省：</p>
<blockquote>
<p>Auf dem Gebiet der Wissenschaft aber ist derjenige==这个人== ganz
gewiß==一定== keine „Persönlichkeit“, der als Impresario der Sache, der
er sich hingeben==奉献== sollte, mit auf die Bühne==舞台== tritt, sich
durch „Erleben“ legitimieren==确认合法== möchte und fragt: Wie
beweise==证实== ich, daß ich etwas anderes bin als nur ein „Fachmann“,
wie mache ich es, daß ich, in der Form oder in der Sache, etwas sage,
das so noch keiner gesagt hat wie ich.</p>
</blockquote>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>韦伯</tag>
        <tag>学术与政治</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令与常见问题</title>
    <url>/dict/Git-%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="git-阅读材料">Git 阅读材料</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3Yy">Pro Git<i class="fa fa-external-link-alt"></i></span>
看到所有的网站都推荐阅读这一本书，当作手册来查；</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9taXNzaW5nLmNzYWlsLm1pdC5lZHUvMjAyMC92ZXJzaW9uLWNvbnRyb2wv">Missing
CS<i class="fa fa-external-link-alt"></i></span> 介绍了 Git 的数据模型，方便理解 Git
不那么友好的指令操作，很惊讶作者可以把 Git 讲得那么清楚；
<ul>
<li>btw，该网站同样推荐了许多 Git 的阅读材料，比如下一条：</li>
</ul></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQv">Git commit<i class="fa fa-external-link-alt"></i></span> 介绍撰写 Commit
信息的好的实践方案</li>
</ul>
<span id="more"></span>
<h2 id="git-commit-七准则">Git commit 七准则</h2>
<p>这里引用 <span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQv">Git commit<i class="fa fa-external-link-alt"></i></span>
里的文字：</p>
<blockquote class="blockquote-center">
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI3NlcGFyYXRl">Separate subject from
body with a blank line<i class="fa fa-external-link-alt"></i></span> 将主题与正文用空白行分隔</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI2xpbWl0LTUw">Limit the subject
line to 50 characters<i class="fa fa-external-link-alt"></i></span> 主题限制在 50 个字符之内</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI2NhcGl0YWxpemU=">Capitalize the
subject line<i class="fa fa-external-link-alt"></i></span> 主题首字符大写</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI2VuZA==">Do not end the subject
line with a period<i class="fa fa-external-link-alt"></i></span> 主题结尾不要写句号</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI2ltcGVyYXRpdmU=">Use the imperative
mood in the subject line<i class="fa fa-external-link-alt"></i></span> 主题使用祈使语气</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYmVhLm1zL2dpdC1jb21taXQvI3dyYXAtNzI=">Wrap the body at 72
characters<i class="fa fa-external-link-alt"></i></span> 正文每一行不超过 72 个字符</li>
<li><a href="https://cbea.ms/git-commit/#why-not-how">Use the body to
explain <em>what</em> and <em>why</em> vs. <em>how</em></a>
使用正文说明是什么，为什么，怎么做</li>
</ol>

</blockquote>
<h2 id="github-clone-失败">Github clone 失败</h2>
<p>使用 Github 克隆某一个库的时候，报错如下：</p>
<blockquote>
<p>git clone fatal unable to acces</p>
</blockquote>
<p>使用如下解决方案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>结果不行，后来浏览到一篇帖子，说是 Git
端口和本机系统代理的端口不一致造成的。打开
Clash，查看我的笔记本的代理端口为：7890。然后设置 Git 的端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>注意，第二条是 <code>http://127.0.0.1:7890</code> ，不是
<code>https://127.0.0.1:7890</code></p>
<h2 id="git-相关命令">Git 相关命令</h2>
<p><code>git init</code> 初始化 git 仓库。在当前目录下会生成一个
<code>.git/</code> 目录</p>
<p><code>git branch &lt;newbranch&gt;</code> 创建一个新的分支（但 head
指针仍然指向旧分支）</p>
<p><code>git checkout &lt;branchname&gt;</code> 将 head
指针移到某一个分支上</p>
]]></content>
      <categories>
        <category>技术词典</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran 中的 KIND</title>
    <url>/dict/Fortran-%E4%B8%AD%E7%9A%84-KIND/</url>
    <content><![CDATA[<p><code>KIND</code>
并不直接对应变量所占用的字节数，在不同的编译器与系统中可能有不同的对应关系，例如最常见的系统有：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REAl</span>(<span class="keyword">KIND</span>=<span class="number">4</span>)  :: xs   <span class="comment">! 4 byte ieee float</span></span><br><span class="line"><span class="keyword">REAl</span>(<span class="keyword">KIND</span>=<span class="number">8</span>)  :: xd   <span class="comment">! 8 byte ieee float</span></span><br><span class="line"><span class="keyword">REAl</span>(<span class="keyword">KIND</span>=<span class="number">16</span>) :: xq   <span class="comment">! 16 byte ieee float</span></span><br></pre></td></tr></table></figure>
<p>而有些编译器可能是：</p>
<span id="more"></span>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REAL</span>(<span class="keyword">KIND</span>=<span class="number">1</span>) :: XS   <span class="comment">! 4 BYTE FLOAT</span></span><br><span class="line"><span class="keyword">REAL</span>(<span class="keyword">KIND</span>=<span class="number">2</span>) :: XD   <span class="comment">! 8 BYTE FLOAT</span></span><br><span class="line"><span class="keyword">REAL</span>(<span class="keyword">KIND</span>=<span class="number">3</span>) :: XQ   <span class="comment">! 16 BYTE FLOAT</span></span><br></pre></td></tr></table></figure>
<p>所以，为了提高代码的可移植性，一般不直接给 integer 或 real
变量类型赋予确定的字节长度，而是使用内置函数<code>SELECTED_REAL_KIND</code>
and <code>SELECTED_INT_KIND</code> 从当前编译器中获取 <code>KIND</code>
的数值。例如，我想声明一个 15 位的 real 变量，首先调用内置函数：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!&gt; Double precision real numbers, 15 digits, range 10⁻³⁰⁷ to 10³⁰⁷-1; 64 bits</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: dp = <span class="built_in">selected_real_kind</span>(<span class="number">15</span>, <span class="number">307</span>)</span><br></pre></td></tr></table></figure>
<p>然后在程序中声明变量：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span>(dp) :: a, b, c</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=dp) :: a, b, c <span class="comment">! another equivalent statement</span></span><br><span class="line">a = <span class="number">1.0_dp</span></span><br><span class="line">b = <span class="number">3.5_dp</span></span><br><span class="line">c = <span class="number">1.34e8_dp</span></span><br></pre></td></tr></table></figure>
<p>注意，这里的浮点数常数后面还加上了参量 <code>KIND</code>
的后缀，每次写个数都这么搞似乎太麻烦了些，不知道不写是不是也<sub>行</sub>啊~~~？anyway，可以在
module 中统一定义参量 <code>KIND</code> ，然后在其它程序中引用：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!&gt; Numerical storage size parameters for real and integer values</span></span><br><span class="line"><span class="keyword">module</span> kind_parameter</span><br><span class="line">   <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">   <span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">!&gt; Single precision real numbers, 6 digits, range 10⁻³⁷ to 10³⁷-1; 32 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: sp = <span class="built_in">selected_real_kind</span>(<span class="number">6</span>, <span class="number">37</span>)</span><br><span class="line">   <span class="comment">!&gt; Double precision real numbers, 15 digits, range 10⁻³⁰⁷ to 10³⁰⁷-1; 64 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: dp = <span class="built_in">selected_real_kind</span>(<span class="number">15</span>, <span class="number">307</span>)</span><br><span class="line">   <span class="comment">!&gt; Quadruple precision real numbers, 33 digits, range 10⁻⁴⁹³¹ to 10⁴⁹³¹-1; 128 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: qp = <span class="built_in">selected_real_kind</span>(<span class="number">33</span>, <span class="number">4931</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">!&gt; Char length for integers, range -2⁷ to 2⁷-1; 8 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: i1 = <span class="built_in">selected_int_kind</span>(<span class="number">2</span>)</span><br><span class="line">   <span class="comment">!&gt; Short length for integers, range -2¹⁵ to 2¹⁵-1; 16 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: i2 = <span class="built_in">selected_int_kind</span>(<span class="number">4</span>)</span><br><span class="line">   <span class="comment">!&gt; Length of default integers, range -2³¹ to 2³¹-1; 32 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: i4 = <span class="built_in">selected_int_kind</span>(<span class="number">9</span>)</span><br><span class="line">   <span class="comment">!&gt; Long length for integers, range -2⁶³ to 2⁶³-1; 64 bits</span></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: i8 = <span class="built_in">selected_int_kind</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> kind_parameter</span><br></pre></td></tr></table></figure>
<p>如果不是跨系统使用自己的代码，直接在 Windows 环境下用
<code>real(8)</code> 就省事多了。</p>
<p>我似乎明白了为什么之前看到过别人的 Fortran 代码，连 0.0，1.0，…，9.0
都要用变量名定义。我使用的编程语言主要是 MATLAB（如果 MATLAB
可以被称为一门编程语言的话），对数据类型只关注整数，浮点数，字符这种大的类别的区分，对于这些数据占系统多少字节并不关心，但是
Fortran 中的变量还可以体现占用字节的信息。</p>
<p><strong>主要参考文档</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMjAwOTMwMDkwMTM3L2h0dHBzOi8vc3RldmVsaW9uZWwuY29tL2RyZm9ydHJhbi8yMDE3LzAzLzI3L2RvY3Rvci1mb3J0cmFuLWluLWl0LXRha2VzLWFsbC1raW5kcy8=">Doctor
Fortran in “It Takes All KINDs”<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODM4MzEwL2ZvcnRyYW4tOTAta2luZC1wYXJhbWV0ZXI=">Fortran
90 kind parameter<i class="fa fa-external-link-alt"></i></span></p>
<p>在看帖子时看到别人写的查询自己机器 <code>KIND</code> 变量并生成相应的
Fortran 源码的代码，<code>kindfinder.f90</code></p>
]]></content>
      <categories>
        <category>技术词典</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>数据类型声明</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 快捷指令</title>
    <url>/dict/Vim-%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="为什么会用-vim">为什么会用 Vim</h2>
<p>因为 Vim 提供了一种不太一样的文本编辑器哲学.
它认为代码主要的工作是修改代码, 所以提供了大量的键盘指令操作,
方便使用者来修改 ta 们的代码.</p>
<h2 id="vim-的四种模式">Vim 的四种模式</h2>
<ul>
<li>Normal mode: 普通模式, 移动光标或使用命令修改文本</li>
<li>Visual mode: 浏览模式, 选择文本</li>
<li>Insert mode: 插入模式, 编辑文本</li>
<li>Command mode: 命令模式, 执行命令</li>
</ul>
<h3 id="插入模式">插入模式</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>i</code></td>
<td>在光标后编辑</td>
</tr>
<tr class="even">
<td><code>I</code></td>
<td>在光标所在行<strong>起始</strong>编辑</td>
</tr>
<tr class="odd">
<td><code>a</code></td>
<td>在光标<strong>前</strong>编辑</td>
</tr>
<tr class="even">
<td><code>A</code></td>
<td>在光标所在行<strong>末尾</strong>编辑</td>
</tr>
<tr class="odd">
<td><code>o</code></td>
<td>在光标所在行<strong>下方</strong>增添新行并编辑</td>
</tr>
<tr class="even">
<td><code>O</code></td>
<td>在光标所在行<strong>上方</strong>增添新行并编辑</td>
</tr>
</tbody>
</table>
<h3 id="浏览模式">浏览模式</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>v</code></td>
<td>从光标所在<strong>处</strong>开始,
按<strong>字符</strong>选择文本</td>
</tr>
<tr class="even">
<td><code>V</code></td>
<td>从光标所在<strong>行</strong>开始,
按<strong>行</strong>选择文本</td>
</tr>
<tr class="odd">
<td><code>ctrl+v</code></td>
<td>从光标所在<strong>列</strong>开始,
按<strong>列</strong>选择文本</td>
</tr>
</tbody>
</table>
<h3 id="命令模式">命令模式</h3>
<ul>
<li><code>:q</code> 退出</li>
<li><code>:w</code> 保存</li>
<li><code>:wq</code> 保存并退出</li>
<li><code>:e &#123;文件名&#125;</code> 打开文件并编辑</li>
<li><code>:ls</code> 展示打开的缓存区</li>
<li><code>:help &#123;命令&#125;</code> 打开帮助, 例如
<ul>
<li><code>:help :w</code> 打开关于命令 <code>:w</code> 的帮助</li>
<li><code>:help w</code> 打开关于命令 <code>w</code> 的帮助</li>
</ul></li>
</ul>
<h2 id="导航">导航</h2>
<h3 id="移动屏幕">移动屏幕</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>zt</code></td>
<td>移动屏幕, 使得光标在窗口顶端</td>
</tr>
<tr class="even">
<td><code>zt</code></td>
<td>移动屏幕, 使得光标在窗口顶端</td>
</tr>
<tr class="odd">
<td><code>zz</code></td>
<td>移动屏幕, 使得光标在窗口中部</td>
</tr>
<tr class="even">
<td><code>zb</code></td>
<td>移动屏幕, 使得光标在窗口底部</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>H</code></td>
<td>移动光标至屏幕顶端</td>
</tr>
<tr class="even">
<td><code>M</code></td>
<td>移动光标至屏幕中部</td>
</tr>
<tr class="odd">
<td><code>L</code></td>
<td>移动光标至屏幕底部</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>gg</code></td>
<td>移动光标至文件起始处</td>
</tr>
<tr class="even">
<td><code>G</code></td>
<td>移动光标至文件末尾处</td>
</tr>
</tbody>
</table>
<p><code>&#123;行号&#125;gg</code>, <code>&#123;行号&#125;G</code>, <code>:&#123;行号&#125;</code>
移动光标至行{行号}</p>
<h3 id="单词">单词</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>w</code></td>
<td>将光标移动到前一个单词的起始处</td>
</tr>
<tr class="even">
<td><code>e</code></td>
<td>将光标移动到当前单词的末尾处; <br>若已经在末尾,
则移动到前一个单词的末尾处</td>
</tr>
<tr class="odd">
<td><code>b</code></td>
<td>将光标移动到后一个单词的起始处</td>
</tr>
<tr class="even">
<td><code>ge</code></td>
<td>将光标移动到后一个单词的末尾处</td>
</tr>
</tbody>
</table>
<h3 id="行">行</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>^</code></td>
<td>将光标移动到所在行第一个字符处</td>
</tr>
<tr class="even">
<td><code>0</code></td>
<td>将光标移动到行首</td>
</tr>
<tr class="odd">
<td><code>$</code></td>
<td>将光标移动到行尾</td>
</tr>
</tbody>
</table>
<h3 id="搜索">搜索</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>f&#123;字符&#125;</code></td>
<td>在当前行<strong>向前</strong>搜索并跳转至字符 char 处</td>
</tr>
<tr class="even">
<td><code>F&#123;字符&#125;</code></td>
<td>在当前行<strong>向后</strong>搜索并跳转至字符 char 处</td>
</tr>
<tr class="odd">
<td><code>t&#123;字符&#125;</code></td>
<td>在当前行<strong>向前</strong>搜索并跳转到字符 char 后</td>
</tr>
<tr class="even">
<td><code>T&#123;字符&#125;</code></td>
<td>在当前行<strong>向后</strong>搜索并跳转到字符 char 前</td>
</tr>
</tbody>
</table>
<p>使用 <code>,</code> / <code>;</code> 搜索 后/前 一个字符</p>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/&#123;正则表达式&#125;</code></td>
<td>在文档中搜索{正则表达式}</td>
</tr>
</tbody>
</table>
<p>使用 <code>N</code> / <code>n</code> 搜索 后/前 一个{正则表达式}</p>
<h2 id="编辑文档">编辑文档</h2>
<h3 id="删除和替换">删除和替换</h3>
<ul>
<li><code>d&#123;导航命令&#125;</code> 删除 {导航命令}
<ul>
<li>e.g. <code>dw</code> 删除单词, <code>d$</code>
删除光标处至行尾的内容, <br><code>d0</code> 删除光标处至行首的内容</li>
</ul></li>
<li><code>c&#123;导航命令&#125;</code> 替换 {导航命令}
<ul>
<li>e.g. <code>cw</code> 可以看作执行删除单词命令后再执行命令
<code>i</code></li>
</ul></li>
<li><code>x</code> 删除字符 (等价于 <code>dl</code>)</li>
<li><code>s</code> 替换字符 (等价于 <code>cl</code>)</li>
</ul>
<h3 id="复制和粘贴">复制和粘贴</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>y␣</code></td>
<td>复制光标所在处字符</td>
</tr>
<tr class="even">
<td><code>yy</code></td>
<td>复制光标所在行</td>
</tr>
<tr class="odd">
<td><code>yw</code></td>
<td>复制光标所在单词</td>
</tr>
<tr class="even">
<td><code>y$</code></td>
<td>复制光标处至行尾的内容</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>p</code></td>
<td>在光标后粘贴</td>
</tr>
<tr class="even">
<td><code>P</code></td>
<td>在光标前粘贴</td>
</tr>
</tbody>
</table>
<h3 id="撤销和重现">撤销和重现</h3>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>u</code></td>
<td>撤销上一次操作</td>
</tr>
<tr class="even">
<td><code>Ctrl+r</code></td>
<td>重现下一次操作</td>
</tr>
</tbody>
</table>
<h3 id="计数">计数</h3>
<p>在此处仅举一些命令作为例子, 其它可类推</p>
<ul>
<li><code>3w</code> 向前移动 3 个单词</li>
<li><code>5j</code> 向下移动 5 行</li>
<li><code>7dw</code> 删除 7 个单词</li>
</ul>
]]></content>
      <categories>
        <category>技术词典</category>
      </categories>
      <tags>
        <tag>Vim</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux 快捷键索引</title>
    <url>/dict/tmux-%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>tmux 之于命令窗口有点类似于浏览器之于网页, 可在 tmux
命令环境中操纵多个命令行窗口.<span id="more"></span></p>
<blockquote>
<p>注: tmux 的快捷键操作一般需要先按下 <kbd>Ctrl</kbd> +<kbd>b</kbd>.
文档中列出的快捷键清单默认没有写出这一组合键, 如不需要按下
<kbd>Ctrl</kbd> +<kbd>b</kbd>, 会在按键操作中特别说明.</p>
</blockquote>
<h2 id="面板-pano-操作">面板 (pano) 操作</h2>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><kbd>%</kbd></td>
<td>左右分裂当前面板</td>
</tr>
<tr class="even">
<td><kbd>“</kbd></td>
<td>上下分裂当前面板</td>
</tr>
<tr class="odd">
<td><kbd>方向键</kbd></td>
<td>导航面板</td>
</tr>
<tr class="even">
<td><kbd>Ctrl</kbd>+<kbd>d</kbd> (不按 <code>c-b</code>)</td>
<td>关闭当前面板</td>
</tr>
<tr class="odd">
<td><kbd>z</kbd></td>
<td>将 pano 放大为全屏, <br />再按一次缩小为原来的尺寸</td>
</tr>
<tr class="even">
<td><kbd>Ctrl</kbd>+<kbd>方向键</kbd></td>
<td>按照方向键方向调整 pano 尺寸</td>
</tr>
</tbody>
</table>
<h2 id="窗口-window-操作">窗口 (window) 操作</h2>
<table>
<colgroup>
<col style="width: 59%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><kbd>c</kbd></td>
<td>创建新窗口</td>
</tr>
<tr class="even">
<td><kbd>Ctrl</kbd>+<kbd>d</kbd> (不按 <code>c-b</code>)</td>
<td>关闭当前窗口</td>
</tr>
<tr class="odd">
<td><kbd>,</kbd></td>
<td>重命名当前窗口</td>
</tr>
<tr class="even">
<td><kbd>p</kbd></td>
<td>打开前一个窗口</td>
</tr>
<tr class="odd">
<td><kbd>n</kbd></td>
<td>打开后一个窗口</td>
</tr>
<tr class="even">
<td><kbd>num</kbd></td>
<td>打开编号 <kbd>num</kbd> 窗口</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>技术词典</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 环境下快速打开 MATLAB 命令行</title>
    <url>/howto/Linux-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80-MATLAB-%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<p>在 Ubuntu 22.04 中安装 MATLAB 之后，使用命令行运行 MATLAB 报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">laptop@qxh-Precision-7920-Tower:~$ matlab</span><br><span class="line">matlab：未找到命令</span><br></pre></td></tr></table></figure>
<p>这样每次运行 MATLAB，总是要到路径
<code>/usr/local/MATLAB/R2024a/bin</code> 下运行 <code>matlab</code>
脚本，并且再切换到原来的目录，很不方便。一种解决方案是使用
<code>alias</code> 命令，定义一条短语替代长的字符串命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Creates aliases -- words that are replaced by a <span class="built_in">command</span> string.</span><br><span class="line"> Aliases expire with the current shell session unless defined <span class="keyword">in</span> the shell<span class="string">&#x27;s configuration file, e.g. ~/.bashrc.</span></span><br></pre></td></tr></table></figure>
<p>根据 MATLAB 在工作站的安装目录，我定义的 <code>alias</code> 为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> matlab=<span class="string">&quot;/usr/local/MATLAB/R2024a/bin/matlab -nodesktop -nodisplay&quot;</span></span><br></pre></td></tr></table></figure>
<p>命令中 <code>-nodesktop</code> <code>-nodisplay</code> 表示不运行
MATLAB GUI 界面（不得不吐槽 MATLAB 在 Ubuntu 下的 GUI
太丑了）。运行这一行命令之后，如果运行
<code>alias</code>，就会发现我们定义的短语已经加载到当前的 bash
当中了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">laptop@qxh-Precision-7920-Tower:~$ <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">alias</span> alert=<span class="string">&#x27;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#x27;</span>\<span class="string">&#x27;&#x27;</span>s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//<span class="string">&#x27;\&#x27;</span><span class="string">&#x27;)&quot;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> matlab=<span class="string">&#x27;/usr/local/MATLAB/R2024a/bin/matlab -nodesktop -nodisplay&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此外还会看到许多我们并没有直接定义的
<code>alias</code>，这是因为它们是在 bash 配置文件
<code>~/.bashrc</code> 中预定义的，每次运行 bash
时都会将这些命令加载进来，所以，如果希望下一次运行 bash 可以直接运行
matlab，还需要将定义的 <code>alias</code> 加载到 <code>~/.bashrc</code>
中。</p>
<p>编辑完 bash 配置文件之后，运行 <code>source</code> 命令重新加载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>就可以了。</p>
<p>此外，如果脚本配置文件中定义了如下语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f ~/.bash_aliases ]; <span class="keyword">then</span></span><br><span class="line">	. ~/.bash_aliases</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>那么可以在外部文件中 <code>.bash_aliases</code> 写入自定义的
<code>aliases</code> 。</p>
<blockquote>
<p><strong>可能遇到的问题</strong></p>
<p>执行 <code>source ~/.bashrc</code>如果报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bashrc (line 6): &#x27;case&#x27; builtin not inside of switch block</span><br><span class="line">case $- in</span><br><span class="line">^</span><br><span class="line">from sourcing file .bashrc</span><br><span class="line">source: Error while reading file “.bashrc”</span><br></pre></td></tr></table></figure>
<p>那么这可能是因为在 Fish 环境下执行的，退出 Fish 之后就可以了。参考 <span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy8xMzkwMDAwL215LWJhc2hyYy1oYXMtYS10eXBvLWFuZC1pLWRvLW5vdC1rbm93LWhvdy10by1maXgtaXQ=">my
.bashrc has a typo and I do not know how to fix it<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
]]></content>
      <categories>
        <category>教你做事</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu + apache2 配置 https 协议下的 SVN 仓库</title>
    <url>/howto/Linux-%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E7%9A%84-SVN-%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>在 Windows 环境下，因为有 Tortoise SVN 和 Visual SVN Server
的存在，SVN 的操作难度降低了不少。但在 Linux
环境下，为了让用户更好地了解 SVN
的工作原理，<del>从而体验自立更生的快乐和自闭，</del>SVN
的种种操作，从建仓到创建用户到配置网络到 checkout 到 commit 到
update，全都是用命令行实现的。虽然一些编译器集成了版本控制的功能，但是要建立
SVN 仓库，据作者有限的知识，应该只能通过命令行创建。本文介绍的是如何在
Linux 环境下使用 apache2 配置 https 协议下的 SVN 仓库。</p>
<p>主要的参考文档是：<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLnVidW50dS5jb20vY29tbXVuaXR5L1N1YnZlcnNpb24=">Subversion<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9yYmdlZWsud29yZHByZXNzLmNvbS8yMDEyLzA5LzA5L3N2bi1zZXJ2ZXItb24tdWJ1bnR1LXdpdGgtaHR0cHMtYWNjZXNzLw==">ssl
配置<i class="fa fa-external-link-alt"></i></span> <span id="more"></span></p>
<h2 id="创建-apache2-用户-www-data">创建 apache2 用户 www-data</h2>
<p>apache2
是与网络相关的服务器，如果我们希望能在同一局域网下的不同设备操作同一个
SVN 仓库，就必须要配置它。首先我们需要创建一个与 SVN 相关的 group，和
apache2 的用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加组 subversion</span></span><br><span class="line">$ sudo addgroup subversion</span><br><span class="line"><span class="comment"># 在组 subversion 中添加用户 www-data (apache2 用户) 和 laptop</span></span><br><span class="line">$ sudo adduser www-data subversion</span><br><span class="line">$ sudo adduser laptop subversion</span><br></pre></td></tr></table></figure>
<p>创建的 <code>group</code> 以及所属用户可以查看
<code>/etc/group</code> 文件获知：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/group | grep subversion</span><br><span class="line">subversion<span class="github-emoji" alias="x" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">&#x274c;</span>1002:laptop,www-data</span><br></pre></td></tr></table></figure>
<h2 id="创建-svn-仓库">创建 SVN 仓库</h2>
<p>如果我们希望在 <code>/repos/svn</code> 创建一个关于 MATLAB
脚本的仓库，我们可以运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo svnadmin create /repos/svn/MATLAB</span><br></pre></td></tr></table></figure>
<p>塔嗒！一个 SVN
仓库就创建好了，是不是很简单？我们先接着往下做吧。因为我们是用
<code>sudo</code> 命令创建的仓库，所以该仓库所属用户为
<code>root</code>，如果我们想要读写执行该文档中的数据，每次都要通过
<code>sudo</code> 来操作，否则会遇到 <code>permission denied</code>
错误。我们将文件夹的用户修改为 <code>www-data</code>，组修改为
<code>subversion</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R www:data /repos/svn/MATLAB</span><br></pre></td></tr></table></figure>
<p>命令中的选项 <code>-R</code>
表示递归修改指定目录下的所有子文件夹以及文件所属用户和组。修改完之后，我们还需要修改
SVN 仓库的权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R g+rws /repos/svn/MATLAB</span><br></pre></td></tr></table></figure>
<p>命令表示，对文件夹 <code>MATLAB</code>
所属的用户<code>g</code>递归<code>-R</code>添加<code>+</code>读写执行<code>rws</code>权限。</p>
<h2 id="创建-svn-用户">创建 SVN 用户</h2>
<p>SVN 用户名以及密码存放在 <code>/etc/subversion/passwd</code>
文件中，第一次创建用户时使用命令 <code>htpasswd -c</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo htpasswd -c /etc/subversion/passwd laptop</span><br></pre></td></tr></table></figure>
<p>运行该命令之后，会要求输入用户密码并确认，输入的密码会加密保存在
<code>passwd</code> 中。</p>
<div class="note warning"><p><code>-c</code> 会覆盖原来的 <code>passwd</code> 文件！</p>
</div>
<p>如果继续添加用户，则运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo htpasswd /etc/subversion/passwd another_laptop</span><br></pre></td></tr></table></figure>
<p>或者重置原用户的密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo htpasswd /etc/subversion/passwd laptop</span><br></pre></td></tr></table></figure>
<h2 id="本地-checkout-svn-仓库">本地 checkout SVN 仓库</h2>
<p>现在，如果只需要在本地操作 SVN 的话，那么就可以通过
<code>file:///</code> 获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，命令中有三个反斜杠！</span></span><br><span class="line">svn co file:///repos/svn/MATLAB MATLAB</span><br><span class="line"><span class="comment"># 或者使用 localhost，此时命令有两个反斜杠</span></span><br><span class="line">svn co file://localhost/repos/svn/MATLAB myproject</span><br></pre></td></tr></table></figure>
<div class="note info"><p>checkout 本地的 SVN 仓库不需要用户名和密码。</p>
</div>
<h2 id="使用-webdav-获取-svn-仓库">使用 WebDAV 获取 SVN 仓库</h2>
<p>许多教程中要求安装的是libapache2-svn，但是对于新版本 Ubuntu
系统，安装 <span class="exturl" data-url="aHR0cHM6Ly9sYXVuY2hwYWQubmV0L3VidW50dS9iaW9uaWMvK3BhY2thZ2UvbGliYXBhY2hlMi1tb2Qtc3Zu">libapache2-mod-svn<i class="fa fa-external-link-alt"></i></span>
。</p>
<p>我们首先配置文件
<code>/etc/apache2/mods-available/dav_svn.conf</code>，其用途是配置
apache2 和 subversion 关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Location /svn&gt;</span><br><span class="line">   DAV svn</span><br><span class="line">   SVNParentPath /repos/svn</span><br><span class="line">   SVNListParentPath On</span><br><span class="line">   AuthType Basic</span><br><span class="line">   AuthName <span class="string">&quot;Subversion Repository&quot;</span></span><br><span class="line">   AuthUserFile /etc/subversion/passwd</span><br><span class="line">   Require valid-user</span><br><span class="line">&lt;/Location&gt;</span><br></pre></td></tr></table></figure>
<p>一些对于该文件的注释：</p>
<ul>
<li><code>Location</code> 中的路径 <code>/svn</code> 表示在 checkout SVN
仓库时，URL 的链接目录。该目录可以不等同于 SVN
仓库在服务器本地的存储路径。具体来说，如果按照如上配置文件，那么
checkout 的 SVN 路径应该是
<code>http://&lt;ip&gt;/svn/&lt;reposName&gt;</code>，不是<del><code>http://&lt;ip&gt;/repos/svn/&lt;reposName&gt;</code></del></li>
<li><code>SVNParentPath</code> 写入 SVN 仓库的上一级目录</li>
</ul>
<p>配置完成之后，需要重启 apache2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure>
<p>此时就可以使用 <code>http</code> 协议拉取 SVN 仓库了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">svn co http://hostname/svn/MATLAB --username laptop</span><br></pre></td></tr></table></figure>
<h2 id="配置-https-协议">配置 https 协议</h2>
<p>http
协议客户端与服务器之间的通讯是明文的，为了对通讯进行加密，我们使用 https
协议，其中多出的「s」表示 ssl。</p>
<p>首先我们需要打开 apache2 关于 ssl 的模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo a2enmod ssl</span><br></pre></td></tr></table></figure>
<p>然后我们需要生成自签名证书与密钥。创建目录
<code>/etc/apache2/ssl</code> ，运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo openssl req -new -x509 -days 365 -nodes -out /etc/apache2/ssl/apache.pem -keyout /etc/apache2/ssl/apache.key</span><br></pre></td></tr></table></figure>
<p>这时在目录 <code>/etc/apache2/ssl</code> 目录下会生成证书
<code>apache.pem</code> 和密钥 <code>apache.key</code>
两个文件。我们需要修改文件
<code>/etc/apache2/sites-available/default-ssl</code>
中自签名证书和密钥的路径为刚刚生成的两个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SSLCertificateFile /etc/apache2/ssl/apache.pem</span><br><span class="line">SSLCertificateKeyFile /etc/apache2/ssl/apache.key</span><br></pre></td></tr></table></figure>
<p>在之后我们还要修改 <code>/etc/apache2/ports.conf</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Listen 80</span><br><span class="line"></span><br><span class="line">&lt;IfModule ssl_module&gt;</span><br><span class="line">        NameVirtualHost *:443</span><br><span class="line">        Listen 443</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_gnutls.c&gt;</span><br><span class="line">        NameVirtualHost *:443</span><br><span class="line">        Listen 443</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>配置完这些文件之后，我们需要开启 apache2 虚拟主机 ssl（英文是：Enable
an apache2 virtual host on Debian-based OSes.）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo a2ensite default-ssl</span><br></pre></td></tr></table></figure>
<p>以及重启 apache2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure>
<p>这时，如果一切顺利的话，我们就可以通过 https 访问 SVN 仓库了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">svn co https://hostname/svn/MATLAB</span><br></pre></td></tr></table></figure>
<h2 id="防火墙允许-https">防火墙允许 https</h2>
<p>此时，我们在同一局域网下的客户端，因为服务器防火墙的阻拦，还是不可以
checkout SVN repos，这时需要在服务器中运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow https</span><br></pre></td></tr></table></figure>
<p>就能够允许客户端通过 https 协议访问 SVN 了。</p>
]]></content>
      <categories>
        <category>教你做事</category>
      </categories>
      <tags>
        <tag>svn</tag>
        <tag>apache2</tag>
        <tag>https</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 添加注记文本</title>
    <url>/howto/Markdown-%E4%BD%BF%E7%94%A8-html-%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>在写文档的时候, 我有时会有这样的需求:</p>
<ul>
<li>标记一段重要的文本；</li>
<li>这些文本可以归属为: 笔记 (note) , 警告 (warning) , 定义等等</li>
</ul>
<p>我就很想要一个彩色的框框, 把这段文字给标注一下. 在 <span
class="math inline">\(\LaTeX\)</span>​​​ 中, 一般是用命令
<code>\mdframed</code> 实现. 然而在 Markdown 的标准语法中,
并没有注记文本这一功能.</p>
<span id="more"></span>
<hr />
<p>一些特殊的 Markdown 解析器可以做到, 比如在 Github Markdown
解析器中插入下段标记:</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/github-admonition-20230928143727151.png"
alt="image-20230928143727151" />
<figcaption aria-hidden="true">image-20230928143727151</figcaption>
</figure>
<hr />
<p>注记文本的功能也有人向 Typora 官方提出过, 不过 Typora
认为这一功能并不是必要的, 反而还会破坏 Markdown 语法的简洁性. 在 Github
上的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cG9yYS90eXBvcmEtaXNzdWVzL2xhYmVscy9tYXJrZG93biUyMGV4dGVuc2lvbj9wYWdlPTImcT1pcyUzQW9wZW4rbGFiZWwlM0ElMjJtYXJrZG93bitleHRlbnNpb24lMjI=">issue<i class="fa fa-external-link-alt"></i></span>是这样说的:</p>
<blockquote>
<p>This seems too far way from most markdown engines. We want keep
markdown in typora simple, no extra learning costs if one already knows
how to write markdown. So, we are less likely to add syntax support for
this</p>
</blockquote>
<p>一种替代的方法是是用 emoji <span class="github-emoji"
data-alias="tada" style=""
data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span>.
这个是 stackflow 上提供的权宜之计. 比如说, 我想写一段笔记:</p>
<blockquote>
<p><span class="github-emoji" data-alias="notebook" style=""
data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8">📓</span>
<strong>笔记</strong></p>
<p>这是一段笔记.</p>
</blockquote>
<p>还可以吧, 要是引用框的颜色可以变变就更好了. 不然 Typora
的文档总显得灰头土脸的, 放到 hexo 博客上的文章也是单一的白色.
这时可以使用 html 标签 <code>&lt;div&gt; &lt;/div&gt;</code>
来添加引用文本的背景色, 可是需要添加很长一段代码, 在 Typora
中不太实用:</p>
<div style="background-color:lightblue;padding:20px;">
<h4>
Warning
</h4>
<p>
London is the capital city of England. It is the most populous city in
the United Kingdom, with a metropolitan area of over 13 million
inhabitants.
</p>
</div>
<p>但是这个颜色吧… 综上, 还是使用 emoji 的方式, 在 Typora
中表示段落文字的强调.</p>
<hr />
<p>在写 hexo 博客的时候, 可以使用 tag 插件实现这一功能,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [summary] %&#125;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>变量说明如下:</p>
<ul>
<li><code>[class]</code> : <em>Optional parameter.</em> Supported
values: default | primary | success | info | warning | danger.</li>
<li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon
in note.</li>
<li><code>[summary]</code> : <em>Optional parameter.</em> Optional
summary of the note.</li>
</ul>
<p>效果图为</p>
<figure>
<img
src="C:\Users\qiutian\AppData\Roaming\Typora\typora-user-images\image-20240406093726500.png"
alt="image-20240406093726500" />
<figcaption aria-hidden="true">image-20240406093726500</figcaption>
</figure>
<h2 id="除此之外">除此之外</h2>
<p>探索 Markdown 段落标记文字的时候, 发现它可以插入 html 标签,
来实现一些之前没想到过的功能. 更多内容可以参考<span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LnR5cG9yYS5pby9IVE1MLyNjb21tZW50cw==">官方文档<i class="fa fa-external-link-alt"></i></span>, 以及 html
<span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9odG1sL2RlZmF1bHQuYXNw">教学网站<i class="fa fa-external-link-alt"></i></span>.</p>
<h3 id="键盘标签-kbd">键盘标签 <code>&lt;kbd&gt;</code></h3>
<p>该标签可以插入在行内. 比如, 我想表示 VSCode 中「打开设置」快捷键:
<kbd>Ctrl</kbd>+<kbd>,</kbd>.</p>
<h3 id="总结标签-summary">总结标签 <code>&lt;summary&gt;</code></h3>
<details>
<summary>
I have keys but no locks. I have space but no room. You can enter but
can't leave. What am I?
</summary>
<pre><code> A keyboard. &lt;/details&gt;</code></pre>
]]></content>
      <categories>
        <category>教你做事</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 环境下安装 LaTeX</title>
    <url>/howto/Ubuntu-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85-LaTeX/</url>
    <content><![CDATA[<p>如果想懒省事且有充足的安装空间的话，可以直接安装完全体版
<code>texlive-full</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install texlive-full</span><br></pre></td></tr></table></figure>
<p>这大概会占用 6 GB 的空间，但是好处是在未来写 <code>tex</code>
文档时，不会加载了奇奇怪怪的宏包之后编译出现 bug。<span id="more"></span></p>
<p>另外可以安装低配版的宏包，可是在 VSCode 编译时会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Recipe terminated with fatal error: spawn xelatex ENOENT</span><br></pre></td></tr></table></figure>
<p>查看网上的问题贴，这应该是因为找不到 <code>xelatex</code>
的安装路径。但如果装的是低配版的 texlive，我根本就不知道 Ubuntu
这货把它装在哪里了…</p>
<p>安装完 <code>texlive-full</code> 之后还有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I can&#x27;t find the format file `xelatex.fmt&#x27;!</span><br></pre></td></tr></table></figure>
<p>stackflow 上有相关的<span class="exturl" data-url="aHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIzMTY0L2ktY2FudC1maW5kLXRoZS1mb3JtYXQtZmlsZS14ZWxhdGV4LWZtdA==">帖子<i class="fa fa-external-link-alt"></i></span>，尝试最高赞的解决方案：</p>
<blockquote>
<p>try to run <code>sudo fmtutil-sys --all</code> which should create
all missing format files.</p>
</blockquote>
<p>没有奏效。第二个解决方案是重新安装 <code>xetex</code></p>
<blockquote>
<p>If you installed TeX from the repositories of your Linux system, you
could reinstall the xetex package from a repository.</p>
<ul>
<li>Redhat/Fedora: <code>sudo yum reinstall texlive-xetex</code></li>
<li>Debian/Ubuntu:
<code>sudo apt-get install --reinstall texlive-xetex</code></li>
</ul>
</blockquote>
<p>It works!</p>
]]></content>
      <categories>
        <category>教你做事</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 使用 snippets 插入代码注释</title>
    <url>/howto/VSCode-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>突然发现用 snippets 写注释也非常好用啊，比如写 Fortran 的 function 或
subroutine 的头部注释：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">! name      : symSchur2</span></span><br><span class="line"><span class="comment">! remark    : get Schur decomposition for 2x2 matrix</span></span><br><span class="line"><span class="comment">!</span></span><br><span class="line"><span class="comment">! version   : 1.0</span></span><br><span class="line"><span class="comment">! date      : 2023-09-06 13:34:25</span></span><br><span class="line"><span class="comment">! author    : XXX</span></span><br><span class="line"><span class="comment">!-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> symSchur2(A,c,s)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> symSchur2</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>直接在 Fortran 对应的 snippets 设置文件
<code>FortranFreeForm.json</code> 中加入如下片段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Head comments for subroutines&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hc&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;!-----------------------------------------------------------------------------&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! name      : $1&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! remark    : $2&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;!&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! version   : 1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! date      : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE  $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;! author    : XXX&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;!-----------------------------------------------------------------------------&quot;</span></span><br><span class="line">		<span class="punctuation">]</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，变量 <code>$1</code> <code>$2</code> 在插入 snippets
时会自动要求你插入新的内容。时间部分可以用 VSCode 内置的变量添加。</p>
]]></content>
      <categories>
        <category>教你做事</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>snippets</tag>
      </tags>
  </entry>
  <entry>
    <title>配置 Typora 上传图片到网络图床</title>
    <url>/howto/%E9%85%8D%E7%BD%AE-Typora-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E7%BD%91%E7%BB%9C%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>如果在 markdown 文档插入本地路径中的图片，那么移动 markdown
文档同时还必须考虑图片路径，否则图片总是无法正确显示。而配置网络中的图床，在
markdown
中只需要插入图片对应的网络链接即可，这在写网络博客很方便。图床一共需要配置三个位置：</p>
<span id="more"></span>
<ul>
<li>Github：设置图床仓库 <code>picgo-bed</code></li>
<li>PicGo：配置图床</li>
<li>Typora：偏好设置中图片选项选择使用 picgo-bed(app) 上传图片</li>
</ul>
<h2 id="github-设置">Github 设置</h2>
<p>Github 设置公共仓库，同时生成一个 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==">token<i class="fa fa-external-link-alt"></i></span> 用于 picgo
操作仓库。注意生成时只需要勾选 repo 选项即可，如图所示</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/image-20230908204919952.png" alt="choose-repo-only" style="zoom:50%;" /></p>
<p>如果设置 token 有效时长为有限的，那么需要记住 token
失效的时间，否则超出期限之后无法上传图片。</p>
<h2 id="picgo-设置">PicGo 设置</h2>
<p>我的设置如下，具体可参考 PicGo
手册：https://picgo.github.io/PicGo-Doc/zh/guide/</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/image-20230908205208599.png"
alt="image-20230908205208599" />
<figcaption aria-hidden="true">image-20230908205208599</figcaption>
</figure>
<blockquote>
<p><span class="github-emoji" data-alias="warning" style=""
data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span>
注意修改 “设定分支名” 选项中默认值 maste 为 github 主分支名称
“main”，</p>
</blockquote>
<p>为了增加上传图片的可读性，我还设置了如下功能</p>
<ul>
<li>上传图片前重命名</li>
<li>对图片加上时间戳</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/%E6%B5%8B%E8%AF%95%20picgo%20%E6%94%B9%E5%90%8D%E5%AD%97%E5%8A%9F%E8%83%BD.png"
alt="测试picgo改名字功能" />
<figcaption aria-hidden="true">测试picgo改名字功能</figcaption>
</figure>
<p>这样上传到 github 中得到的就是改过名字的图片了，可读性会强很多</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/github%20%E6%98%BE%E7%A4%BA%E6%94%B9%E8%BF%87%E5%90%8D%E5%AD%97%E7%9A%84%E5%9B%BE%E7%89%87%E5%90%8D%E7%A7%B0.png"
alt="github仓库截图" />
<figcaption aria-hidden="true">github仓库截图</figcaption>
</figure>
<h2 id="typora-配置">Typora 配置</h2>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/Typora%20%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE.png"
alt="typora 上传图片设置" />
<figcaption aria-hidden="true">typora 上传图片设置</figcaption>
</figure>
]]></content>
      <categories>
        <category>教你做事</category>
      </categories>
      <tags>
        <tag>typora</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT + Github：搭建博客</title>
    <url>/howto/%E9%85%8D%E7%BD%AE-Hexo-%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>首先我们先理清一下这三者的关系：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuLw==">Hexo<i class="fa fa-external-link-alt"></i></span>
本身是自动生成博客网页的<strong>框架</strong>代码，它不需要我们自己编写网页（例如
<code>.css</code>，<code>.js</code> ），而是修改
<code>_config.yml</code>
文件提供的参量，自动生成静态网页，可以在本机浏览；</li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy8=">NexT<i class="fa fa-external-link-alt"></i></span> 是 Hexo
的主题插件，本身依赖于 Hexo，提供额外的主题。它同样也提供
<code>_config.yml</code> 文件供我们配置；</li>
<li>使用 Github 将生成的静态网页推送到互联网当中。<span id="more"></span></li>
</ul>
<div class="note info"><p>新版本的 NexT 可以在博客根目录下配置 <code>_config.next.yml</code>
文件，这可以避免在使用 Github 更新 NexT
时与，本地的配置文件发生冲突，同时也不再用区别 Hexo 和 NexT
名称相同的配置文件。</p>
</div>
<h2 id="安装-hexo">安装 Hexo</h2>
<p>Hexo 的官方配置文档在<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">这里<i class="fa fa-external-link-alt"></i></span>。</p>
<p>首先安装一些必备的工具：<code>Node.js</code>；<code>Git</code>。</p>
<p>然后使用 <code>npm</code> 安装 Hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="初始化博客本地文件夹">初始化博客本地文件夹</h2>
<p>我们现在需要在本机的某一文件夹下初始化博客，例如想将博客文件放在
<code>\Blog</code> 目录下，在该文件夹中打开命令行，运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>运行上述命令之后，在 <code>\Blog</code>
文件夹下会生成如下子目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<div class="note info"><p>第一次使用 Hexo 命令时，可能会报关于 PowerShell 不能信任 Hexo
脚本的错误，并在界面中指向<span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL3Bvd2Vyc2hlbGwvbW9kdWxlL21pY3Jvc29mdC5wb3dlcnNoZWxsLmNvcmUvYWJvdXQvYWJvdXRfZXhlY3V0aW9uX3BvbGljaWVzP3ZpZXc9cG93ZXJzaGVsbC03LjM=">网址<i class="fa fa-external-link-alt"></i></span>。直接把执行策略改成
<code>Bypass</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy Bypass</span><br></pre></td></tr></table></figure>
</div>
<h2 id="配置博客">配置博客</h2>
<p>详细的配置步骤可见 Hexo 和 NexT 官方文档，不过更推荐看 NexT <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL2dldHRpbmctc3RhcnRlZC8=">的文档<i class="fa fa-external-link-alt"></i></span>，因为
NexT 的文档中既包含了 Hexo
的配置，同时一直在更新当中。这里列举了一些在教程之外的配置。</p>
<h3 id="自定义菜单栏内容">自定义菜单栏内容</h3>
<p>NexT 提供的菜单栏内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<p>我希望加入额外的标签页，用来记录点滴日常，新建标签如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nichijou:</span> <span class="string">/nichijou/</span> <span class="string">||</span> <span class="string">fa-regular</span> <span class="string">fa-sun</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>fa-regular fa-sun</code> 是来自 <span class="exturl" data-url="aHR0cHM6Ly9mb250YXdlc29tZS5jb20v">font awesome<i class="fa fa-external-link-alt"></i></span>
的图标。这时我们还需要配置语言，使得 NexT 能够识别关键词，在
<code>./theme/next/language</code> 目录下找到 <code>zh-CN.yml</code>，在
<code>menu</code> 关键词下添加如下翻译词对：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add user defined translation pair</span></span><br><span class="line"><span class="attr">nichijou:</span> <span class="string">日常</span></span><br></pre></td></tr></table></figure>
<p>在修改完配置文件之后，我们还需要生成博客 page 页面对应的
<code>.md</code> 文档，使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page nichijou</span><br></pre></td></tr></table></figure>
<p>之后会在 <code>./source</code> 目录下生成同名目录
<code>nichijou/</code>，同时在该目录中生成 <code>index.md</code>
文件。这样在点击博客菜单栏标题时，就会显示 <code>index.md</code>
的内容。</p>
<h3 id="公式显示">公式显示</h3>
<p>按照默认设置，博客显示的公式是 LaTeX 代码。因此需要修改
<code>_config.next.yml</code> 关于 <code>math</code> 部分的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="知识协议">知识协议</h3>
<p>配置的协议为 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzQuMC9kZWVkLnpoLWhhbnM=">cc
by-sa<i class="fa fa-external-link-alt"></i></span>，可以共享、修改、用于商业目的，但是必须在引用时指明来源，并且使用相同的协议。</p>
<h2 id="撰写博客的工作流程">撰写博客的工作流程</h2>
<h3 id="新建博客文档">新建博客文档</h3>
<p>新建文档的命令是 <code>new</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>可选参数 <code>[layout]</code>：默认是 <code>post</code>，可以选择为
<code>draft</code>，这时会在 <code>\source\_drafts</code>
目录下生成待发表的博客文档，并且没有时间戳；</li>
<li>文档题目
<code>&lt;title&gt;</code>：可以<strong>不添加后缀</strong>，默认生成
<code>&lt;title&gt;.md</code>
文档。如果题目中没有空格，也可以不用加双引号。</li>
</ul>
<p>例如新建文档：<a
href="https://qiuxiaohuo.github.io/2023/09/20/mytest/">测试我的第一篇博客文档</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new 测试我的第一篇博客文档</span><br></pre></td></tr></table></figure>
<p>这样就可以在 <code>\source</code> 目录下找到对应的
<code>测试我的第一篇博客文档.md</code> 文档了。</p>
<p>如果不想立即发表博客文档，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;博客草稿&quot;</span><br></pre></td></tr></table></figure>
<p>这时在生成网站文件时会自动忽略该文档。如果该草稿已经完成，则使用如下命令进行发表，hexo
会将该文档转移到 <code>\source\_posts</code> 目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish post &quot;博客草稿&quot;</span><br></pre></td></tr></table></figure>
<p>此外还可以在 <code>\scaffold</code> 目录下自定义模板文件，具体详见
hexo <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mvd3JpdGluZy5odG1s">写作<i class="fa fa-external-link-alt"></i></span>
文档。</p>
<h3 id="生成网站文件">生成网站文件</h3>
<p>首先先清理一下原来的站点文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>或者简写为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br></pre></td></tr></table></figure>
<p>然后生成静态文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>或简写为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>后面还可以加一点组合命令，比如 <code>-d</code>
表示生成完静态站点之后直接推送到 Github 上去，它与如下命令是等价的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy -g</span><br></pre></td></tr></table></figure>
<p>上个命令意思是在 <code>deploy</code> 之前先
<code>generate</code>。如果想在本机中查看网页生成的效果，可以运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>在配置完成之后，上传一篇博客文档的工作流程可以总结为：</p>
<ol type="1">
<li>在 目录中生成 <code>博客文档.md</code>
文件：<code>hexo new &lt;博客文档名称&gt;</code>；</li>
<li>编写 <code>博客文档.md</code> 文档 (可以不在 Hexo 生成的 .md
文件中编写，完成后将文档内容复制到该文件中)；</li>
<li>清除生成的静态文件：<code>hexo cl</code>；</li>
<li>重新生成静态文件：<code>hexo g</code>；</li>
<li>查看生成网页的效果，若不满意，则返回第 2
步：<code>hexo s</code>；</li>
<li>上传到
Github，博客的内容最终展示在互联网上：<code>hexo d</code></li>
</ol>
<h2 id="一些博客插件">一些博客插件</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL3RhZy1wbHVnaW5zL25vdGU=">NexT
主题下使用 note 标记<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>教你做事</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hill 参数表示横观各向同性的材料矩阵</title>
    <url>/mech/constitutive/%E4%BD%BF%E7%94%A8-Hill-%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%A8%AA%E8%A7%82%E5%90%84%E5%90%91%E5%90%8C%E6%80%A7%E7%9A%84%E6%9D%90%E6%96%99%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>参考文献：Micromechanics of Composite Materials，George J.
Dvorak，section 2.3</p>
<p>Hill（1964）给出一种横观各向同性材料更紧凑的表达方式： <span
class="math display">\[
\left[\begin{array}{l}
\sigma_{11} \\
\sigma_{22} \\
\sigma_{33} \\
\sigma_{23} \\
\sigma_{31} \\
\sigma_{12}
\end{array}\right]=\left[\begin{array}{cccccc}
n &amp; l &amp; l &amp; 0 &amp; 0 &amp; 0 \\
l &amp; k+m &amp; k-m &amp; 0 &amp; 0 &amp; 0 \\
l &amp; k-m &amp; k+m &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; m &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; p &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; p
\end{array}\right]\left[\begin{array}{c}
\varepsilon_{11} \\
\varepsilon_{22} \\
\varepsilon_{33} \\
2 \varepsilon_{23} \\
2 \varepsilon_{31} \\
2 \varepsilon_{12}
\end{array}\right]
\]</span> 式中 1 方向为纤维主方向，参数 <span
class="math inline">\(k,l,n,m,p\)</span>
与横观各向同性的工程常数之间的对应关系为<span id="more"></span> <span
class="math display">\[
\left.
\begin{aligned}
k=\left[ 2\frac{1-v_{23}}{E_{22}} - 4 \frac{v_{12}^2}{E_{11}}
\right]^{-1} \quad
l=2 k v_{12} \\
n=E_{11}+4 k v_{12}^2 = E_{11} + \frac{l^2}{k} \quad
m=G_{23} \quad
p=G_{21}
\end{aligned}
\right\}
\]</span></p>
<p><span class="math display">\[
\left.
\begin{aligned}
E_{11} = n - l^2/k \quad
v_{12} = l/2 k \quad
v_{21} = E_{22} v_{12} / E_{11} \\
E_{22} = E_{33} = \frac{4 m\left(k n-l^2\right)}{n(k+m)-l^2} \quad
v_{23} = v_{32}=\frac{n(k-m)-l^2}{n(k+m)-l^2}
\end{aligned}
\right\}
\]</span></p>
<p>为验证上述公式，我们不妨代入各向同性的材料参数，那么该公式最终应退化为各向同性的材料矩阵：
<span class="math display">\[
k = \frac{E}{2(1+\nu)(1-2\nu)} = \lambda + \mu, \quad
l = \frac{\nu E}{(1+\nu)(1-2\nu)} = \lambda, \quad
n = \frac{\mu(3\lambda + 2\mu)}{\lambda + \mu} +
\frac{\lambda^2}{\lambda+\mu} = \lambda + 2\mu
\]</span> 以及 <span class="math display">\[
m = p = \mu
\]</span> 值得指出的是，使用 Hill
参数表示横观各向同性材料刚度矩阵，关系式 <span class="math display">\[
\frac{C_{33} - C_{32}}{2} = C_{44}
\]</span>
更方便直接看出。这也是横观各向同性材料与一般的正交各向异性材料之间的差别</p>
]]></content>
      <categories>
        <category>本构理论</category>
      </categories>
      <tags>
        <tag>弹性力学</tag>
        <tag>横观各向同性</tag>
      </tags>
  </entry>
  <entry>
    <title>弹性有限变形</title>
    <url>/mech/constitutive/%E5%BC%B9%E6%80%A7%E6%9C%89%E9%99%90%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="弹性有限变形的一般本构方程">弹性有限变形的一般本构方程</h2>
<p>在本节推导中假设如下:</p>
<ol type="1">
<li><p>材料在参考构型中的内能体积密度 <span class="math inline">\(W =
\rho_0 e\)</span> 可以表示为变形梯度的函数, <span
class="math inline">\(W= W(F)\)</span>;</p></li>
<li><p>不考虑材料与外部的热交换, 因此能量守恒定律表述为</p>
<p><span class="math display">\[
\begin{equation}
\frac{\mathrm{D} W}{\mathrm{D} t} = J \sigma : v \nabla
\label{eq:energy_conservation}
\end{equation}
\]</span></p></li>
</ol>
<p>式中, <span class="math inline">\(J \triangleq \det F =
\rho_0/\rho\)</span>. 上式左端应用链式法则得到 <span
class="math display">\[
\begin{equation}
\frac{\mathrm{D} W}{\mathrm{D} t} = \frac{\partial W}{\partial F} :
\frac{\mathrm{D} F}{\mathrm{D} t}
= \left( \frac{\partial W}{\partial F} \cdot F^{\top} \right) : v \nabla
\label{eq:matl_deriv_of_e_density}
\end{equation}
\]</span> 对比式 <span
class="math inline">\(\ref{eq:energy_conservation}\)</span> 与式 <span
class="math inline">\(\ref{eq:matl_deriv_of_e_density}\)</span>,
再由速度梯度场的任意性可得等式 <span class="math display">\[
\sigma = \frac{1}{J} \frac{\partial W}{\partial F} \cdot F^{\top}
\]</span> 上式从形式看很简单, 但需要确定 <span
class="math inline">\(W\)</span> 关于变形梯度 <span
class="math inline">\(F\)</span> <strong>9 个分量</strong>的函数形式.
因此在实际操作中不可用.
接下来通过本构的<strong>客观性原理</strong>和<strong>材料的对称性</strong>减少
<span class="math inline">\(W\)</span> 的函数独立变量数量.</p>
<h3
id="客观性原理对内能体积密度函数的简化">客观性原理对内能体积密度函数的简化</h3>
<p>考虑变形 1 和变形 2, 变形 1 给出变形梯度场 <span
class="math inline">\(F\)</span>, 变形 2 在变形 1 的基础上作施加旋转场
<span class="math inline">\(Q\)</span>, 因此变形 2 的变形梯度场为 <span
class="math display">\[
F&#39; = Q \cdot F
\]</span> 经旋转之后, 内能密度在每个物质点 <span
class="math inline">\(X\)</span> 处应保持不变, 因此有 <span
class="math display">\[
W(F) \equiv W(Q \cdot F)
\]</span> 又因为变形梯度可以通过极分解原理分解为正交张量 <span
class="math inline">\(R\)</span> 和对称正定张量 <span
class="math inline">\(U\)</span>, 作变量替换, 得到关于 <span
class="math inline">\(U\)</span> 的内能密度函数 <span
class="math inline">\(\widetilde W\)</span> <span
class="math display">\[
\widetilde W(U, R) \triangleq W(R \cdot U)
\]</span> 在任意旋转下 <span class="math inline">\(\widetilde W\)</span>
保持不变, 所以 <span class="math display">\[
\widetilde W(U, R) \equiv W(Q \cdot R \cdot U)
\]</span> 因此总可以选取一个旋转场: <span class="math inline">\(Q \equiv
R^{-1}\)</span>, 上式转化为 <span class="math display">\[
\widetilde W(U, R) \equiv W( U)
\]</span> 因此, 内能密度函数可以表示为关于右伸长张量 <span
class="math inline">\(U\)</span> 的函数, 并且函数形式与 <span
class="math inline">\(W(U)\)</span> 相同. 这样就将分量的个数简化为
<strong>6 个</strong>. 又因为 <span class="math inline">\(U =
\sqrt{C}\)</span>, 所以 <span class="math display">\[
\hat{W}(C) = W(\sqrt{C})
\]</span> 在上述推导中, 为了区分不同的函数表达形式, 使用记号 <span
class="math inline">\(\widetilde{W}\)</span> 或 <span
class="math inline">\(\hat{W}\)</span>, 之后则不加区别地使用函数记号
<span class="math inline">\(W\)</span>.</p>
<p>如果将内能密度考虑为右 Cauchy-Green 张量 <span
class="math inline">\(C\)</span> 的函数, 那么 <span
class="math inline">\(W\)</span> 的物质导数为 <span
class="math display">\[
\frac{\mathrm{D} W}{\mathrm{D} t}
= \left[ F \cdot \left( \frac{\partial W}{\partial C} + \frac{\partial
W}{\partial C^{\top}} \right) \cdot F^{\top} \right] : v \nabla
\]</span> 如果 <span class="math inline">\(W\)</span> 可以表示为关于分量
<span class="math inline">\(C_{IJ}\)</span> 的对称函数, 也即 <span
class="math inline">\(W(C_{IJ}) \equiv W(C_{JI})\)</span>,
那么上式又可以化简为 <span class="math display">\[
\frac{\mathrm{D} W}{\mathrm{D} t}
= \left( F \cdot 2 \frac{\partial W}{\partial C} \cdot F^{\top} \right)
: v \nabla
\]</span> 再比较上式和式 <span
class="math inline">\(\ref{eq:energy_conservation}\)</span>, 就得到
<span class="math display">\[
\begin{equation}
\boxed{
\sigma = \frac{1}{J} F \cdot 2 \frac{\partial W}{\partial C} \cdot
F^{\top}
}
\label{eq:sigma_rep_as_psi_to_C}
\end{equation}
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<h5 id="内能密度函数与-pk2-应力的关系">内能密度函数与 PK2
应力的关系</h5>
<p>Cauchy 应力与 PK2 应力之间的关系为 <span class="math display">\[
F \cdot S \cdot F^{\top} = J \sigma \quad
\]</span> 再根据式 <span
class="math inline">\(\ref{eq:sigma_rep_as_psi_to_C}\)</span>, 就得到
<span class="math display">\[
\boxed{
S = 2 \frac{\partial W}{\partial C}
}
\]</span></p>
</blockquote>
<blockquote>
<p>[!NOTE]</p>
<h5 id="小变形下的近似">小变形下的近似</h5>
<p>在小变形下, <span class="math display">\[
C \sim I + 2 \varepsilon
\]</span> 因此 <span class="math display">\[
\frac{\partial W}{\partial \varepsilon} \sim 2 \frac{\partial
W}{\partial C}
\]</span> 将式 (4) 展开为位移梯度的函数 <span class="math display">\[
\sigma \sim \frac{1}{1 + \mathrm{tr}(u\nabla)}
(I + u \nabla) \cdot \frac{\partial W}{\partial \varepsilon} \cdot (I +
\nabla u) \\
\sim \frac{\partial W}{\partial \varepsilon}
+ 2\frac{\partial W}{\partial \varepsilon} \cdot \varepsilon
+ \mathcal{O}(\varepsilon^2)
\]</span> 忽略掉关于 <span class="math inline">\(\varepsilon\)</span>
的一阶和二阶项, 得到 <span class="math display">\[
\boxed{
\sigma = \frac{\partial W}{\partial \varepsilon}
}
\]</span></p>
</blockquote>
<h3 id="各向同性对内能密度函数的简化">各向同性对内能密度函数的简化</h3>
<p>考虑旋转矩阵 <span class="math inline">\(Q\)</span>, 若材料对 <span
class="math inline">\(Q\)</span> 具有旋转不变性, 那么 <span
class="math display">\[
W(C) \equiv W(Q^{\top} \cdot C \cdot Q)
\]</span> 特别的, 对于<strong>各向同性材料</strong>, <span
class="math inline">\(Q\)</span> 是任意的, 上式等价于 <span
class="math inline">\(W\)</span> 在任意坐标变化下形式不变,
因此内能密度函数 <span class="math inline">\(W\)</span>
可以写成应变不变量 <span
class="math inline">\(\ref{eq:invariants_1}\)</span> 的函数: <span
class="math display">\[
W = W(\mathscr{I}_1, \mathscr{I}_2, \mathscr{I}_3)
\]</span> 根据链式法则, <span class="math inline">\(W\)</span> 对右
Cauchy-Green 张量 <span class="math inline">\(C\)</span> 的导数为 <span
class="math display">\[
\frac{\partial W}{\partial \boldsymbol{C}}
= \frac{\partial W}{\partial \mathscr{I}_1} \frac{\partial
\mathscr{I}_1}{\partial \boldsymbol{C}}
+ \frac{\partial W}{\partial \mathscr{I}_2} \frac{\partial
\mathscr{I}_2}{\partial \boldsymbol{C}}
+ \frac{\partial W}{\partial \mathscr{I}_3} \frac{\partial
\mathscr{I}_3}{\partial \boldsymbol{C}}
\]</span> 式中, 应变不变量对 <span
class="math inline">\(\boldsymbol{C}\)</span> 的导数为 <span
class="math display">\[
\boxed{
\frac{\partial \mathscr{I}_1}{\partial \boldsymbol{C}} = \boldsymbol{I},
\quad
\frac{\partial \mathscr{I}_2}{\partial \boldsymbol{C}} =
\mathscr{I}_1\boldsymbol{I} - \boldsymbol{C}, \quad
\frac{\partial \mathscr{I}_3}{\partial \boldsymbol{C}} =
\mathscr{I}_3\boldsymbol{C}^{-1}
}
\]</span> 代入 <span class="math inline">\(\partial W / \partial
\boldsymbol{C}\)</span>, <span class="math display">\[
\frac{\partial W}{\partial \boldsymbol{C}}
= W_{,1} \boldsymbol{I} + W_{,2} (\mathscr{I}_1\boldsymbol{I} -
\boldsymbol{C}) + W_{,3}\mathscr{I}_3 \boldsymbol{C}^{-1}
\]</span> 式中, <span class="math inline">\(W_{,i} = {\partial
W}/{\partial \mathscr{I}_i}\)</span>. 再根据式 <span
class="math inline">\(\ref{eq:sigma_rep_as_psi_to_C}\)</span> , 并应用
<span class="math inline">\(\mathscr{I}_3 = J^2\)</span> ,
就得到应力的表达式 <span class="math display">\[
\boldsymbol{\sigma} = \frac{1}{\sqrt{\mathscr{I}_3}} \boldsymbol{F}
\cdot 2 \left( W_{,1} \boldsymbol{I} + W_{,2}
(\mathscr{I}_1\boldsymbol{I} - \boldsymbol{C}) + W_{,3}\mathscr{I}_3
\boldsymbol{C}^{-1} \right) \cdot \boldsymbol{F}^{\top}
\]</span> 注意到 <span class="math inline">\(\boldsymbol{B}\)</span> 与
<span class="math inline">\(\boldsymbol{C}\)</span> 之间的关系满足 <span
class="math display">\[
\boldsymbol{F} \cdot \boldsymbol{C}^{n} \cdot \boldsymbol{F}^{\top}
= \boldsymbol{F} \cdot ( \boldsymbol{F}^{\top} \cdot \boldsymbol{F}
\cdot \boldsymbol{F}^{\top} \cdots \boldsymbol{F}^{\top} \cdot
\boldsymbol{F} ) \cdot \boldsymbol{F}^{\top}
= \boldsymbol{B}^{n+1}, \quad n \in \mathbb{Z}
\]</span> 所以应力 <span class="math inline">\(\sigma\)</span>
又可以写作关于 <span class="math inline">\(B\)</span> 的形式 <span
class="math display">\[
\boxed{
\boldsymbol{\sigma} = \frac{1}{\sqrt{\mathscr{I}_3}} 2 \left(
W_{,3}\mathscr{I}_3 I
+(W_{,1} + W_{,2} \mathscr{I}_1) B
- W_{,2} B^2 \right)
}
\]</span> 根据 Cayley-Hamilton 定理, 得到关于 <span
class="math inline">\(B\)</span> 的代数恒等式 <span
class="math display">\[
\boldsymbol{B}^2 \equiv \mathscr{I}_1 \boldsymbol{B} - \mathscr{I}_2
\boldsymbol{I} + \mathscr{I}_3 \boldsymbol{B}^{-1}
\]</span> 代回之前用 <span class="math inline">\(\boldsymbol{B}\)</span>
表示的应力表达式中, 得到使用 <span class="math inline">\(\{
\boldsymbol{B}^{-1}, \boldsymbol{B} \}\)</span> 表示的应力 <span
class="math display">\[
\boxed{
\boldsymbol{\sigma} = \frac{1}{\sqrt{\mathscr{I}_3}} 2 \left(
W_{,1} \boldsymbol{B}
+ (W_{,2} \mathscr{I}_2 + W_{,3}\mathscr{I}_3) \boldsymbol{I}
- W_{,2} \mathscr{I}_3 \boldsymbol{B}^{-1} \right)
}
\]</span></p>
<blockquote>
<p>[!TIP]</p>
<h5 id="使用-barmathscri_1-barmathscri_2-j-表示各向同性弹性材料">使用
<span class="math inline">\(\{\bar{\mathscr{I}}_1, \bar{\mathscr{I}}_2,
J \}\)</span> 表示各向同性弹性材料</h5>
<p>通过链式法则, 可以得到 <span class="math display">\[
\begin{equation}
\boxed{
\boldsymbol{\sigma} = \frac{2}{J} \left[
\frac{1}{J^{2/3}} \left( W_{,1} + \bar{\mathscr{I}}_1 W_{,2} \right)
\boldsymbol{B}
- \frac{1}{3} (\bar{\mathscr{I}}_1 W_{,1} + 2\bar{\mathscr{I}}_2 W_{,2})
\boldsymbol{I}
- \frac{1}{J^{4/3}} W_{,2} \boldsymbol{B}^2
\right]
+ W_{,3} \boldsymbol{I}
}
\label{eq:cons_rep_as_B_inva_3}
\end{equation}
\]</span></p>
</blockquote>
<h3 id="考虑材料不可压缩的情况">考虑材料不可压缩的情况</h3>
<p>当材料不可压缩时 <span class="math display">\[
\mathscr{I}_3 \equiv 1
\]</span> 对于不可压缩情况, 不可以直接令 <span
class="math inline">\(\mathscr{I}_3 = 1\)</span>, 因为这会导致式中函数
<span class="math inline">\(W\)</span> 导数项爆破. 使用 Lagrange
乘子将不可压缩的特性考虑进去: <span class="math display">\[
\widetilde W = W(\mathscr{I}_1, \mathscr{I}_2) - \frac{1}{2}p
(\mathscr{I}_3 -1)
\]</span></p>
<p><span class="math display">\[
\sigma
= - pI
+ (2W_{,1} + 2W_{,2}\mathscr{I}_1) B
- 2W_{,2} B^2
\]</span></p>
<p><em>动力学约束中, <span class="math inline">\(p\)</span>
只能通过平衡方程求解, 无法通过本构关系得到</em></p>
<h2 id="一些超弹本构">一些超弹本构</h2>
<h3 id="hypoelasticity-材料">Hypoelasticity 材料</h3>
<p>在绝大多数情况下, 只有当材料受剪时才会表现出非线性的响应 (与 <span
class="math inline">\(\mathscr{I}&#39;_2\)</span> 相关),
同时应力与体积变化呈线性关系 (与 <span
class="math inline">\(\mathscr{I}_1\)</span> 相关).
一种定义内能密度函数的方式为 <span class="math display">\[
W(\mathscr{I}_1, \mathscr{I}&#39;_2)
= \frac{1}{6} K \mathscr{I}_1^2 + \frac{2n \sigma_0 \varepsilon_0}{n+1}
\left( \frac{\mathscr{I}&#39;_2}{\varepsilon_0^2} \right)^{(n+1)/2n}
\]</span> 对应变 <span class="math inline">\(\varepsilon\)</span>
求导数得到 <span class="math display">\[
\boldsymbol{\sigma} = \frac{ \partial W }{ \partial \varepsilon}
= \frac{1}{3}K \mathscr{I}_1 \mathbf{I}
+ \sigma_0 \left( \frac{\mathscr{I}&#39;_2}{\varepsilon_0^2}
\right)^{(1-n)/2n}
\frac{\boldsymbol{\varepsilon}&#39;}{\varepsilon_0}
\]</span> 或者表示成关于应力的表达式: <span class="math display">\[
\boldsymbol{\varepsilon} = \frac{1}{3K} \mathscr{J}_1 \mathbf{I}
+ \varepsilon_0 \left( \frac{\mathscr{J}_2}{\sigma_0^2}
\right)^{(n-1)/2} \frac{\boldsymbol{\sigma}&#39;}{\sigma_0}
\]</span> 式中, <span class="math inline">\(\mathscr{J}_1\)</span>,
<span class="math inline">\(\mathscr{J}_2\)</span>
为应力的第一和第二不变量: <span class="math display">\[
\mathscr{J}_1 \triangleq \mathrm{tr}~\sigma, \quad
\mathscr{J}_2 \triangleq \frac{1}{2}
\left( \mathrm{tr}~ \sigma^2
- \frac{1}{3}(\mathrm{tr}~\sigma)^2 \right)
\]</span> 由此可以得到以下三种工况的应力应变关系:</p>
<ol type="1">
<li><p>单轴拉伸. 应力分量为 <span
class="math inline">\(\sigma_1\)</span>. 此时没有剪切变形, 应变分量为
<span class="math display">\[
\varepsilon_{11} = \frac{1}{3K} \sigma_1
+ \frac{2 \varepsilon_0}{\sqrt{3}} \left( \frac{\sigma_1}{\sqrt{3}
\sigma} \right)^{n}
\]</span></p></li>
<li><p>承受静水压力 <span class="math inline">\(-p\)</span>. 此时 <span
class="math inline">\(\mathscr{J}_2 = 0\)</span>, 因此变形为 <span
class="math display">\[
\boldsymbol{\varepsilon} = -\frac{p}{K} \mathbf{I}
\]</span></p></li>
<li><p>承受剪切力 <span class="math inline">\(\tau\)</span>.
此时应变只有对应剪应力分量处非零, 并满足幂形式: <span
class="math display">\[
\varepsilon = \varepsilon_0 \left( \frac{\tau}{\sigma_0} \right)^n
\]</span></p></li>
</ol>
<h3 id="neo-hookean-材料">Neo-Hookean 材料</h3>
<p>内能密度函数为 <span class="math display">\[
\boxed{
W(\bar{\mathscr{I}}_1, J)
= \frac{1}{2} \mu (\bar{\mathscr{I}}_1 - 3)
+ \frac{1}{2} K (J - 1)^2
}
\]</span></p>
<p>式中, <span class="math inline">\(\mu\)</span> 和 <span
class="math inline">\(K\)</span> 为材料参数,
在小变形的情况下分别对应剪切和 bulk 模量. 对于近不可压缩材料, <span
class="math inline">\(K \gg \mu\)</span>. 将 <span
class="math inline">\(W\)</span> 对不变量的导数带入到式 <span
class="math inline">\(\ref{eq:cons_rep_as_B_inva_3}\)</span> 中得到
<span class="math display">\[
\boxed{
\boldsymbol{\sigma}
= \frac{\mu}{J^{5/3}} ~\mathrm{dev}\boldsymbol{B}
+  K(J-1)\boldsymbol{I}
}
\]</span></p>
<h3 id="mooney-rivlin-材料">Mooney-Rivlin 材料</h3>
<p>内能密度函数为 <span class="math display">\[
\boxed{
W(\bar{\mathscr{I}}_1, \bar{\mathscr{I}}_2, J)
= \frac{1}{2} \mu_1 (\bar{\mathscr{I}}_1 - 3)
+ \frac{1}{2} \mu_2 (\bar{\mathscr{I}}_2 - 3)
+ \frac{1}{2} K (J - 1)^2
}
\]</span> 式中, <span class="math inline">\(\mu_1\)</span>, <span
class="math inline">\(\mu_2\)</span> 和 <span
class="math inline">\(K\)</span> 为材料参数, 对于近不可压缩材料, <span
class="math inline">\(K \gg \mu_1 , \mu_2\)</span>. 应力应变关系为 <span
class="math display">\[
\boxed{
\boldsymbol{\sigma}
= \frac{\mu_1}{J^{5/3}} ~\mathrm{dev}\boldsymbol{B}
+ \frac{\mu_2}{J^{7/3}} \left(
\mathscr{I}_1 \boldsymbol{B}
- \frac{2}{3} \mathscr{I}_2 \boldsymbol{I}
- \boldsymbol{B}^2
\right)
+ K(J-1)\boldsymbol{I}
}
\]</span></p>
<h2 id="附录-应变的不变量">附录: 应变的不变量</h2>
<p>我们使用右 Cauchy-Green 张量 <span class="math inline">\(C\)</span>
的不变量定义应变的不变量 <span class="math display">\[
\begin{equation}
\begin{gathered}
\mathscr{I}_1 = \mathrm{tr}~C \\
\mathscr{I}_2 = \frac{1}{2} \left( (\mathrm{tr}~C)^2 - \mathrm{tr}~C^2
\right) \\
\mathscr{I}_3 = \det C
\label{eq:invariants_1}
\end{gathered}
\end{equation}
\]</span> 如果定义 <span class="math inline">\(C\)</span> 的特征值为
<span class="math inline">\(\lambda_1^2\)</span>, <span
class="math inline">\(\lambda_2^2\)</span>, <span
class="math inline">\(\lambda_3^2\)</span>,
那么上述应变不变量又可以表述为 <span class="math display">\[
\mathscr{I}_1 = \lambda_1^2 + \lambda_2^2 + \lambda_3^2 \\
\mathscr{I}_2 = \lambda_1^2 \lambda_2^2 + \lambda_1^2 \lambda_3^2 +
\lambda_1^2 \lambda_3^2 \\
\mathscr{I}_3 = \lambda_1^2 \lambda_2^2\lambda_3^2
\]</span></p>
<p>注意到 <span class="math inline">\(C\)</span> 的不变量与左
Cauchy-Green 张量 <span class="math inline">\(B\)</span> 相同, 因此式
(5) 中将 <span class="math inline">\(C\)</span> 替换为 <span
class="math inline">\(B\)</span> 同样成立.</p>
<p>Cayley-Hamilton 定理给出关于 <span class="math inline">\(C\)</span>
<span class="math inline">\(B\)</span> 以及不变量作为系数的恒等式: <span
class="math display">\[
C^3 - \mathscr{I}_1 C^2 + \mathscr{I}_2 C - \mathscr{I}_3 I = 0 \\
B^3 - \mathscr{I}_1 B^2 + \mathscr{I}_2 B - \mathscr{I}_3 I = 0
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<p>如果考虑仿射量 <span class="math inline">\(A\)</span> 的 deviatoric
部分: <span class="math display">\[
A&#39; = A - \frac{1}{3} (\mathrm{tr}A)~ I
\]</span> <span class="math inline">\(A&#39;\)</span> 的不变量定义与式
(0) 一致, 那么 <span class="math display">\[
\begin{equation}
\begin{gathered}
\mathscr{I}&#39;_1 = \mathrm{tr}A&#39; = 0 \\
\mathscr{I}&#39;_2 = \frac{1}{2} \left( (\mathrm{tr}A&#39;)^2 -
\mathrm{tr}A&#39;^2 \right) \\
\mathscr{I}&#39;_3 = \det A&#39;
\end{gathered}
\label{eq:invariants_2}
\end{equation}
\]</span> 不变量 <span class="math inline">\((\mathscr{I}&#39;_1,
\mathscr{I}&#39;_2, \mathscr{I}&#39;_3)\)</span> 也可以通过 <span
class="math inline">\((\mathscr{I}_1, \mathscr{I}_2,
\mathscr{I}_3)\)</span> 表示, 或者 <span
class="math inline">\((\mathrm{tr}A, \mathrm{tr}A^2,
\mathrm{tr}A^3)\)</span> 表示. 例如, <span
class="math inline">\(A&#39;\)</span> 的第二不变量可以表示为 <span
class="math display">\[
\mathscr{I}&#39;_2 = \frac{1}{2} \left( (\mathrm{tr}A&#39;)^2 -
\mathrm{tr}A&#39;^2 \right)
= -\frac{1}{2}
\mathrm{tr}\left( A^2 - \frac{2}{3} (\mathrm{tr}A)~ A + \frac{1}{9}
(\mathrm{tr}A)^2~ I \right)
= -\frac{1}{2} \mathrm{tr}A^2 + \frac{1}{6} (\mathrm{tr}A)^2
= \mathscr{I}_2 -\frac{1}{3} \mathscr{I}_1^2
\]</span> 可以证明, 上述定义的 <span
class="math inline">\(\mathscr{I}&#39;_2\)</span> 总是负值, 如果 <span
class="math inline">\(A\)</span> 的特征值总是大于 0. 因此我们重定义
<span class="math inline">\(\mathscr{I}&#39;_2\)</span> 为原来的负数,
使得它总是大于 0: <span class="math display">\[
\mathscr{I}&#39;_2 := -\mathscr{I}&#39;_2 &gt; 0
\]</span></p>
</blockquote>
<blockquote>
<p>[!NOTE]</p>
<h5
id="应用于近不可压缩情况下的应变不变量">应用于近不可压缩情况下的应变不变量</h5>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\bar{\mathscr{I}}_1 &amp;= \frac{\mathscr{I}_1}{J^{2/3}}, \\
\bar{\mathscr{I}}_2 &amp;= \frac{\mathscr{I}_2}{J^{4/3}}, \\
J &amp;= \sqrt{\mathscr{I}_3}
\end{aligned}
\label{eq:invariants_3}
\end{equation}
\]</span></p>
</blockquote>
]]></content>
      <categories>
        <category>本构理论</category>
      </categories>
      <tags>
        <tag>超弹性</tag>
        <tag>大变形</tag>
      </tags>
  </entry>
  <entry>
    <title>J2 塑性本构</title>
    <url>/mech/constitutive/J2-%E5%A1%91%E6%80%A7%E6%9C%AC%E6%9E%84/</url>
    <content><![CDATA[<div class="pdf-container" data-target="https://maipdf.cn/est/d66482f3e37a9b/pdf" data-height="800px"></div>
]]></content>
      <categories>
        <category>本构理论</category>
      </categories>
      <tags>
        <tag>本构</tag>
      </tags>
  </entry>
  <entry>
    <title>推导非线性本构时用到的张量运算</title>
    <url>/mech/constitutive/%E6%8E%A8%E5%AF%BC%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%AC%E6%9E%84%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E5%BC%A0%E9%87%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="二阶张量-deviatoric-分解">二阶张量 deviatoric 分解</h2>
<p>对于二阶张量 <span
class="math inline">\(\boldsymbol{\varepsilon}\)</span>,
总可以做如下分解: <span class="math display">\[
\boldsymbol{\varepsilon}= \underbrace{\frac{1}{3} \mathrm{tr}
\left[\boldsymbol{\varepsilon}\right] \mathbf{I}}
  _{:= {\boldsymbol{\varepsilon}}^\mathrm{vol}}
  + \underbrace{\boldsymbol{\varepsilon}- \frac{1}{3} \mathrm{tr}
\left[\boldsymbol{\varepsilon}\right] \mathbf{I}}
    _{:= {\boldsymbol{\varepsilon}}^\mathrm{dev}},
\]</span> deviatoric 分解的性质为:<span id="more"></span></p>
<ol type="1">
<li><p>算子 <span class="math inline">\({(\cdot)}^\mathrm{vol}\)</span>
和 <span class="math inline">\({(\cdot)}^\mathrm{dev}\)</span>
是线性算子, <em>i.e.</em> <span class="math display">\[
{(\lambda\boldsymbol{\varepsilon}_1 +
\mu\boldsymbol{\varepsilon}_2)}^\mathrm{vol}
    = \lambda{\boldsymbol{\varepsilon}}^\mathrm{vol}_1 +
\mu{\boldsymbol{\varepsilon}}^\mathrm{vol}_2, \quad
    {(\lambda\boldsymbol{\varepsilon}_1 +
\mu\boldsymbol{\varepsilon}_2)}^\mathrm{dev}
    = \lambda{\boldsymbol{\varepsilon}}^\mathrm{dev}_1 +
\mu{\boldsymbol{\varepsilon}}^\mathrm{dev}_2,
\]</span></p></li>
<li><p>偏张量的迹等于 0: <span class="math display">\[
\mathrm{tr} \left[{\boldsymbol{\varepsilon}}^\mathrm{dev}\right] =
\mathrm{tr} \left[\boldsymbol{\varepsilon}\right] - \frac{1}{3}
\mathrm{tr} \left[\boldsymbol{\varepsilon}\right] \mathrm{tr}
\left[\mathbf{I}\right] = 0;
\]</span></p></li>
<li><p>volumatric 部分和 deviatoric 部分双点积结果为 0: <span
class="math display">\[
{\boldsymbol{\sigma}}^\mathrm{dev} :
{\boldsymbol{\varepsilon}}^\mathrm{vol} = \frac{1}{3} \mathrm{tr}
\left[\boldsymbol{\varepsilon}\right] {\boldsymbol{\sigma}}^\mathrm{dev}
: \mathbf{I}
    = \frac{1}{3} \mathrm{tr} \left[\boldsymbol{\varepsilon}\right]
\mathrm{tr} \left[{\boldsymbol{\sigma}}^\mathrm{dev} \cdot
\mathbf{I}\right] = 0.
\]</span></p></li>
</ol>
<p>性质 2 使得在计算材料的应变能密度时,
能量可以分解为由静水压力引起的应变能, 和材料畸变导致的应变能: <span
class="math display">\[
\boldsymbol{\sigma}: \boldsymbol{\varepsilon}=
{\boldsymbol{\sigma}}^\mathrm{vol}:{\boldsymbol{\varepsilon}}^\mathrm{vol}
+
{\boldsymbol{\sigma}}^\mathrm{dev}:{\boldsymbol{\varepsilon}}^\mathrm{dev},
\]</span></p>
<h2 id="四阶单位张量">四阶单位张量</h2>
<p>四阶单位张量有三种, 写成分量形式为: <span class="math display">\[
\mathcal{A}_{ijkl} = \delta_{ij}\delta_{kl}, \quad
  \mathcal{B}_{ijkl} = \delta_{ik}\delta_{jl}, \quad
  \mathcal{C}_{ijkl} = \delta_{il}\delta_{jk}.
\]</span> 定义如下两种四阶张量符号: <span class="math display">\[
\{\mathbf{I}\otimes \mathbf{I}\}_{ijkl} = \mathcal{A}_{ijkl}, \quad
  \{\mathbb{I}\}_{ijkl}  = \frac{1}{2}(\mathcal{B}_{ijkl} +
\mathcal{C}_{ijkl}).
\]</span> 二阶对称张量 <span
class="math inline">\(\boldsymbol{\sigma}\)</span> 分别与四阶单位张量
<span class="math inline">\(\mathbf{I}\otimes \mathbf{I}\)</span>, <span
class="math inline">\(\mathbb{I}\)</span> 双点积的结果为 <span
class="math display">\[
\begin{gathered}
  \mathbf{I}\otimes \mathbf{I}:\boldsymbol{\sigma}=
\boldsymbol{\sigma}:\mathbf{I}\otimes \mathbf{I}= \delta_{ij}\delta_{kl}
\sigma_{kl}
  = \delta_{ij} \sigma_{kk}
  = \mathrm{tr} \left[\boldsymbol{\sigma}\right]\mathbf{I};\\
  \mathbb{I}:\boldsymbol{\sigma}= \boldsymbol{\sigma}:\mathbb{I}=
\frac{1}{2} (\delta_{ik}\delta_{jl}\sigma_{kl}
  + \delta_{il}\delta_{jk}\sigma_{kl}
    )
    = \frac{1}{2}(\sigma_{ij}+\sigma_{ji})
    = \boldsymbol{\sigma}.\end{gathered}
\]</span> 如果用 Voigt 记法将四阶单位张量表示为矩阵的形式, 那么 <span
class="math display">\[
[\mathbf{I}\otimes \mathbf{I}]= \begin{pmatrix}
    1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}, \quad
[\mathbb{I}] = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2}
    \end{pmatrix}.
    \label{eq:idtt_voigt}
\]</span></p>
<p><span class="math inline">\([\mathbb{I}]\)</span> 在 Voigt
记法中并不是 <span class="math inline">\(\mathbb{R}^{6 \times
6}\)</span> 的单位矩阵, 这是因为 Voigt 映射规则将张量 <span
class="math inline">\(\mathcal{B}\)</span> 和 <span
class="math inline">\(\mathcal{C}\)</span> 分别映射为 <span
class="math display">\[
[\mathcal{B}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}, \quad
    [\mathcal{C}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}.
\]</span></p>
<h2
id="各向同性弹性张量的不同表示方法">各向同性弹性张量的不同表示方法</h2>
<p>对于各向同性材料, 四阶弹性模量张量 <span
class="math inline">\(L_{ijkl}\)</span> 可以用 <span
class="math inline">\(\rm Lam\acute{e}\)</span> 系数表示为 <span
class="math display">\[
L_{ijkl} \triangleq \lambda \delta_{ij} \delta_{kl}
                       + \mu \delta_{ik} \delta_{jl}
                       + \mu \delta_{il} \delta_{jk},
\]</span> 将上式写成张量形式 <span
class="math inline">\(\mathbb{L}\)</span> 为 <span
class="math display">\[
\mathbb{L} = \lambda \mathbf{I}\otimes \mathbf{I}+ 2\mu \mathbb{I}.
\]</span> 同样的, 我们也可以将柔度张量写为 <span class="math display">\[
\mathbb{M} = -\frac{\lambda}{2\mu(3\lambda + 2\mu)}
\mathbf{I}\otimes\mathbf{I}
+ \frac{1}{2\mu} \mathbb{I}
\]</span> 也可以用常数 <span class="math inline">\(K\)</span> 与 <span
class="math inline">\(\mu\)</span>, 将 <span
class="math inline">\(\mathbb{L}\)</span> 写成类似于二阶张量 deviatoric
分解的形式: <span class="math display">\[
\mathbb{L}:= K \mathbf{I}\otimes \mathbf{I}+ 2\mu \left(\mathbb{I}-
\frac{1}{3}\mathbf{I}\otimes \mathbf{I}\right).
\tag{1}
\]</span> 式中, <span class="math inline">\(K = \lambda +
\frac{2}{3}\mu\)</span>. 又因为 <span class="math display">\[
\begin{gathered}
    \mathbf{I}\otimes \mathbf{I}:
{\boldsymbol{\varepsilon}}^\mathrm{vol} =
3{\boldsymbol{\varepsilon}}^\mathrm{vol}, \quad
    \mathbf{I}\otimes \mathbf{I}:
{\boldsymbol{\varepsilon}}^\mathrm{dev} = 0,\\
    \left(\mathbb{I}- \frac{1}{3}\mathbf{I}\otimes \mathbf{I}\right) :
{\boldsymbol{\varepsilon}}^\mathrm{vol} = 0, \quad
    \left(\mathbb{I}- \frac{1}{3}\mathbf{I}\otimes \mathbf{I}\right) :
{\boldsymbol{\varepsilon}}^\mathrm{dev} =
{\boldsymbol{\varepsilon}}^\mathrm{dev},
  \end{gathered}
\]</span> 所以如果使用式 (1) 的表示方法, 对应变的 deviatoric
分解作双点积运算, 交叉项等于 0, 由此得到更紧凑的结果: <span
class="math display">\[
\begin{aligned}
    \mathbb{L}:({\boldsymbol{\varepsilon}}^\mathrm{vol} +
{\boldsymbol{\varepsilon}}^\mathrm{dev})
    &amp;= K \mathbf{I}\otimes \mathbf{I}:
{\boldsymbol{\varepsilon}}^\mathrm{vol}
     + 2\mu \left(\mathbb{I}- \frac{1}{3}\mathbf{I}\otimes
\mathbf{I}\right):{\boldsymbol{\varepsilon}}^\mathrm{dev} \\
    &amp;= 3K {\boldsymbol{\varepsilon}}^\mathrm{vol} + 2\mu
{\boldsymbol{\varepsilon}}^\mathrm{dev}.
  \end{aligned}
\]</span></p>
<h2 id="张量导数">张量导数</h2>
<p>二阶对称张量 <span class="math inline">\(\boldsymbol{\sigma}\)</span>
对自身的导数为 <span class="math display">\[
\frac{\partial\boldsymbol{\sigma}}{\partial\boldsymbol{\sigma}} =
\mathbb{I}.
\]</span> 张量的迹<span class="math inline">\(\mathrm{tr}
\left[\boldsymbol{\sigma}\right]\)</span> 对张量 <span
class="math inline">\(\boldsymbol{\sigma}\)</span> 的导数为 <span
class="math display">\[
\frac{\partial\mathrm{tr}
\left[\boldsymbol{\sigma}\right]}{\partial\boldsymbol{\sigma}}
  = \frac{\partial\sigma_{kk}}{\partial\sigma_{ij}}
  = \delta_{ij}
  = \mathbf{I}.
\]</span> 偏张量 <span
class="math inline">\({\boldsymbol{\sigma}}^\mathrm{dev}\)</span>
对张量<span class="math inline">\(\boldsymbol{\sigma}\)</span> 的导数为
<span class="math display">\[
\frac{\partial \boldsymbol{\sigma}^{\mathrm{dev}}}{\partial
\boldsymbol{\sigma}}=\frac{\partial\left(\boldsymbol{\sigma}-\frac{1}{3}
\operatorname{tr}[\sigma] \mathbf{I}\right)}{\partial
\boldsymbol{\sigma}}=\mathbb{I}-\frac{1}{3} \mathbf{I} \otimes
\mathbf{I}
\]</span> 若二阶张量的范数定义为张量的双点积 <span
class="math display">\[
\|\boldsymbol{\sigma}\|^2 := \mathrm{tr} \left[\boldsymbol{\sigma}\cdot
\boldsymbol{\sigma}\right] = \sigma_{ij}\sigma_{ij}.
\]</span> 那么张量范数的导数为 <span class="math display">\[
\frac{\partial\|\boldsymbol{\sigma}\|}{\partial\boldsymbol{\sigma}} =
\frac{1}{2\|\boldsymbol{\sigma}\|} (\mathbb{I}:\boldsymbol{\sigma}+
\boldsymbol{\sigma}:\mathbb{I})
  = \frac{\boldsymbol{\sigma}}{\|\boldsymbol{\sigma}\|} :=
\boldsymbol{n}_{\boldsymbol{\sigma}}.
\]</span> 注意到 <span class="math display">\[
{\boldsymbol{\sigma}}^\mathrm{dev}:\mathbf{I}\otimes \mathbf{I}=
\mathrm{tr} \left[{\boldsymbol{\sigma}}^\mathrm{dev}\right]\mathbf{I}=0,
\]</span> 因此 <span class="math display">\[
\frac{\partial\left\|\boldsymbol{\sigma}^{\mathrm{dev}}\right\|}{\partial
\boldsymbol{\sigma}}=\frac{\boldsymbol{\sigma}^{\mathrm{dev}}}{\left\|\boldsymbol{\sigma}^{\mathrm{dev}}\right\|}:
\frac{\partial \boldsymbol{\sigma}^{\mathrm{dev}}}{\partial
\boldsymbol{\sigma}}=\frac{\boldsymbol{\sigma}^{\mathrm{dev}}}{\left\|\boldsymbol{\sigma}^{\mathrm{dev}}\right\|}
.
\]</span> 张量法向 <span
class="math inline">\(\boldsymbol{n}_{\boldsymbol{\sigma}}\)</span>
对张量 <span class="math inline">\(\boldsymbol{\sigma}\)</span> 求导数,
得到 <span class="math display">\[
\frac{\partial\boldsymbol{n}_{\boldsymbol{\sigma}}}{\partial\boldsymbol{\sigma}}
= \frac{1}{\|\boldsymbol{\sigma}\|}
  (\mathbb{I}- \boldsymbol{n}_{\boldsymbol{\sigma}} \otimes
\boldsymbol{n}_{\boldsymbol{\sigma}}).
\]</span></p>
]]></content>
      <categories>
        <category>本构理论</category>
      </categories>
      <tags>
        <tag>张量</tag>
      </tags>
  </entry>
  <entry>
    <title>两点张量变形梯度</title>
    <url>/mech/continuum/%E4%B8%A4%E7%82%B9%E5%BC%A0%E9%87%8F%E5%8F%98%E5%BD%A2%E6%A2%AF%E5%BA%A6/</url>
    <content><![CDATA[<p>首先，连续体在初始时刻 <span class="math inline">\(t_0\)</span>
所占空间定义为参考构型 <span
class="math inline">\(\Omega_0\)</span>。在时刻 <span
class="math inline">\(t\)</span>，连续体从参考构型变形到当前构型<span
class="math inline">\(\Omega\)</span>。<span
class="math inline">\(\Omega_0\)</span> 与 <span
class="math inline">\(\Omega\)</span> 均为三维欧几里得向量空间 <span
class="math inline">\(E^3\)</span> 的子集。参考构型中点 <span
class="math inline">\(\boldsymbol{X}\)</span> 运动到当前构型点 <span
class="math inline">\(\boldsymbol{x}\)</span>，我们定义函数 <span
class="math inline">\(\chi(\boldsymbol{X},t): E^3\times\mathbb{R}
\mapsto E^3\)</span> 来描述连续体的运动: <span class="math display">\[
\boldsymbol{x} \triangleq \chi(\boldsymbol{X},t) =
\chi_{t}(\boldsymbol{X})
\]</span> 固定时刻 <span class="math inline">\(t\)</span>，对上式变量
<span class="math inline">\(\boldsymbol{X}\)</span> 微分，可得到微元
<span class="math inline">\(\mathrm{d}\boldsymbol{x}\)</span> 与 <span
class="math inline">\(\mathrm{d}\boldsymbol{X}\)</span> 之间的关系：
<span class="math display">\[
\mathrm{d} \boldsymbol{x} =
\frac{\partial{\chi}_t}{\partial{\boldsymbol{X}}} \cdot
\mathrm{d}\boldsymbol{X} =
\boldsymbol{F} \cdot \mathrm{d} \boldsymbol{X}
\]</span> 式中，变形梯度 <span
class="math inline">\(\boldsymbol{F}\)</span> 定义为 <span
class="math display">\[
\boldsymbol{F} \triangleq
\frac{\partial{\chi}_t}{\partial{\boldsymbol{X}}}
\]</span> <span id="more"></span>所以，变形梯度将参考构型点 <span
class="math inline">\(\boldsymbol{X}\)</span> 处的微元 <span
class="math inline">\(\mathrm{d} \boldsymbol{X}\)</span>
映射到当前构型点<span class="math inline">\(\boldsymbol{x}\)</span>
处的微元 <span class="math inline">\(\mathrm{d}
\boldsymbol{x}\)</span>。</p>
<p>为方便演算，我们希望将变形梯度 <span
class="math inline">\(\boldsymbol{F}\)</span>
写成分量形式。在将任意向量或张量写成分量形式之前，都必须要确定基底是什么。例如，对于一般的二阶张量
<span class="math inline">\(\boldsymbol{T}: E^3 \mapsto E^3\)</span>
，若使用张成 <span class="math inline">\(E^3\)</span> 的基底<span
class="math inline">\(\{ \boldsymbol{e}_i\}\)</span>，则张量 <span
class="math inline">\(\boldsymbol{T}\)</span> 的分量形式可以写成： <span
class="math display">\[
\boldsymbol{T} = T_{ij}~\boldsymbol{e}_i \otimes \boldsymbol{e}_j
\]</span> 对向量 <span class="math inline">\(\boldsymbol{v} = v_i
\boldsymbol{e}_i\)</span> 做点积运算得到 <span class="math display">\[
\boldsymbol{T} \cdot \boldsymbol{v} = T_{ij} \boldsymbol{e}_i \otimes
\boldsymbol{e}_j \cdot v_k \boldsymbol{e}_k
= T_{ij} v_j \boldsymbol{e}_i
\]</span> 变形梯度同样是二阶张量，但在点 <span
class="math inline">\(\boldsymbol{X}\)</span> 与点 <span
class="math inline">\(\boldsymbol{x}\)</span> 处，若使用不同的基底 <span
class="math inline">\(\{ \boldsymbol{E}_A\}\)</span>和 <span
class="math inline">\(\{ \boldsymbol{e}_i\}\)</span>
描述在该点处的微元： <span class="math display">\[
\mathrm{d}\boldsymbol{X} = \mathrm{d}X_A \boldsymbol{E}_A, \quad
\mathrm{d}\boldsymbol{x} = \mathrm{d}x_i
\boldsymbol{e}_i
\]</span> 那么 <span class="math inline">\(\boldsymbol{F}\)</span>
的分量形式为 <span class="math display">\[
\boldsymbol{F} = F_{iA} \boldsymbol{e}_i \otimes \boldsymbol{E}_A
\]</span> 与一般的二阶张量不同，变形梯度 <span
class="math inline">\(\boldsymbol{F}\)</span>
将两组<strong>不同原点</strong>的向量 <span
class="math inline">\(\mathrm{d} \boldsymbol{x}\)</span> 和 <span
class="math inline">\(\mathrm{d} \boldsymbol{X}\)</span>
联系起来，因此变形梯度又称为「两点张量」(two-point tensor)。</p>
<p>下面我们给出变形梯度的转置与逆。张量的转置 <span
class="math inline">\(\boldsymbol{F}^{\mathrm{T}}\)</span> 定义为 <span
class="math display">\[
(\boldsymbol{F} \cdot \boldsymbol{u}) \cdot \boldsymbol{v} =
\boldsymbol{u}\cdot (\boldsymbol{F}^{\mathrm{T}} \cdot
\boldsymbol{v})
\]</span> 写成分量形式可得 <span class="math display">\[
\begin{aligned}
(\boldsymbol{F} \cdot \boldsymbol{u}) \cdot \boldsymbol{v} = (F_{iA}
\boldsymbol{e}_i \otimes \boldsymbol{E}_A \cdot u_B
\boldsymbol{E}_B) \cdot v_j \boldsymbol{e}_j = F_{iA}u_Av_i\\
\boldsymbol{u}\cdot (\boldsymbol{F}^{\mathrm{T}} \cdot \boldsymbol{v})
=u_B
\boldsymbol{E}_B \cdot (F_{Ai}^{\mathrm{T}} \boldsymbol{E}_A \otimes
\boldsymbol{e}_i \cdot v_j \boldsymbol{e}_j) =
F_{Ai}^{\mathrm{T}} u_Av_i
\end{aligned}
\]</span> 若将分量记成矩阵形式，则有<span
class="math inline">\([F_{Ai}^{\mathrm{T}}] = [F_{Ai}]^T\)</span>.</p>
<p>接下来求解变形梯度的逆。根据反函数定理，若在点 <span
class="math inline">\(\boldsymbol{X}\)</span> 处的 Jacobian 行列式 <span
class="math inline">\(J = \det\boldsymbol{F} \neq
0\)</span>，则存在逆映射 <span
class="math inline">\(\chi_{t}^{-1}\)</span>，使得 <span
class="math inline">\(\boldsymbol{X} =
\chi_{t}^{-1}(\boldsymbol{x})\)</span>。对 <span
class="math inline">\(\chi_{t}^{-1}\)</span>​ 求微分可得： <span
class="math display">\[
\mathrm{d} \boldsymbol{X} =
\frac{\partial{\chi}_t^{-1}}{\partial{\boldsymbol{x}}} \cdot
\mathrm{d}\boldsymbol{x} =
\boldsymbol{F}^{-1} \cdot \mathrm{d} \boldsymbol{x}
\]</span> 由此可以得到变形梯度的逆。将 <span
class="math inline">\(\boldsymbol{F}^{-1}\)</span> 写成分量形式 <span
class="math display">\[
\boldsymbol{F}^{-1} = F_{Ai}^{-1} \boldsymbol{E}_A \otimes
\boldsymbol{e}_i
\]</span> 式中，<span class="math inline">\([F_{Ai}^{-1}] =
[F_{iA}]^{-1}\)</span>。根据变形梯度及其逆的分量形式，我们可以得到如下关系：
<span class="math display">\[
\boldsymbol{F}^{-1} \boldsymbol{F} = \boldsymbol{E}_A \otimes
\boldsymbol{E}_A = \boldsymbol{I}, \quad
\boldsymbol{F} \boldsymbol{F}^{-1} = \boldsymbol{e}_i \otimes
\boldsymbol{e}_i = \boldsymbol{i}
\]</span> 上式得到的单位张量 (identity tensor) 需要做出区分：前者 <span
class="math inline">\(\boldsymbol{I}\)</span>
是在参考构型下的单位张量，后者 <span
class="math inline">\(\boldsymbol{i}\)</span>
是在当前构型下的单位张量。</p>
]]></content>
      <categories>
        <category>连续介质力学</category>
      </categories>
  </entry>
  <entry>
    <title>从一般的应变张量到小变形和小转动</title>
    <url>/mech/continuum/%E4%BB%8E%E4%B8%80%E8%88%AC%E7%9A%84%E5%BA%94%E5%8F%98%E5%BC%A0%E9%87%8F%E5%88%B0%E5%B0%8F%E5%8F%98%E5%BD%A2%E5%92%8C%E5%B0%8F%E8%BD%AC%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="小变形问题">小变形问题</h2>
<p>在有限变形的框架下, 使用物质坐标系和空间坐标系描述应变的度量分别为
Lagrange 应变和 Euler 应变: <span class="math display">\[
E \triangleq \frac{1}{2}(F^{\top} F - I), \quad
e \triangleq \frac{1}{2}(I - F^{-\top} F^{-1})
\tag{1}
\]</span> 式中的 <span class="math inline">\(F\)</span> 和 <span
class="math inline">\(F^{-1}\)</span> 分别为 <span
class="math display">\[
F_{iI} = \frac{\partial x_i}{\partial X_I}, \quad
F_{Ii}^{-1} = \frac{\partial X_I}{\partial x_i}
\]</span> <span id="more"></span>如果引入位移梯度为 <span class="math display">\[
\nabla u \triangleq \frac{\partial u_i}{\partial X_I} = F - I, \quad
\nabla_x u \triangleq \frac{\partial u_I}{\partial x_i} = I - F^{-1}
\tag{2}
\]</span> 这样, 使用位移表示 Lagrange 和 Euler 应变分别为 <span
class="math display">\[
2E_{IJ} =
\left( \frac{\partial u_k}{\partial X_I} + \delta_{kI} \right)
\left( \frac{\partial u_k}{\partial X_J} + \delta_{kJ} \right)
- \delta_{IJ}
= \frac{\partial u_I}{\partial X_J} + \frac{\partial u_J}{\partial X_I}
+ \frac{\partial u_k}{\partial X_J} \frac{\partial u_k}{\partial X_I},
\\
2e_{ij} = \delta_{ij} -
\left( \delta_{iK} - \frac{\partial u_K}{\partial x_i} \right)
\left( \delta_{jK} - \frac{\partial u_K}{\partial x_j} \right)
= \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i}
- \frac{\partial u_K}{\partial x_j} \frac{\partial u_K}{\partial x_i}
\tag{3}
\]</span> 小位移的假设为: 位移梯度远小于 1, 或者写成数学的形式为 <span
class="math display">\[
\|\nabla u \| = \| F - I \| \ll 1, \quad \| \nabla_x u \| = \| I -
F^{-1} \| \ll 1
\tag{4}
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<p>位移梯度远小于1, 并不意味着位移远小于 1.
可以考虑在小变形的基础上附加一个大的刚体位移,
位移梯度可以通过一阶导数将常数项的刚体位移抹除掉.</p>
</blockquote>
<p>接下来将说明, 在小位移假设下,
可以不加区别地使用物质坐标或空间坐标描述位移梯度, 也即 <span
class="math display">\[
\boxed{
\nabla_x u \simeq \nabla u
}
\tag{5}
\]</span> 根据式 (2), 位移关于空间坐标的导数为 <span
class="math display">\[
\nabla_x u  = I - F^{-1}
\]</span> 对 <span class="math inline">\((I + \square)^{-1}\)</span>
型列式进行渐进展开, 得到 <span class="math display">\[
\nabla_x u  = I - (I + F -I)^{-1}
\sim (F-I) - (F-I)^2 + (F-I)^3 + \cdots
\]</span> 又因为 <span class="math inline">\(\nabla u = F -I\)</span>,
所以 <span class="math display">\[
\nabla_x u \sim \nabla u - (\nabla u)^2 + (\nabla u)^3 + \cdots
\]</span> 忽略高阶项, 就得到式 (5) 的结论.</p>
<p>因此, 式 (3) 得到的应变在不同坐标表示下的两种应变度量,
在小位移假设下, 忽略位移梯度的高阶项, coincide: <span
class="math display">\[
E_{ij} \simeq e_{ij}
\simeq \frac{1}{2} \left( \frac{\partial u_i}{\partial x_j} +
\frac{\partial u_j}{\partial x_i} \right)
\triangleq \varepsilon_{ij}
\]</span> 另一种思路是考虑 Lagrange 应变的定义: <span
class="math display">\[
E = \frac{1}{2}(F^{\top} F - I)
= \frac{1}{2} \left( (F-I)^{\top} (F-I) + (F + F^{\top}) - 2I \right)
\]</span> 忽略式中出现的 <span class="math inline">\((F-I)\)</span>
的二阶项, 就得到小应变的变形梯度表示: <span class="math display">\[
\boxed{
\varepsilon \triangleq \frac{1}{2}(F + F^{\top}) - I, \quad \text{or}
\quad
\varepsilon \triangleq \frac{1}{2}(\nabla u + \nabla u^{\top})
}
\tag{6}
\]</span> 变形的正确描述应能避开刚体位移, 然而式 (6)
提供的变形描述方式无法回避刚体转动. 例如, 考虑绕 <span
class="math inline">\(x_3\)</span> 逆时针的转动, 在给定的坐标系下
(这里考虑物质坐标系和参考坐标系使用同一套基底),
变形梯度可以写成矩阵的形式: <span class="math display">\[
{\rm F} = \begin{bmatrix}
\cos \theta &amp; -\sin \theta &amp; 0 \\
\sin \theta &amp; \cos \theta &amp; 0  \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span> 代入到式 (6) 中, 得到非零的小变形: <span
class="math display">\[
[\varepsilon] = \begin{bmatrix}
\cos \theta -1 &amp; 0 &amp; 0 \\
0 &amp; \cos \theta -1 &amp; 0  \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\]</span> 不过, 上式得到的应变是关于 <span
class="math inline">\(\theta\)</span> 的二阶小量.
在位移梯度和转角同阶的情况下,
由转动引起的应变相对于位移引起的应变是可以忽略的.</p>
<blockquote>
<p>[!NOTE]</p>
<p>如果定义应变为 <span class="math display">\[
\varepsilon \triangleq \nabla u
\]</span> 那么, 由刚体转动引入的应变分量是关于转角 <span
class="math inline">\(\theta\)</span> 的一阶小量: <span
class="math display">\[
[\varepsilon] = \begin{bmatrix}
\cos \theta -1 &amp; -\sin \theta &amp; 0 \\
\sin \theta &amp; \cos \theta -1 &amp; 0  \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\]</span></p>
</blockquote>
<h2 id="小转动问题">小转动问题</h2>
<p>一般的, 绕轴 <span class="math inline">\(n\)</span> 按照右手定则转动
<span class="math inline">\(\theta\)</span> 的变形公式为 <span
class="math display">\[
\boldsymbol{x} = (n \cdot X) \boldsymbol{n}
+ \cos \theta \left( X - (n\cdot X)\boldsymbol{n} \right)
+ \sin \theta ~\boldsymbol{n} \times \boldsymbol{X}
\]</span> 写成分量的形式为 <span class="math display">\[
x_i = ((1-\cos \theta)n_i n_k + \cos \theta \delta_{ik} + \sin \theta
e_{ijk} n_j) X_k
\]</span> 记旋转矩阵 <span class="math inline">\(R(\theta)\)</span> 为
<span class="math display">\[
R_{ik}(\theta) \triangleq (1-\cos \theta)n_i n_k + \cos \theta
\delta_{ik} + \sin \theta e_{ijk} n_j
\]</span> 如果 <span class="math inline">\(\theta \ll 1\)</span>, 那么
<span class="math inline">\(1-\cos \theta \sim \theta^2/2\)</span>,
<span class="math inline">\(\cos \theta \sim 1\)</span>, <span
class="math inline">\(\sin \theta \sim \theta\)</span>. 忽略关于 <span
class="math inline">\(\theta\)</span> 的高阶小量, 就得到 <span
class="math display">\[
x_i = ( \delta_{ik} + \theta e_{ijk} n_j) X_k, \quad
u_i = \theta e_{ijk} n_j X_k,\quad \boldsymbol{u} = \theta
\boldsymbol{n} \times \boldsymbol{X}
\]</span> 因此, 小转动引起的位移梯度为 <span class="math display">\[
u_{i,I} = \theta e_{ijI} n_j, \quad
[\nabla u] = \theta \begin{bmatrix}
0 &amp; -n_3 &amp; n_2 \\
n_3 &amp; 0 &amp; -n_1  \\
-n_2 &amp; n_1 &amp; 0
\end{bmatrix}
\]</span> 对于一般的小位移, 定义小转动二阶张量 <span
class="math inline">\(\Omega\)</span> 为 <span class="math display">\[
\boxed{
\Omega \triangleq \frac{1}{2} (F - F^{\top}), \quad \text{or} \quad
\Omega \triangleq \frac{1}{2} (\nabla u - \nabla u^{\top})
}
\tag{7}
\]</span> 根据定义, 张量 <span class="math inline">\(\Omega\)</span>
是反对称张量, 这也意味着该张量可以表示为一个向量与置换张量的线性组合,
定义旋转向量 <span class="math inline">\(\omega\)</span> 为 <span
class="math display">\[
\Omega_{ij} \triangleq - e_{ijk} \omega_k, \quad \text{or} \quad
\omega_{i} \triangleq-\frac{1}{2} e_{ijk} \Omega_{jk}
\]</span> 在上述定义下, 有 <span class="math display">\[
\Omega a = \omega \times a, \quad \forall a \in \mathbb{R}^3
\tag{8}
\]</span> 如果我们定义旋度 <span class="math inline">\(\rm curl\)</span>
运算为 <span class="math display">\[
\mathrm{curl}~ \boldsymbol{v} \triangleq \nabla \times \boldsymbol{v}
= e_{ijk} ~\boldsymbol{e}_i\frac{\partial ~}{\partial x_j} v_k
= e_{ijk} \frac{\partial v_j}{\partial x_i} ~\boldsymbol{e}_k
\]</span> 另一种与上式等价的旋度定义为 <span class="math display">\[
( \nabla v - \nabla v^{\top}) a \equiv (\mathrm{curl}~ v) \times a,
\quad
\forall a \in \mathbb{R}^3
\]</span> 对比上式式 (7) , 再根据式 (8), 就得到 <span
class="math display">\[
\omega = \frac{1}{2} \mathrm{curl}~ u
\]</span> 综合应变与旋转张量的定义 (7) 和 (8), 可以看到,
小变形的应变是位移梯度的对称部分, 旋转是位移梯度的反对称部分.</p>
]]></content>
      <categories>
        <category>连续介质力学</category>
      </categories>
      <tags>
        <tag>应变张量</tag>
      </tags>
  </entry>
  <entry>
    <title>应力度量</title>
    <url>/mech/continuum/%E5%BA%94%E5%8A%9B%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="pull-back-和-push-forword-操作">Pull-back 和 push-forword
操作</h2>
<p>变形梯度不仅将参考构型中的微元 <span
class="math inline">\(\mathrm{d}X\)</span> 映射为当前构型中的微元 <span
class="math inline">\(\mathrm{d}x\)</span>, 同时作为两点张量,
还将物质形式的物理量映射到空间形式的物理量. 因此, 对于空间向量 <span
class="math inline">\(v_{i}(x,t)\)</span>, 我们可以从数学的意义上,
将该变量 pull back 到物质坐标表示的物质形式的向量 <span
class="math inline">\(V_I(X,t)\)</span>: <span class="math display">\[
V_I(X,t) \triangleq F_{Ii}^{-1} v_{i}(\varphi(X,t), t)
\]</span> 类似的, 也可以将用物质形式的向量 <span
class="math inline">\(G_{I}\)</span>, push forward 到空间形式的向量
<span class="math inline">\(g_i\)</span>: <span class="math display">\[
g_i(x,t) \triangleq F_{iI} G_{I}(\varphi^{-1}(x,t), t)
\]</span> 如果使用变形梯度作为对向量前推后拉的操作运算, 那么除了使用
<span class="math inline">\(F_{iI}\)</span>, <span
class="math inline">\(F_{Ii}^{-1}\)</span> 之外,
还可以使用变形梯度的转置 <span
class="math inline">\(F_{iI}^{-\top}\)</span>, <span
class="math inline">\(F_{Ii}^{\top}\)</span>. 对每一个指标, 有两种前推
<span class="math inline">\(\{ F_{iI}, F_{iI}^{-\top} \}\)</span> 后拉
<span class="math inline">\(\{ F_{Ii}^{-1}, F_{Ii}^{T} \}\)</span>
的方式. 因此, 如果推广到对二阶张量的前推后拉操作,
每种运算有四种方式.</p>
<h2 id="cauchy-应力的定义">Cauchy 应力的定义</h2>
<p>在 Spencer 的连续介质力学书中, Cauchy 应力定义为 <span
class="math display">\[
t^{(i)} = \sigma_{ij} e_{j}, \quad \mathrm{or} \quad \sigma_{ij}
\triangleq t^{(i)} \cdot e_{j}
\]</span> 这样得到的平衡方程为 <span class="math display">\[
\nabla \cdot \sigma + \rho b = 0, \quad \mathrm{or} \quad
\sigma_{ji,j} + \rho b_{i} = 0
\tag{1}
\]</span> 而我熟悉的平衡方程为 <span class="math display">\[
\sigma_{ij,j} + \rho b_i = 0
\]</span> <span id="more"></span>这是因为定义应力分量的方式不同.
如果将应力张量看作是一个矩阵, 那么使用 Spencer 的定义方式,
矩阵的每一行代表着在坐标系基矢量法面的作用力 <span
class="math inline">\(t^{(i)}\)</span>, 因此, 对于任意方向向量 <span
class="math inline">\(n\)</span> 作用在法向为 <span
class="math inline">\(n\)</span> 的法面上的力为法向分量 <span
class="math inline">\(n_i\)</span> 和 <span
class="math inline">\(t^{(i)}\)</span> 的线性组合: <span
class="math display">\[
t^{(n)} = n_1 t^{(1)} + n_2 t^{(2)} + n_3 t^{(3)}
\]</span> 也即 <span class="math display">\[
t^{(n)} = n_i \sigma_{ij} e_{j} = n \cdot \sigma
\]</span> 在一些其它的教材上 (Tadmor, 黄筑平), 应力分量定义为 <span
class="math display">\[
\sigma_{ij} \triangleq e_{i} \cdot t^{(j)}
\tag{2}
\]</span> 由此得到的平衡方程为 <span class="math display">\[
\sigma \cdot \nabla + \rho b = 0, \quad \mathrm{or} \quad
\sigma_{ij,j} + \rho b_{i} = 0
\tag{3}
\]</span> 由于 <span class="math inline">\(\sigma\)</span> 是对称张量,
所以式 (1) 等价于式 (3), 但是在定义 P-K 应力时,
就会体现出这两类定义应力方式的区别. 以下均使用式 (2) 的定义方式.</p>
<h2 id="第一类-piola-kirchhoff-应力">第一类 Piola-Kirchhoff 应力</h2>
<p>在推导物质坐标下的动量守恒公式时, 我们通过积分的参量变换, 得到第一类
Piola-Kirchhoff (以下简称为 PK1) 应力 <span
class="math inline">\(P\)</span> 的定义 <span class="math display">\[
\boxed{
P \triangleq J \sigma \cdot F^{-\top}
}
\tag{4}
\]</span> 应力 <span class="math inline">\(P\)</span>
对应为变形后的平面所受的力在参考构型下的度量. 对于变形前后的面微元 <span
class="math inline">\(\mathrm{d}A\)</span> 和 <span
class="math inline">\(\mathrm{d}a\)</span>, 在当前构型下的作用力为 <span
class="math inline">\(f^{(n)}\)</span>, 那么 <span
class="math display">\[
f^{(n)} = \sigma \cdot \mathrm{d}a = P \cdot \mathrm{d}A
\tag{5}
\]</span> 由上式可知 <span class="math inline">\(P\)</span> 是两点张量,
与变形梯度 <span class="math inline">\(F\)</span> 相类似.</p>
<blockquote>
<p>[!NOTE]</p>
<p>按照 Spencer 教材的定义, PK1 应力定义为 <span class="math display">\[
P \triangleq J F^{-1} \cdot \sigma
\]</span> 对应式 (5) 的关系为<strong>左乘</strong>面微元向量: <span
class="math display">\[
f^{(n)} = \mathrm{d}a \cdot \sigma = \mathrm{d}A \cdot P
\]</span> 因为 PK1 应力不是对称张量, 所以 PK1 与向量缩并时,
左右得到的结果不同.</p>
</blockquote>
<h2 id="kirchhoff-应力">Kirchhoff 应力</h2>
<p>Kirchhoff 应力定义为 <span class="math display">\[
\boxed{
\tau \triangleq J \sigma
}
\tag{6}
\]</span> 根据式 (4), 可以得到 PK1 应力与 Kirchhoff 应力之间的关系 <span
class="math display">\[
P = \tau \cdot F^{-\top}
\]</span> 因此, PK1 应力是 Kirchhoff 应力的一个 pull-back</p>
<h2 id="第二类-piola-kirchhoff-应力">第二类 Piola-Kirchhoff 应力</h2>
<p>我们继续考察式 (5), 式中 <span class="math inline">\(f^{(n)}\)</span>
是在当前构型下的作用力. 按照之前定义的 pull-back 操作,
将作用力后拉到物质形式: <span class="math display">\[
f_0^{(n)} \triangleq F^{-1} \cdot f^{(n)}
\]</span> 同样使用参考构型的面微元作为应力的度量, 就得到第二类
Piola-Kirchhoff 应力的定义: <span class="math display">\[
S \triangleq F^{-1} P, \quad \mathrm{or} \quad
S \triangleq J F^{-1} \cdot \sigma \cdot F^{-\top}
\]</span></p>
<blockquote>
<p>[!TIP]</p>
<h5 id="例-不可压缩杆的单轴拉伸">例: 不可压缩杆的单轴拉伸</h5>
<p>对一根沿 <span class="math inline">\(E^1\)</span>
方向摆放的杆施加轴向力 <span class="math inline">\(f\)</span>, 杆长度从
<span class="math inline">\(L\)</span> 拉伸至 <span
class="math inline">\(l\)</span>, 假设杆变形均匀, 对应的变形梯度为 <span
class="math display">\[
F = \begin{bmatrix}
\alpha &amp; &amp; \\
&amp; \frac{1}{\sqrt{\alpha}} &amp; \\
&amp; &amp; \frac{1}{\sqrt{\alpha}}
\end{bmatrix}
\]</span> 式中, <span class="math inline">\(\alpha \triangleq
l/L\)</span>设杆的初始横截面积为 <span class="math inline">\(A\)</span>,
拉伸后变为 <span class="math inline">\(a\)</span>, 其关系为 <span
class="math inline">\(a = A/\alpha\)</span>. 杆内的 Cauchy 应力只有
<span class="math inline">\(\sigma_{11}\)</span> 非零: <span
class="math display">\[
\sigma_{11} = \frac{f}{a} = \alpha \frac{f}{A}
\]</span> 对应 PK1 应力为 <span class="math display">\[
P_{iI} = J \sigma_{ij} F_{Ij}^{-1} \Rightarrow P_{11} = \frac{f}{A},
\quad P_{iI} = 0 ~(iI \neq 11)
\]</span> 以及 PK2 应力为 <span class="math display">\[
S_{IJ} = F_{Ii}^{-1} P_{iJ} \Rightarrow S_{11} = \frac{f}{\alpha A},
\quad
S_{IJ} = 0 ~(IJ \neq 11)
\]</span></p>
</blockquote>
<h2 id="corotational-应力">Corotational 应力</h2>
<p>对于高维空间中的低维单元 (例如三维空间中的杆端元, 膜单元等),
应用坐标变换, 将张量的分量转化为随体坐标系下可以简化问题的计算.
设在宏观坐标系下的单元坐标为 <span
class="math inline">\(x_{\alpha}\)</span>, 随体坐标系下单元坐标为 <span
class="math inline">\(x&#39;_i\)</span> 由此得到坐标变换关系为 <span
class="math display">\[
x&#39;_i = Q_{\alpha i} x_{\alpha}
\]</span> 式中, <span class="math inline">\(Q_{\alpha i} \triangleq
e_{\alpha} \cdot e&#39;_{i}\)</span>. 对应应力分量的变换关系为 <span
class="math display">\[
\sigma&#39;_{ij} = Q_{\alpha i} Q_{\beta j} \sigma_{\alpha \beta}
\]</span> 记成张量的形式为 <span class="math display">\[
\sigma&#39; = Q^{\top}\cdot \sigma\cdot ~Q
\]</span></p>
<blockquote>
<p>[!TIP]</p>
<h5 id="例-应力旋转">例: 应力旋转</h5>
<p>设在初始状态下, 材料在某一点处的应力状态为 <span
class="math display">\[
\sigma_0 = \begin{bmatrix}
\sigma_x^0 &amp; \\
&amp; \sigma_y^0
\end{bmatrix}
\]</span> 材料经 <span class="math inline">\(90\)</span>
度逆时针旋转到当前构型, 对应的变形梯度为 <span class="math display">\[
F = \begin{bmatrix}
0 &amp; -1\\
1 &amp; 0
\end{bmatrix}, \quad J = 1
\]</span> 以及相应的坐标变换张量为 <span class="math display">\[
Q = \begin{bmatrix}
0 &amp; -1\\
1 &amp; 0
\end{bmatrix} = F
\]</span> 假想应力 <em>固定</em> 在材料中, 因此旋转后, 材料的应力状态为
<span class="math display">\[
\sigma = \begin{bmatrix}
\sigma_y^0 &amp; \\
&amp; \sigma_x^0
\end{bmatrix}
\]</span> 对应的 PK1 应力为 <span class="math display">\[
P = J \sigma \cdot F^{-\top} = \begin{bmatrix}
&amp; -\sigma_y^0\\
\sigma_x^0 &amp;
\end{bmatrix}
\]</span> 以及 PK2 应力为 <span class="math display">\[
S = F^{-1} \cdot P = \begin{bmatrix}
\sigma_x^0 &amp; \\
&amp; \sigma_y^0
\end{bmatrix}
= \sigma_0
\]</span> corotational 应力为 <span class="math display">\[
\sigma&#39; = Q^{\top}\cdot \sigma\cdot ~Q = \begin{bmatrix}
\sigma_x^0 &amp; \\
&amp; \sigma_y^0
\end{bmatrix}
= \sigma_0
\]</span></p>
</blockquote>
<h2 id="功共轭意义下的应力张量">功共轭意义下的应力张量</h2>
<p>在能量守恒公式中, 材料边界处外力做功,
通过散度定理转化为体积分之后得到 <span class="math display">\[
I = \int_{B} \sigma : D ~\mathrm{d}x
\]</span> 如果将上述积分转化到参考构型下, 就得到 <span
class="math display">\[
I = \int_{B_0} J \sigma : D ~\mathrm{d}X
\]</span> 这一项在能量方程中出现, 因此与应变的度量无关, 因此积分项 <span
class="math inline">\(J \sigma : D\)</span> 也与应变的度量无关.
如果定义应力应变 (Langrange 意义下) 分别为 <span
class="math inline">\(T\)</span> 和 <span
class="math inline">\(E\)</span>, 并且满足 <span class="math display">\[
\boxed{
T:\dot{E} = J \sigma : D
}
\tag{7}
\]</span> 就称应力 <span class="math inline">\(T\)</span> 和 应变 <span
class="math inline">\(E\)</span> 是<strong>功共轭</strong>的. 例如对于
Green 应变 <span class="math display">\[
\dot{E} = F^{\top} \cdot D \cdot F \Rightarrow
T : \dot{E} = (F \cdot T \cdot F^{\top}) : D
\]</span> 对比式 (7) 得到 <span class="math display">\[
F \cdot T \cdot F^{\top} = J \sigma \quad
\]</span> 所以与 Green 应变功共轭的应力为 PK2 应力.</p>
]]></content>
      <categories>
        <category>连续介质力学</category>
      </categories>
  </entry>
  <entry>
    <title>张量场的积分定理</title>
    <url>/mech/continuum/%E5%BC%A0%E9%87%8F%E5%9C%BA%E7%9A%84%E7%A7%AF%E5%88%86%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>首先, 我们先定义梯度, 散度和旋度的概念, 并特别强调对于高阶张量的定义,
这将规范我们使用的 notation. 然后, 我们以二维空间为例, 引出散度定理,
Stokes 公式和 Gauss 公式. 最后,
我们再给出一般的张量场中这三种公式的形式.</p>
<h2 id="梯度-散度和旋度">梯度, 散度和旋度</h2>
<p>我们引入记号 <span class="math inline">\(\nabla\)</span>, <span
class="math inline">\(\nabla \cdot\)</span>, <span
class="math inline">\(\nabla \times\)</span>, 分别表示梯度, 散度和旋度.
我们首先介绍这三种运算最简单的情况, 然后再推广到一般的张量空间当中.</p>
<p>对标量场的梯度运算, 得到的是一个向量场: <span class="math display">\[
\nabla \phi = \frac{\partial \phi\ }{\partial x_i} e_i
\]</span> 对向量场的散度运算, 得到的是一个标量场: <span
class="math display">\[
\nabla \cdot v = \frac{\partial v_i}{\partial x_i}
\]</span> 对向量场的旋度运算, 得到的仍是一个向量场: <span
class="math display">\[
\nabla \times v = \begin{vmatrix}
i &amp; j &amp; k \\
\dfrac{\partial \ }{\partial x_1} &amp; \dfrac{\partial \ }{\partial
x_1} &amp; \dfrac{\partial \ }{\partial x_1} \\
v_1 &amp; v_2 &amp; v_3
\end{vmatrix}
\]</span> <span id="more"></span>可以看到,
上述运算分别将原本张量的阶数提升(梯度)或下降(散度)一阶,
或者保持不变(旋度). 推广到高阶之后情况也是相同, 但需要特别强调的是,
因为高阶张量 (二阶及以上) 引入了指标的排序,
所以即使所有分量所构成的集合相同, 排列不同, 也是不同的张量.</p>
<p>我们定义高阶张量的梯度运算为 <span class="math display">\[
\boxed{
\nabla B \triangleq e_k \otimes \frac{\partial B}{\partial x_k}, \quad
B \nabla \triangleq \frac{\partial B}{\partial x_k} \otimes e_k
}
\tag{1}
\]</span> 例如, 向量场 <span class="math inline">\(v\)</span>
的梯度为二阶张量 <span class="math display">\[
\nabla v = v_{j,i} e_{i} \otimes e_{j}, \quad
v \nabla = v_{i,j} e_{i} \otimes e_{j}
\]</span> 所以 <span class="math display">\[
\nabla v = (v \nabla)^{\top}
\]</span> 定义张量的散度运算为 <span class="math display">\[
\boxed{
\nabla \cdot B \triangleq e_k \cdot \frac{\partial B}{\partial x_k},
\quad
B \cdot \nabla \triangleq \frac{\partial B}{\partial x_k} \cdot e_k
}
\tag{2}
\]</span> 例如, 二阶张量场 <span class="math inline">\(\sigma\)</span>
的散度为向量场 <span class="math display">\[
\nabla \cdot \sigma = \sigma_{ij,i} e_j , \quad
\sigma \cdot \nabla = \sigma_{ij,j} e_i
\]</span> 定义张量的旋度运算为 <span class="math display">\[
\boxed{
\nabla \times B \triangleq e_k \times \frac{\partial B}{\partial x_k},
\quad
B \times \nabla \triangleq \frac{\partial B}{\partial x_k} \times e_k
}
\tag{3}
\]</span></p>
<h2 id="二维空间中向量场的积分定理">二维空间中向量场的积分定理</h2>
<h3 id="stokes-定理">Stokes 定理</h3>
<p>对于区域 <span class="math inline">\(S\)</span> 的无旋流动,
以下三个条件是<strong>等价</strong>的:</p>
<ol type="1">
<li><p>速度场环绕任意闭合路径 <span class="math inline">\(C\)</span>
的积分等于 0: <span class="math display">\[
\oint_{C} v \cdot \mathrm{d} r = 0
\]</span></p></li>
<li><p>速度场是某一势函数 <span class="math inline">\(u\)</span> 的梯度:
<span class="math display">\[
v = \nabla u
\]</span></p></li>
<li><p>速度场的旋度 (vorticity) 等于 0: <span class="math display">\[
\mathrm{curl}\  v \triangleq \frac{\partial v_y}{\partial x} -
\frac{\partial v_x}{\partial y} \equiv 0
\]</span></p></li>
</ol>
<p>条件 1 和 3 的等价性可以通过 <strong>Stokes 定理</strong> 证明.
在二维情景下, 区域 <span class="math inline">\(S\)</span>
内对旋度的积分等于在边界 <span class="math inline">\(C\)</span>
上的第二类曲线积分: <span class="math display">\[
\boxed{
\int_{S} \mathrm{curl}\  v \ \mathrm{d}S =  \oint_{C} v \cdot \mathrm{d}
r
}
\]</span> 条件 2 和 3 的等价性更加直接. 如果速度场满足条件 2,
同时假设势函数 <span class="math inline">\(u\)</span> 二阶导数连续, 那么
<span class="math display">\[
\mathrm{curl}\  v
= \frac{\partial^2 u}{\partial x \partial y} - \frac{\partial^2
u}{\partial y \partial x}
\equiv 0
\]</span> 因此, <span class="math inline">\(\nabla u\)</span>
表征的是空间中的无旋流动. 条件 1 和 3 提供了检验流场有旋无旋的方式, 条件
1 是全局的, 条件 3 是点态的.</p>
<blockquote>
<p>[!NOTE]</p>
<p>旋度 <span class="math inline">\(\mathrm{curl}\)</span> 作用在向量上,
得到的是一个向量场. 在二维情景下, 旋度只在垂直于平面方向的分量不等于 0,
因此这里使用的旋度是标量.</p>
</blockquote>
<h3 id="散度定理">散度定理</h3>
<p>以上我们通过势函数的梯度刻画了无旋流动速度场,
接下来将通过数学公式描述物理场的另一种重要的性质:
<strong>守恒性质</strong>. 类似于上文中的条件 1 和 条件 3,
守恒性质同样也可以通过全局和点态两种方式进行描述:</p>
<ol type="1">
<li><p>对任意闭合曲线, 通量等于 0: <span class="math display">\[
\oint_{C} n \cdot v \ \mathrm{d}s = 0
\]</span></p></li>
<li><p>速度场的散度恒等于 0: <span class="math display">\[
\nabla \cdot v \equiv 0
\]</span></p></li>
</ol>
<p>这里的条件 1 和 2 的等价性可以通过<strong>散度定理</strong>证明:
在区域 <span class="math inline">\(S\)</span> 中对散度的积分,
等于在边界处 <span class="math inline">\(C\)</span> 的通量: <span
class="math display">\[
\boxed{
\int_{S} \nabla \cdot v \ \mathrm{d}S = \oint_{C} n \cdot v \
\mathrm{d}s
}
\]</span></p>
<h3 id="gauss-公式">Gauss 公式</h3>
<p>Gauss 公式是分部积分公式在高维情景下的推广: <span
class="math display">\[
\int \boldsymbol{w} \cdot \nabla u \ \mathrm{d}S
= \int u (-\nabla \cdot \boldsymbol{w}) \ \mathrm{d}S
+ \int \nabla \cdot (u \boldsymbol{w}) \ \mathrm{d}S
\]</span> 上式最后一项可以通过散度定理化简为 <span
class="math display">\[
\boxed{
\int \boldsymbol{w} \cdot \nabla u \ \mathrm{d}S
= \int u (-\nabla \cdot \boldsymbol{w}) \ \mathrm{d}S
+ \underbrace{\oint u\  \boldsymbol{w} \cdot \boldsymbol{n} \
\mathrm{d}s}_{\bigstar}
}
\]</span> 这就得到了 Gauss 公式.</p>
<h2 id="一般形式的散度定理">一般形式的散度定理</h2>
<p>对于区域 <span class="math inline">\(V\)</span> 上的光滑标量场 <span
class="math inline">\(\varphi\)</span>, 并假设边界 <span
class="math inline">\(\partial V\)</span> 分片光滑, 那么以下等式成立:
<span class="math display">\[
\int_{V} \varphi_{,i} \ \mathrm{d}x = \int_{\partial V} \varphi n_i \
\mathrm{d}\sigma(x), \quad i=1,2,3
\]</span> 首先考虑梯度运算, 写成分量形式为 <span class="math display">\[
\int_V \nabla B \ \mathrm{d}x = \int_{V} B_{\cdot,i} e_i \otimes
e_{\cdot} \ \mathrm{d}x
= \int_{\partial V} B_{\cdot} n_i \ e_i \otimes e_{\cdot} \
\mathrm{d}\sigma(x)
= \int_{\partial V} n \otimes B  \ \mathrm{d}\sigma(x)
\]</span> 再考虑散度运算, <span class="math display">\[
\int_{V} \nabla \cdot B \ \mathrm{d}x = \int_{V} B_{i\cdot,i} \
e_{\cdot} \ \mathrm{d}x
= \int_{\partial V} B_{i\cdot} n_i \ e_{\cdot} \ \mathrm{d}\sigma(x)
= \int_{\partial V} n \cdot B \ \mathrm{d}\sigma(x)
\]</span> 最后考虑旋度运算 <span class="math display">\[
\int_{V} \nabla \times B \ \mathrm{d}x = \int_{V} B_{\cdot,i} \  e_{i}
\times e_{\cdot} \ \mathrm{d}x
= \int_{\partial V} B_{\cdot} n_i \  e_{i} \times e_{\cdot} \
\mathrm{d}\sigma(x)
= \int_{\partial V} n \times B \ \mathrm{d}\sigma(x)
\]</span> 对于右侧的运算也是类似的, 因此, 如果我们定义一般的运算符 <span
class="math inline">\(\divideontimes\)</span>, 代表梯度,
散度或旋度的其中一种, 那么 <span class="math display">\[
\int_V \nabla \divideontimes B \ \mathrm{d}x = \int_{\partial V} n
\divideontimes B \ \mathrm{d}\sigma(x), \quad
\int_V B \divideontimes \nabla \ \mathrm{d}x = \int_{\partial V} B
\divideontimes n \ \mathrm{d}\sigma(x)
\]</span></p>
]]></content>
      <categories>
        <category>连续介质力学</category>
      </categories>
      <tags>
        <tag>散度定理</tag>
        <tag>Stokes 公式</tag>
        <tag>Gauss 公式</tag>
      </tags>
  </entry>
  <entry>
    <title>物质坐标下的守恒方程</title>
    <url>/mech/continuum/%E7%89%A9%E8%B4%A8%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E5%AE%88%E6%81%92%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<p>空间坐标下的守恒方程可通过输运定理获得, 而对于物质坐标下的守恒方程,
我们通过积分参数变换的方式获得. 因此在本文中,
我们首先陈述微元在不同参数表示下的变换关系,
然后再根据空间坐标下的守恒方程, 通过参数变换,
得到物质坐标下的守恒方程.<span id="more"></span></p>
<h2 id="微元的参数变换关系">微元的参数变换关系</h2>
<h3 id="线微元">线微元</h3>
<p>可通过变形梯度得到 <span class="math display">\[
\boxed{
\mathrm{d} x = F \cdot \mathrm{d} X, \quad \mathrm{or} \quad
\mathrm{d} X = F^{-1} \cdot ~\mathrm{d}X
}
\tag{1}
\]</span></p>
<h3 id="体微元">体微元</h3>
<p>线微元建立起参数 <span class="math inline">\(X \leftrightarrow
x\)</span> 邻域的仿射变换关系 <span class="math inline">\(F\)</span>.
对于仿射变换, 体积微元通过 <span class="math inline">\(F\)</span>
的行列式相关联, 定义 <span class="math inline">\(J \triangleq \det
F\)</span>, 那么 <span class="math display">\[
\boxed{
\mathrm{d} v = J \mathrm{d} V, \quad \mathrm{or} \quad
\mathrm{d} V = \frac{1}{J} ~\mathrm{d} v
}
\tag{2}
\]</span></p>
<h3 id="面微元">面微元</h3>
<p>参考构型和当前构型中的面微元分别定义为 <span class="math display">\[
\mathrm{d} A \triangleq N ~\mathrm{d} \Sigma, \quad
\mathrm{d} a \triangleq n ~\mathrm{d} \sigma
\]</span> 式中, <span class="math inline">\(N\)</span> 和 <span
class="math inline">\(n\)</span> 表示面微元的法向方向, <span
class="math inline">\(\mathrm{d} \Sigma\)</span> 和 <span
class="math inline">\(\mathrm{d} \sigma\)</span> 表示面微元面积大小.
考虑参考构型中的两段线微元<span class="math inline">\(~\mathrm{d}
X^1\)</span> 和<span class="math inline">\(~\mathrm{d}X^2\)</span>,
作为面微元的两条边, 因此, 参考构型中的面微元可以表示为 <span
class="math display">\[
\mathrm{d} A = \mathrm{d} X^1 \times ~\mathrm{d} X^2
\]</span> 变形后, 面微元 <span class="math inline">\(\mathrm{d}
A\)</span> 变形为 <span class="math inline">\(\mathrm{d} a\)</span>,
组成 <span class="math inline">\(\mathrm{d} a\)</span> 的两边分别为
<span class="math inline">\(\mathrm{d} x^1\)</span> 和 <span
class="math inline">\(\mathrm{d} x^2\)</span>: <span
class="math display">\[
\mathrm{d} a = \mathrm{d}x^1 \times \mathrm{d}x^2 = (F ~\mathrm{d}X^1)
\times (F ~\mathrm{d}X^2)
\]</span></p>
<p>写成分量形式, 就得到 <span class="math display">\[
n_i \mathrm{d} \sigma = e_{ijk} F_{jJ} \mathrm{d}X_{J}^1 F_{kK}
\mathrm{d}X_{K}^2
\]</span> 上式两端同乘 <span class="math inline">\(F_{iI}\)</span>,
同时应用 <span class="math inline">\(e_{ijk}F_{iI}F_{jJ}F_{kK} = e_{IJK}
\det F\)</span>, 得到 <span class="math display">\[
n_i F_{iI} \mathrm{d} \sigma = \det F ~e_{IJK} \mathrm{d}X_{J}^1
\mathrm{d}X_{K}^2
\]</span> 因此 <span class="math display">\[
\boxed{
\mathrm{d}A = \frac{1}{J} F^{\top} \cdot \mathrm{d}a, \quad \mathrm{or}
\quad
\mathrm{d}a = J F^{-\top} \cdot \mathrm{d}A
}
\tag{3}
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<p>需要指出, 平面的法向 <span class="math inline">\(N\)</span>
在变形后为 <span class="math display">\[
\tilde{n} = F \cdot N
\]</span> 一般不等于, 也不平行于 <span class="math inline">\(n\)</span>.
若 <span class="math inline">\(\tilde{n} \parallel n\)</span>, 那么
<span class="math display">\[
F \cdot N = \mu F^{-\top} \cdot N \Rightarrow F^{\top} \cdot F \cdot N =
\mu N
\]</span> 也即 <span class="math inline">\(N\)</span> 是右 Cauchy-Green
张量的特征向量.</p>
</blockquote>
<h2 id="函数记号说明">函数记号说明</h2>
<p>函数 <span class="math inline">\(f\)</span> 定义在 <span
class="math inline">\(E_3 \times (0,T)\)</span> 上, 其中 <span
class="math inline">\(E_3\)</span> 为 Euclidean 点空间. 函数 <span
class="math inline">\(f\)</span> 可以表示为空间坐标形式和物质坐标形式:
<span class="math display">\[
f = \hat{f}(X,t), \quad \mathrm{or} \quad
f = \breve{f}(x,t)
\tag{4}
\]</span> 空间坐标 <span class="math inline">\(x\)</span> 和物质坐标
<span class="math inline">\(X\)</span> 之间通过一一映射 <span
class="math inline">\(\varphi\)</span> 关联 <span
class="math display">\[
x = \varphi(X,t), \quad
X = \varphi^{-1}(x,t)
\]</span> 因此式 (4) 中不同坐标形式的函数可以互相表示, <span
class="math display">\[
\hat{f} = \breve{f}(\varphi(X,t), t), \quad
\breve{f} = \hat{f}(\varphi^{-1}(x,t), t)
\]</span> 函数 <span class="math inline">\(f\)</span>
的空间变量类型一般可以通过积分微元等语境中推断得到, 为了记号的清晰,
我们使用 <span class="math inline">\(f\)</span> 指代 <span
class="math inline">\(\hat{f}\)</span> 或 <span
class="math inline">\(\breve{f}\)</span> 中的一种. 我们用下标 <span
class="math inline">\(\square_{\tau}\)</span> 表示在时刻 <span
class="math inline">\(\tau\)</span> 构型的变量. 当 <span
class="math inline">\(\tau=0\)</span> 时, 对应构型为参考构型,
此时的变量默认用物质坐标描述. 例如, <span
class="math inline">\(B_0\)</span> 表示材料在参考构型下占据的空间区域,
<span class="math inline">\(\rho_0\)</span> 表示 <span
class="math inline">\(t=0\)</span> 时刻材料的密度, <span
class="math inline">\(\rho_0(X) = \hat{\rho}(X,0)\)</span>.
如果省略下标, 那么默认为时刻 <span class="math inline">\(t\)</span>
当前构型下的变量.</p>
<h2 id="质量守恒定律">质量守恒定律</h2>
<p>考虑参考构型中的区域 <span class="math inline">\(B_0\)</span>,
该区域的质量为 <span class="math display">\[
M = \int_{B_0} \rho_0 ~\mathrm{d} X
\]</span> 经变形后, 区域为 <span class="math inline">\(B\)</span>,
其中的质量为 <span class="math display">\[
m = \int_{B} \rho ~\mathrm{d}x
\]</span> 作积分变换, 得到 <span class="math display">\[
m = \int_{B_0} \rho J~\mathrm{d}X
\]</span> 根据质量守恒有 <span class="math display">\[
M \equiv m \Rightarrow \int_{B_0} \rho_0 - J\rho ~\mathrm{d} X \equiv 0
\]</span> 上式对任何区域 <span class="math inline">\(B_0\)</span> 成立,
所以 <span class="math display">\[
\boxed{
\rho_0 - J \rho = 0
}
\tag{4}
\]</span></p>
<h2 id="动量守恒定律">动量守恒定律</h2>
<p>空间坐标下的动量守恒定律为 <span class="math display">\[
\sigma \cdot \nabla + \rho b = \rho a
\]</span> 为了表示成物质坐标的形式, 我们首先将上式还原为积分形式 <span
class="math display">\[
\int_{B} \sigma \cdot \nabla + \rho b - \rho a ~\mathrm{d}x = 0
\tag{5}
\]</span> 作变量替换, 上式中第二项和第三项为 <span
class="math display">\[
\int_{B} \rho b - \rho a ~\mathrm{d}x
= \int_{B_0} (\rho b - \rho a)J\mathrm{d}X
\]</span> 应力散度项先通过散度定理转化到边界 <span
class="math inline">\(\partial B\)</span> 上的积分 <span
class="math display">\[
\int_{B} \sigma \cdot \nabla ~\mathrm{d}x = \int_{\partial B} \sigma
\cdot n ~\mathrm{d}\sigma
\]</span> 再根据面微元的变换公式 (3), 得到 <span class="math display">\[
\int_{\partial B}  \sigma \cdot n ~\mathrm{d}\sigma
= \int_{\partial B_0} J \sigma \cdot F^{-\top} \cdot N ~\mathrm{d}\Sigma
\]</span> 定义第一类 P-K 应力为 <span class="math display">\[
P \triangleq J \sigma \cdot F^{-\top} \Rightarrow \sigma = \frac{1}{J} P
\cdot F^{\top}
\]</span> 代入式 (5) 中得到 <span class="math display">\[
\int_{\partial B_0} P \cdot N ~\mathrm{d}\Sigma
+ \int_{B_0} (\rho b - \rho a)J\mathrm{d}X = 0
\]</span> 在 <span class="math inline">\(B_0\)</span> 上应用散度定理,
以及 <span class="math inline">\(B_0\)</span> 的任意性,
就得到物质坐标表示的动量守恒定律: <span class="math display">\[
\boxed{
P \cdot \nabla_0 + \rho b - \rho a = 0
}
\tag{6}
\]</span></p>
<h2 id="角动量守恒定律">角动量守恒定律</h2>
<p>根据公式 <span class="math display">\[
\int_{B} e_{ijk} \sigma_{jk} ~\mathrm{d}x = 0
\]</span> 做参数变换, 得到 <span class="math display">\[
\int_{B_0} e_{ijk} P_{jJ} F_{kJ} ~\mathrm{d}X = 0
\]</span> 最终得到 <span class="math display">\[
P \cdot F^{\top} = F \cdot P^{\top}
\]</span></p>
]]></content>
      <categories>
        <category>连续介质力学</category>
      </categories>
      <tags>
        <tag>守恒定律</tag>
      </tags>
  </entry>
  <entry>
    <title>张量定义及坐标变换</title>
    <url>/mech/continuum/%E5%BC%A0%E9%87%8F%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="向量空间的定义">向量空间的定义</h2>
<p>向量空间的定义在此不再赘述, 不过需要补充一些 remarks:</p>
<blockquote>
<p>[!NOTE]</p>
<ol type="1">
<li>向量空间只定义了运算的概念, 并没有引入距离, 角度等拓扑概念.</li>
<li>向量空间中的“向量”并不局限于后文提到的一阶张量, 而是更抽象的概念,
比如表示全体连续函数的向量空间 <span
class="math inline">\(C^{0}\)</span>, 连续函数 <span
class="math inline">\(f\)</span> 是向量空间 <span
class="math inline">\(C^0\)</span> 中的一个元素.</li>
<li>向量空间总是需要伴随一个数域 <span
class="math inline">\(\mathbb{F}\)</span>, 可以是实数域 <span
class="math inline">\(\mathbb{R}\)</span>, 也可以是复数域 <span
class="math inline">\(\mathbb{C}\)</span>. 对于有限维的向量空间,
在给定一组基底之后, 就能够定义一个从 <span
class="math inline">\(V\)</span> 到 <span
class="math inline">\(\mathbb{F}^n\)</span> (<span
class="math inline">\(n\)</span> 为向量空间的维度) 的一一映射, 因此
<span class="math inline">\(V\)</span> 同构于 <span
class="math inline">\(\mathbb{F}^n\)</span></li>
</ol>
</blockquote>
<span id="more"></span>
<p>引入距离 (范数) 定义的是赋范空间. 引入内积定义的空间是内积空间.
内积可以诱导出范数的定义, 通过 <span class="math display">\[
\| x \| \triangleq \langle x,x  \rangle^{1/2}
\]</span> 特别的, 我们定义诱导出 Euclid
距离范数的内积为<strong>点积</strong>, 记作 <span
class="math display">\[
\langle a,b  \rangle \triangleq a \cdot b
\]</span> 在该内积定义下的向量空间为 <strong>Euclidean vector
space</strong>, 记作 <span class="math inline">\(\vec{E}\)</span>.
Euclidean vector space 中的元素称为<strong>自由向量</strong>.</p>
<p>空间 <span class="math inline">\(\vec{E}\)</span> 的 affine space
称为 <strong>Euclidean point space</strong>, 记作 <span
class="math inline">\(E\)</span>. <span class="math inline">\(E\)</span>
中的元素一般称为<strong>点</strong>, 点集 <span
class="math inline">\(E\)</span> 与向量空间 <span
class="math inline">\(\vec{E}\)</span> 之间的关系为: 对任意的一对点
<span class="math inline">\(P_1\)</span>, <span
class="math inline">\(P_2\)</span>, 存在自由向量 <span
class="math inline">\(v(P_1,P_2)\)</span>, 满足如下条件:</p>
<ol type="1">
<li><span class="math inline">\(v(P_1,P_2) = v(P_1,P_3) + v(P_3,P_2),
\quad \forall P_3 \in E\)</span></li>
<li><span class="math inline">\(v(P_1,P_2) = v(P_1,P_3) \iff P_2 =
P_3\)</span></li>
</ol>
<p>当给定空间 <span class="math inline">\(E\)</span> 中的一个参考点
<span class="math inline">\(O\)</span> 时, 就可以确定任一点 <span
class="math inline">\(P\)</span> 的<strong>位矢</strong> <span
class="math inline">\(x_P \in \vec{E}\)</span> 为 <span
class="math display">\[
x_P = v(P, O)
\]</span> 由此, 任意两点之间的距离, 和三点之间的夹角, 可以通过空间 <span
class="math inline">\(\vec{E}\)</span> 上距离和内积的定义进行计算.</p>
<p>接下来我们将定义<strong>坐标系</strong>. 最一般的坐标系是曲线坐标系,
它包含一个坐标原点 (由此可以度量空间 <span
class="math inline">\(E\)</span> 中点的位矢), 以及一系列坐标曲线,
每一条坐标曲线对应为某一个坐标分量为常数.
这些曲线在空间中的交汇点给出了这一点的坐标. 以下我们考虑笛卡尔坐标系,
它包含一个坐标原点 <span class="math inline">\(O \in E\)</span>,
和一组规范正交基 <span class="math inline">\(\{e_i\} \in
\vec{E}\)</span>. 坐标系 <span class="math inline">\(\{ O; e_i
\}\)</span> 同时定义了空间 <span class="math inline">\(\vec{E}\)</span>
中向量和点集 <span class="math inline">\(E\)</span> 中点的坐标:</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202407201444327.png"
alt="image-20240720144358373" />
<figcaption aria-hidden="true">image-20240720144358373</figcaption>
</figure>
<p>笛卡尔坐标定义了一个从 <span class="math inline">\(E\)</span> 到
<span class="math inline">\(\mathbb{R}^n\)</span> 的同构. 对任意向量(点)
<span class="math inline">\(a\)</span>, 可以表示为一个元组 <span
class="math display">\[
a \cong (a_1, a_2, \ldots, a_n), \quad a = a_i e_i, \quad  a_i = a \cdot
e_i
\]</span> 使用分量表示空间 <span class="math inline">\(\vec{E}\)</span>
中的内积和距离范数为: <span class="math display">\[
a \cdot b = a_i b_i, \quad \|a\| = \sqrt{a_i a_i}
\]</span></p>
<h2 id="基底变换符号约定">基底变换符号约定</h2>
<p>考虑两组正交规范基 <span class="math inline">\(\{e_i&#39;\}\)</span>
和 <span class="math inline">\(\{e_{\alpha}\}\)</span>, 其中指标 <span
class="math inline">\(i\)</span> 表示新坐标系的基底, 上方带 <span
class="math inline">\(&#39;\)</span> 是为了区分新旧基底的分量; <span
class="math inline">\(\alpha\)</span> 表示旧坐标系的基底. 新基底 <span
class="math inline">\(e_i&#39;\)</span> 总是能通过旧基底 <span
class="math inline">\(e_{\alpha}\)</span> 表示为 <span
class="math display">\[
\boxed{
\boldsymbol{e}_i&#39; = Q_{\alpha i} \boldsymbol{e}_{\alpha}
}
\tag{1}
\]</span> 其中, <span class="math inline">\(Q_{\alpha i}\)</span>
可以写成 <span class="math display">\[
Q_{\alpha i} = \boldsymbol{e}_{\alpha} \cdot \boldsymbol{e}&#39;_{i}
\]</span> 当基底是正交规范基时, 转换矩阵 <span
class="math inline">\(Q\)</span> 是正交矩阵, 这是因为 <span
class="math display">\[
\delta_{ij} = e_i&#39; \cdot e_j&#39; = Q_{\alpha i} e_{\alpha} Q_{\beta
j} e_{\beta}
= Q_{\alpha i}Q_{\alpha j}
\]</span> 写成矩阵形式为 <span class="math display">\[
QQ^{\top} = I
\]</span> 注意到, 矩阵 <span class="math inline">\(Q\)</span>
的行列式值有两种可能: <span class="math inline">\(\pm 1\)</span>. 当
<span class="math inline">\(\det Q = +1\)</span> 时, 称 <span
class="math inline">\(Q\)</span> 为 proper orthogonal, 对应为纯旋转; 当
<span class="math inline">\(\det Q = -1\)</span> 时, 对应为旋转加镜像.
以下默认为 proper orthogonal 情况.</p>
<blockquote>
<p>[!NOTE]</p>
<p>一些教材定义矩阵 <span class="math inline">\(Q\)</span>
的方式与此处不同. 这里行指标是旧基底, 列指标是新基底, 所以,
如果将新基底写成旧基底分量的形式, 对应矩阵 <span
class="math inline">\(Q\)</span>
的<strong>列</strong>向量是新基底(在旧基底下的分量形式)</p>
</blockquote>
<h2
id="向量在不同基底下的坐标变换规则">向量在不同基底下的坐标变换规则</h2>
<p>接下来, 我们考虑向量分量在不同坐标系下的变换规则. 对于向量 <span
class="math inline">\(a\)</span>, 在新旧坐标系下的分量分别表示为 <span
class="math display">\[
a = a_i&#39; e_i&#39; = a_{\alpha} e_{\alpha}
\]</span> 将式 (1) 中基底转换关系代入到上式中,
就得到不同坐标系下分量之间的关系 <span class="math display">\[
a_i&#39; e_i&#39; = a_i&#39;Q_{\alpha i} e_{\alpha} =  a_{\alpha}
e_{\alpha}
\Rightarrow \boxed{a_{\alpha} = Q_{\alpha i} a_i&#39;, \quad  a_i&#39; =
Q_{\alpha i} a_{\alpha}}
\tag{2}
\]</span> 因此, 也可以用如上坐标变换关系定义向量.</p>
<h2 id="一般的高阶张量">一般的高阶张量</h2>
<p>如果考虑对偶空间 <span class="math inline">\(V^{*}\)</span>, 那么存在
<span class="math inline">\(v^{*} \in V^{*}\)</span>, 使得 <span
class="math display">\[
v^{*}[u] = v \cdot u, \quad \forall u \in V
\]</span> 因此一阶张量除了看作是向量空间 <span
class="math inline">\(V\)</span> 的元素之外, 在同构的意义上,
还可以看作是 <span class="math inline">\(V\)</span> 上的线性映射.
从这一观点出发, 很容易得到 <span class="math inline">\(n\)</span>
阶张量的另一种方式, 也就是 <span class="math inline">\(V\)</span>
的乘积空间上的线性映射: <span class="math display">\[
T: \underbrace{V \times \cdots \times V}_{n} \mapsto \mathbb{R}
\]</span></p>
<h2 id="坐标变换">坐标变换</h2>
<p>考虑点集 <span class="math inline">\(E\)</span> 中的一点 <span
class="math inline">\(P\)</span> 在不同的笛卡尔坐标系 <span
class="math inline">\(\{ O; e_\alpha \}\)</span> , <span
class="math inline">\(\{ O&#39;; e_i&#39; \}\)</span> 下的表示. 向量
<span class="math inline">\(OP\)</span> 表示为 <span
class="math display">\[
OP = x_{\alpha} e_{\alpha}
\]</span> <span class="math inline">\(O&#39;P\)</span> 表示为 <span
class="math display">\[
O&#39;P = O&#39;O + OP = O&#39;O + \tilde{x}_i&#39; e_i&#39;
\]</span> 如果记 <span class="math inline">\(O&#39;O = o_i&#39;
e_i&#39;\)</span>, 再根据式 (2), 可以得到坐标 <span
class="math inline">\(x_\alpha\)</span> 和 <span
class="math inline">\(x_i&#39;\)</span> 之间的关系为 <span
class="math display">\[
x_i&#39; = o_i&#39; + \tilde{x}_i&#39; = o_i&#39; + Q_{\alpha i}
x_{\alpha}
\]</span> 坐标变换的偏导数之间的关系为 <span class="math display">\[
\frac{\partial x_i&#39;}{\partial x_{\alpha}} = Q_{\alpha i}
\]</span> 通过上述关系, 就不难验证, 对于 <span
class="math inline">\(n\)</span> 阶张量场 <span
class="math inline">\(T_{\cdot}\)</span>, 其偏导数得到 <span
class="math inline">\(n+1\)</span> 阶张量场. 我们需要验证张量分量的导数
<span class="math inline">\(T_{\cdot,\alpha}\)</span> 关于指标 <span
class="math inline">\(\alpha\)</span> 的坐标变换关系. <span
class="math display">\[
T_{\cdot,\alpha} = \frac{\partial T_{\cdot}}{\partial x_{\alpha}}
= \frac{\partial T_{\cdot}}{\partial x_{i}&#39;} \frac{\partial
x_i&#39;}{\partial x_{\alpha}}
= Q_{\alpha i} T_{\cdot,i}
\]</span> 由此得到通过求偏导数增加的指标, 是满足坐标变换关系的, 因此
<span class="math inline">\(T_{\cdot,\alpha}\)</span> 是比 <span
class="math inline">\(T\)</span> 高一阶的张量.</p>
]]></content>
      <categories>
        <category>连续介质力学</category>
      </categories>
      <tags>
        <tag>张量运算</tag>
      </tags>
  </entry>
  <entry>
    <title>速度梯度及相关推导</title>
    <url>/mech/continuum/%E9%80%9F%E5%BA%A6%E6%A2%AF%E5%BA%A6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<p>伸长率 <span class="math inline">\(\lambda\)</span>
在参考构型中表示为 <span class="math display">\[
\lambda^2 = N   C   N
\]</span> 两边求物质导数, 得到 <span class="math display">\[
2 \lambda \dot{\lambda} = N \dot{C} N
\]</span> 其中, <span class="math display">\[
\dot{C} = \dot{F}^{\top}F + F^{\top} \dot{F}
\]</span> 代入式中, 得到 <span class="math display">\[
2 \lambda \dot{\lambda} = N \dot{F}^{\top}F N + N F^{\top} \dot{F} N
\]</span> <span id="more"></span>再根据 <span class="math inline">\(\lambda n =
FN\)</span>, <span class="math display">\[
\dot{\lambda}/\lambda = n D n
\]</span> 式中, <span class="math display">\[
D \triangleq \frac{1}{2}\left( \dot{F} F^{-1} + (\dot{F} F^{-1})^{\top}
\right)
\]</span> <span class="math inline">\(\dot{F} F^{-1}\)</span>
写成分量形式, 就得到 <span class="math display">\[
(\dot{F} F^{-1})_{ij} = \frac{D ~}{D t}
\frac{\partial x_i}{\partial X_I}
\frac{\partial X_I}{\partial x_j}
= \frac{\partial v_i}{\partial x_j}
\triangleq L_{ij}
\]</span> 或者写成张量形式 <span class="math display">\[
\dot{F} F^{-1} = L = \nabla_x v, \quad
\dot{F} = L F
\]</span> 所以 <span class="math display">\[
D = \frac{1}{2}\left( \nabla_x v + \nabla_x v^{\top}  \right)
\]</span> 张量 <span class="math inline">\(D\)</span>
刻画了物质的变形率, (变形比率的速率), 类似于小位移假设下的变形张量,
<span class="math inline">\(D\)</span> 也是速度梯度 <span
class="math inline">\(\nabla_x v\)</span> 的对称部分, 不过这里得到的
<span class="math inline">\(D\)</span> 是准确刻画变形率的张量,
没有隐藏假设条件. 在纯刚体旋转条件下, <span class="math inline">\(D
\equiv 0\)</span>.</p>
<p>同样的, 速度梯度的反对称部分, 刻画了物质的旋转速率, 定义为 <span
class="math display">\[
W \triangleq \frac{1}{2}\left( \nabla_x v - \nabla_x v^{\top} \right)
\]</span> 为反对称张量 <span class="math inline">\(W\)</span> 引入向量
<span class="math inline">\(w\)</span>, 满足 <span
class="math display">\[
W_{ij} \triangleq -\frac{1}{2} e_{ijk} w_k, \quad \text{or} \quad
w_{i} \triangleq- e_{ijk} W_{jk}
\]</span> 再根据旋度的定义, 就得到 <span
class="math inline">\(w\)</span> 与速度 <span
class="math inline">\(v\)</span> 的关系: <span class="math display">\[
w = \mathrm{curl}~ v
\]</span> 对于过点 <span class="math inline">\(O\)</span> 绕轴 <span
class="math inline">\(n\)</span> 作匀速刚体转动, 角速度为 <span
class="math inline">\(\omega\)</span>, <span class="math display">\[
R_{ik}(\omega t) = (1-\cos \omega t)n_i n_k + \cos \omega t \delta_{ik}
+ \sin \omega t e_{ijk} n_j, \quad
x = R(\omega t)X
\]</span> 速度场为 <span class="math display">\[
v(X,t) = \omega R&#39; X
\]</span> 如果将速度场表示为空间坐标的函数, 那么 <span
class="math display">\[
v(x,t) = \omega R&#39; R^{\top} x = \omega n \times x
\]</span> Vortex flow 并不是纯转动, 绕 <span
class="math inline">\(e_3\)</span> 的 Vortex flow 为 <span
class="math display">\[
v_1 = \frac{-\kappa x_2}{|x|^2}, \quad v_2 = \frac{\kappa x_1}{|x|^2},
\quad v_3 = 0
\]</span> 式中, <span class="math inline">\(\kappa &gt;0\)</span>
为一个常数. 注意到, Vortex 流场速度方向和纯转动速度场是一致的,
但是速度的大小并不正比于空间点到旋转轴的距离, 而是等于常数 <span
class="math inline">\(\kappa\)</span>. 该速度场的速度梯度为 <span
class="math display">\[
L = \begin{bmatrix}
\dfrac{2\kappa x_1 x_2}{|x|^4} &amp; \dfrac{\kappa (x_2^2 -
x_1^2)}{|x|^4} \\
\dfrac{\kappa (x_2^2 - x_1^2)}{|x|^4} &amp; -\dfrac{2\kappa x_1
x_2}{|x|^4}
\end{bmatrix}
\]</span> <span class="math inline">\(L\)</span> 对称, 因此 <span
class="math inline">\(D = L\)</span>, <span class="math inline">\(W =
0\)</span>.</p>
]]></content>
      <categories>
        <category>连续介质力学</category>
      </categories>
      <tags>
        <tag>速度梯度</tag>
      </tags>
  </entry>
  <entry>
    <title>空间坐标下的守恒方程</title>
    <url>/mech/continuum/%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E5%AE%88%E6%81%92%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="质量守恒">质量守恒</h2>
<p>考虑空间坐标下的控制体 <span class="math inline">\(V\)</span>, 在
<span class="math inline">\(\delta t\)</span> 时间内, 流出控制体 <span
class="math inline">\(V\)</span> 的质量为 <span class="math display">\[
\mathrm{d} m = \delta_t\int_{\partial V} \rho v\cdot n  ~\mathrm{d}S +
\mathcal{O}(\delta t^2)
\]</span> 控制体在 <span class="math inline">\(t+\delta t\)</span>
时刻的质量为 <span class="math display">\[
m_V(t+\delta t) = \int_{V} \rho(x,t+\delta t) ~\mathrm{d}x
\]</span> 质量守恒的表述为: 在控制体的质量改变,
只能通过质量进出控制体引起. 因此有 <span class="math display">\[
m_{V}(t + \delta t) = m_{V}(t) - \mathrm{d} m
\Rightarrow m_{V}(t + \delta t) - m_{V}(t) + \mathrm{d} m = 0
\]</span> <span id="more"></span>两边同除 <span class="math inline">\(\delta
t\)</span>, 并令 <span class="math inline">\(\delta t \rightarrow
0\)</span>, 就得到 <span class="math display">\[
\int_{V} \frac{\partial \rho}{\partial t} ~\mathrm{d}x
+ \int_{\partial V} \rho v\cdot n  ~\mathrm{d}S = 0
\]</span> 再应用散度定理, 就得到 <span class="math display">\[
\int_{V} \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho v)
~\mathrm{d}x  = 0
\]</span> 又因为 <span class="math inline">\(V\)</span> 是任意选取的,
所以有 <span class="math display">\[
\boxed{
\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho v) = 0
}
\tag{1}
\]</span> 如果材料不可压缩, 那么, 无论是物质坐标下,
还是空间坐标下的密度, 都是恒定不变的常数. 因此, 根据式 (1) 有 <span
class="math display">\[
J \equiv 1
\]</span> 同时为了保证质量守恒, 又不能改变物质的密度,
因此必须对速度场进行约束: <span class="math display">\[
\nabla \cdot v = 0
\]</span></p>
<h2 id="输运定理">输运定理</h2>
<p>设想一个包裹着一团物质的曲面 <span class="math inline">\(\partial
B\)</span>, 当材料变形时, 曲面也在不断地变形. 在当前构型中,
设由该曲面包裹的物质区域为 <span class="math inline">\(B\)</span>.
对该区域的物理量(的质量密度) <span class="math inline">\(\phi\)</span>
进行积分: <span class="math display">\[
\Phi_{B}(t) = \int_{B} \rho \phi ~\mathrm{d} x
\]</span> 与此同时, 在当前构型中考虑与 <span
class="math inline">\(B\)</span> 重合的控制体 <span
class="math inline">\(V\)</span>, 对上式积分项求偏导数后积分: <span
class="math display">\[
\int_{V} \frac{\partial (\rho \phi)}{\partial t} ~\mathrm{d}x
\]</span> <span class="math inline">\(\Phi\)</span> 在控制体 <span
class="math inline">\(V\)</span> 中的增加量, 等于物质面 <span
class="math inline">\(B\)</span> 中 <span
class="math inline">\(\Phi\)</span> 的增加量, 再加上流进 <span
class="math inline">\(V\)</span> 的 <span
class="math inline">\(\Phi\)</span>, 写成公式为 <span
class="math display">\[
\int_{V} \frac{\partial (\rho \phi)}{\partial t} ~\mathrm{d}x
= \frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho \phi ~\mathrm{d}x
- \int_{\partial V} \rho \phi v \cdot n ~\mathrm{d} S
\]</span> 应用散度定理, 上式就可以写成 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho \phi ~\mathrm{d}x
= \int_{V} \frac{\partial (\rho \phi)}{\partial t}
+ \mathrm{div}(\rho \phi v) ~\mathrm{d} x
\tag{2}
\]</span> 观察式 (2), 可以看到, 等式左端是物质团 <span
class="math inline">\(B\)</span> 关于时间的变化率,
等式右端是关于空间区域 <span class="math inline">\(V\)</span> 的积分,
因此, 输运定理将物质团变化率表述为为空间坐标的形式. 需要指出的是,
输运定理并不是守恒定律, 但确实可以通过质量守恒进行化简. 式 (2)
右端项可以展开为 <span class="math display">\[
\int_{V} \frac{\partial (\rho \phi)}{\partial t}
+ \mathrm{div}(\rho \phi v) ~\mathrm{d} x
= \int_{V} \rho \frac{\partial \phi}{\partial t} + \rho v \cdot \nabla
\phi
+ \phi \left( \frac{\partial \rho}{\partial t} + \mathrm{div}(\rho v)
\right) ~\mathrm{d} x \\
= \int_{V} \rho \left( \frac{\partial \phi}{\partial t} +  v \cdot
\nabla \phi \right) ~\mathrm{d} x
= \int_{V} \rho \frac{\mathrm{D} \phi}{\mathrm{D} t} ~\mathrm{d} x
\]</span> 所以, 式 (2) 可以通过质量守恒 (1) 化简为 <span
class="math display">\[
\boxed{
\frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho \phi ~\mathrm{d}x
= \int_{V} \rho \frac{\mathrm{D} \phi}{\mathrm{D} t} ~\mathrm{d} x
}
\tag{3}
\]</span> 可见物质团 <span class="math inline">\(B\)</span>
积分号外的关于时间的导数, 移动到控制体积分中对物理量 <span
class="math inline">\(\phi\)</span> 的物质导数.</p>
<blockquote>
<p>[!NOTE]</p>
<h5
id="应用输运定理推导质量守恒的空间表达形式">应用输运定理推导质量守恒的空间表达形式</h5>
<p>围绕在物质曲面 <span class="math inline">\(\partial B\)</span>
的物理量 <span class="math inline">\(\phi\)</span> 如果等于恒定的常数
<span class="math inline">\(1\)</span>, 那么 <span
class="math inline">\(\phi\)</span>
在空间或者物质坐标下的表达形式是相同的. 定义关于时间的函数 <span
class="math inline">\(m(t)\)</span> 为 <span class="math display">\[
m(t) \triangleq \int_{B} \rho(x,t) ~\mathrm{d}x
\]</span> 质量守恒定律声明, 物质团的质量, 无论物质如何变形,
总是恒定不变, 因此 <span class="math display">\[
m(t) \equiv m(0) = \int_{B_0} \rho(X,0) ~\mathrm{d}X
\]</span> 因此 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho ~\mathrm{d}x  \equiv 0
\]</span> 代入式 (2) 中得到 <span class="math display">\[
\int_{V} \frac{\partial \rho}{\partial t}
+ \mathrm{div}(\rho v) ~\mathrm{d} x = 0
\]</span></p>
</blockquote>
<h2 id="动量守恒定律">动量守恒定律</h2>
<p>粒子所满足的动量守恒定律为: 粒子动量的变化率, 等于粒子所受的外力:
<span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} (mv) = f
\]</span> 将粒子换成物质团 <span class="math inline">\(B\)</span>,
就得到 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho v ~\mathrm{d}x = f
\]</span> 对上式左端应用质量守恒简化后的输运定理 (3) : <span
class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho v ~\mathrm{d}x = \int_{V}
\rho a ~\mathrm{d}x
\]</span> 在当前构型下, 选取与 <span class="math inline">\(B\)</span>
重合的控制体 <span class="math inline">\(V\)</span>,
外力可以表示为两部分: <span class="math inline">\(V\)</span> 内的体力和
<span class="math inline">\(\partial V\)</span> 上的面力: <span
class="math display">\[
f = \int_{V} \rho b ~\mathrm{d}x + \int_{\partial V} \sigma \cdot n
~\mathrm{d}S
\]</span> 再应用散度定理, 将面积分转换为体积分, 就得到 <span
class="math display">\[
\int_{V} \sigma \cdot \nabla + \rho b - \rho a ~\mathrm{d}V = 0
\]</span> 又因为 <span class="math inline">\(V\)</span> 的任意性,
所以得到空间坐标下的动量守恒定律的微分形式 <span class="math display">\[
\boxed{
\sigma \cdot \nabla + \rho b - \rho a = 0
}
\tag{4}
\]</span></p>
<p>如果系统满足平衡方程, 那么加速度 <span
class="math inline">\(a=0\)</span>, 因此式 (4) 为 <span
class="math display">\[
\boxed{
\sigma \cdot \nabla + \rho b= 0
}
\tag{5}
\]</span></p>
<h2 id="角动量守恒定律">角动量守恒定律</h2>
<p>粒子所满足的角动量守恒定律为: 粒子关于坐标系原点 <span
class="math inline">\(O\)</span> 角动量的变化率, 等于粒子所受的外力矩:
<span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} (x \times mv) = x \times f
\]</span> 我们应用分量形式进行推导, 上述方程的左端为 <span
class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho x \times v ~\mathrm{d}x
= \int_{V} \rho e_{ijk} \frac{\mathrm{D} (x_j v_k)}{\mathrm{D} t}
~\mathrm{d}x
= \int_{V} \underbrace{\rho e_{ijk} v_j v_k}_{=0} + \rho e_{ijk} x_j a_k
~\mathrm{d}x
= \int_{V} \rho e_{ijk} x_j a_k ~\mathrm{d}x
\]</span> 方程的右端为 <span class="math display">\[
x \times f = \int_{V} \rho e_{ijk} x_j b_k ~\mathrm{d}x
+ \int_{\partial V} e_{ijk} x_j \sigma_{kl} n_{l} ~\mathrm{d}S
\]</span> 并应用散度定理, 得到 <span class="math display">\[
\int_{\partial V} e_{ijk} x_j \sigma_{kl} n_{l} ~\mathrm{d}S
= \int_{V} e_{ijk} (x_j \sigma_{kl})_{,l} ~\mathrm{d}x
\]</span> 式中的积分项为 <span class="math display">\[
e_{ijk} (x_j \sigma_{kl})_{,l} = e_{ijk} (\sigma_{kj} + x_{j}
\sigma_{ki,i})
\]</span> 代入到角动量守恒方程中, 整理得到 <span class="math display">\[
\int_{V} e_{ijk} x_j (\rho  a_k - \rho b_k - \sigma_{ki,i}) ~\mathrm{d}x
= \int_{V} e_{ijk} \sigma_{kj} ~\mathrm{d}x
\]</span> 根据平衡方程 (4), 上式左端恒等于 0, 所以 <span
class="math display">\[
\boxed{
e_{ijk} \sigma_{kj} = 0 \Rightarrow \sigma_{jk} = \sigma_{kj}
}
\tag{6}
\]</span></p>
<h2 id="能量守恒定律">能量守恒定律</h2>
<p>物质的能量由动能 <span class="math inline">\(K\)</span> 和内能 <span
class="math inline">\(E\)</span> 构成, 定义为 <span
class="math display">\[
K \triangleq \frac{1}{2} \int_{B} \rho |v|^2 ~\mathrm{d}x, \quad
E \triangleq \int_{B} \rho e ~\mathrm{d}x
\]</span> 式中, <span class="math inline">\(|v|^2 = v \cdot v\)</span>,
<span class="math inline">\(e\)</span> 为材料内能的质量密度.
物质团的能量来源有两种: 外力做功与其它形式热量的流入流出.
因此能量守恒定律就是在陈述这些能量的平衡关系.</p>
<blockquote>
<p>[!NOTE]</p>
<p>如果我们不能够确定内能 <span class="math inline">\(e\)</span> 或
<span class="math inline">\(E\)</span> 的形式,
那么能量守恒定律只能是一个文字的陈述, 或者作为内能的定义.
能量守恒只有在确定内能形式 (也就是本构) 的时候才有用.</p>
</blockquote>
<p>如果考虑外部能量的来源只有热流 <span
class="math inline">\(h\)</span>, 那么能量守恒定律可以表示为 <span
class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho \left( \frac{1}{2}|v^2| +
e \right) ~\mathrm{d}x
= \int_{V} \rho b \cdot v ~\mathrm{d}x + \int_{\partial V}  (v \cdot
\sigma - h) \cdot n ~\mathrm{d}S
\]</span> 对上式左端应用输运定理得到 <span class="math display">\[
\frac{\mathrm{d}~}{\mathrm{d} t} \int_{B} \rho \left( \frac{1}{2}|v^2| +
e \right) ~\mathrm{d}x
= \int_{V} \rho a \cdot v + \rho \dot{e} ~\mathrm{d}x
\]</span> 再由 <span class="math inline">\(V\)</span> 的任意性,
得到微分形式的能量守恒定律 <span class="math display">\[
\rho a \cdot v + \rho \dot{e} = \rho b \cdot v + (v \cdot \sigma) \cdot
\nabla - h \cdot \nabla
\]</span> 式中, <span class="math display">\[
(v \cdot \sigma) \cdot \nabla = (v_{i} \sigma_{ij})_{,j}
= (\sigma \cdot \nabla) \cdot v + \sigma : v \nabla
\]</span> 代入得到 <span class="math display">\[
[\rho a - \rho b - (\sigma \cdot \nabla)] \cdot v
+ \rho \dot{e}
- \sigma : v \nabla
+ h \cdot \nabla
=0
\]</span> 也即 <span class="math display">\[
\boxed{
\rho \dot{e} - \sigma : v \nabla+ h \cdot \nabla = 0
}
\tag{7}
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<h5
id="不可压缩牛顿流体的能量守恒方程">不可压缩牛顿流体的能量守恒方程</h5>
<p>流体的本构方程为 <span class="math display">\[
\sigma = -p I + 2\mu D
\]</span> 热流满足 Fourier 传热定律: <span class="math display">\[
h = - \kappa \nabla T
\]</span> 流体的内能密度只与温度相关 <span class="math display">\[
e = C_m T
\]</span> 代入到方程 (7) 中得到 <span class="math display">\[
\rho C_m \dot{T} + p \nabla \cdot v= 2\mu D : D + \nabla^2 T
\]</span> 又因为不可压缩性, 所以 <span class="math inline">\(\nabla
\cdot v \equiv 0\)</span>, 因此 <span class="math display">\[
\rho C_m \dot{T} = 2\mu D : D + \nabla^2 T
\]</span></p>
</blockquote>
<h2 id="虚功原理">虚功原理</h2>
<p>考虑满足平衡方程 <span class="math display">\[
\sigma \cdot \nabla + \rho b = 0
\]</span> 的应力场 <span class="math inline">\(\sigma\)</span>,
以及独立的速度场 <span class="math inline">\(v\)</span>,
和相应的变形率张量 <span class="math display">\[
D = \frac{1}{2} ( \nabla v + v \nabla )
\]</span> 需要强调的是, 应力场 <span
class="math inline">\(\sigma\)</span> 和速度场 <span
class="math inline">\(v\)</span> 是<strong>相互独立</strong>的,
没有任何的关联. 在 <span class="math inline">\(V\)</span>
上对应力和变形率张量的双点积积分得到 <span class="math display">\[
\int_{V} \sigma : D ~\mathrm{d} x
= \int_{V} \sigma : v\nabla ~\mathrm{d}x
= \int_{\partial V} v \cdot \sigma \cdot n ~\mathrm{d}S
+ \int_{V} \rho b \cdot v ~\mathrm{d}x
\]</span> 注意到 <span class="math inline">\(\sigma \cdot n =
t^{(n)}\)</span> 为作用在边界 <span class="math inline">\(\partial
V\)</span> 的面力, 因此 <span class="math display">\[
\boxed{
\int_{V} \sigma : D ~\mathrm{d} x
= \int_{\partial V} t^{(n)} \cdot v ~\mathrm{d}S
+ \int_{V} \rho b \cdot v ~\mathrm{d}x
}
\tag{8}
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<h5 id="小变形下的虚功原理">小变形下的虚功原理</h5>
<p>在小变形假设下, <span class="math display">\[
\delta u = v \delta t, \quad \delta  \varepsilon \triangleq
\frac{1}{2}(\nabla \delta u + \delta u \nabla) = D \delta  t
\]</span> 因此, 对式 (8) 两边同乘 <span class="math inline">\(\delta
t\)</span>, 得到 <span class="math display">\[
\int_{V} \sigma : \delta \varepsilon ~\mathrm{d} x
= \int_{\partial V} t^{(n)} \cdot \delta u ~\mathrm{d}S
+ \int_{V} \rho b \cdot \delta u ~\mathrm{d}x
\]</span></p>
</blockquote>
]]></content>
      <categories>
        <category>连续介质力学</category>
      </categories>
      <tags>
        <tag>守恒定律</tag>
      </tags>
  </entry>
  <entry>
    <title>四阶单位张量定义及 Voigt 表示方法</title>
    <url>/mech/fem/%E5%9B%9B%E9%98%B6%E5%8D%95%E4%BD%8D%E5%BC%A0%E9%87%8F%E5%AE%9A%E4%B9%89%E5%8F%8A-Voigt-%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="四阶单位张量的不同定义方式">四阶单位张量的不同定义方式</h2>
<p>四阶单位张量可以表示为含有四个自由指标 Kronecker delta 记号的组合:
<span class="math inline">\(\delta_{ij} \delta_{kl}\)</span>. 不过,
与二阶单位张量不同的是, 改变指标的顺序, 会得到三种不同的四阶单位张量:
<span class="math display">\[
\delta_{ij} \delta_{kl} \triangleq {\mathcal{F}}_{iljk}
\triangleq{\mathcal{E}}_{ikjl} \triangleq {\mathcal{I}}_{ijkl}
\]</span></p>
<p>或者</p>
<p><span class="math display">\[
{\mathcal{I}}_{ijkl} \triangleq \delta_{ij} \delta_{kl} ,\quad
{\mathcal{E}}_{ijkl} \triangleq \delta_{ik} \delta_{jl} ,\quad
{\mathcal{F}}_{ijkl} \triangleq \delta_{il} \delta_{jk}
\tag{1}
\]</span></p>
<span id="more"></span>
<p>对于任意四阶张量 <span class="math inline">\(\mathbb{L}\)</span>,
在双点积 (<span class="math inline">\(A:B:=A_{\cdot mn} B_{mn\cdot
}\)</span>) 作用下, 张量 <span
class="math inline">\(\mathcal{E}\)</span> 满足:</p>
<p><span class="math display">\[
\mathcal{E}:\mathbb{L}=\delta_{ik} \delta_{jl} L_{klmn} = L_{ijmn},
\quad
\mathbb{L}:\mathcal{E}= L_{ijkl} \delta_{km} \delta_{ln}= L_{ijmn}
\]</span></p>
<p>除上述三种定义四阶单位张量的方式之外, 还可以定义如下四阶张量:</p>
<p><span class="math display">\[
\mathcal{L}_{ijkl}\triangleq\frac{1}{2}(\mathcal{F}_{ijkl}+\mathcal{E}_{ijkl})
= \frac{1}{2}(\delta_{il} \delta_{jk}+\delta_{ik} \delta_{jl})
\]</span></p>
<p>如果四阶张量的指标满足 <span class="math display">\[
\square_{ijkl} = \square_{jikl} = \square_{ijlk}
\]</span> 那么称张量 <span class="math inline">\(\square_{ijkl}\)</span>
具有次对称性. 具有次对称性的单位张量为 <span
class="math inline">\(\mathcal{L}_{ijkl}\)</span></p>
<p>在力学中, 我们一般将四阶单位张量 <span
class="math inline">\(\mathcal{I}_{ijkl}\)</span> 和 <span
class="math inline">\(\mathcal{L}_{ijkl}\)</span> 分别记作 <span
class="math display">\[
\mathcal{I}_{ijkl} \triangleq \mathbf{I} \otimes \mathbf{I}, \quad
\mathcal{L}_{ijkl} \triangleq \mathbb{I}
\]</span></p>
<h2 id="四阶单位张量的-voigt-矩阵形式">四阶单位张量的 Voigt
矩阵形式</h2>
<p>将式 (1) 定义的三种单位张量写成 Voigt 矩阵形式为 <span
class="math display">\[
[\mathcal{I}] = \begin{pmatrix}
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
      \end{pmatrix}, \quad
[\mathcal{E}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}, \quad
[\mathcal{F}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}.
\]</span></p>
<p>以及单位张量 <span class="math inline">\(\mathcal{L}_{ijkl}\)</span>
<span class="math display">\[
[\mathcal{L}] = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2}
    \end{pmatrix}
\]</span> 计算单位张量的 MATLAB 脚本见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpdXhpYW9odW8vZm91cnRoLW9yZGVyLWlkZW50aXR5LXRlbnNvcg==">Github<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="voigt-映射定义">Voigt 映射定义</h2>
<p>二阶张量 <span class="math inline">\(\mathbf{A}\)</span> 在 <span
class="math inline">\(\mathbb{R}^3\)</span> 空间的基底下可以表示为矩阵
<span class="math inline">\(\{A_{ij}\} \in \mathbb{R}^3 \times
\mathbb{R}^3\)</span>. 如果张量 <span
class="math inline">\(\mathbf{A}\)</span> 为对称张量, 那么矩阵 <span
class="math inline">\(\{A_{ij}\}\)</span> 同样为对称矩阵,
因此只需要一个向量 <span class="math inline">\(\mathrm{vec}~A \in
\mathbb{R}^6\)</span>, 就可以完全保存二阶对称张量 <span
class="math inline">\(\mathbf{A}\)</span> 的信息. 我们定义 Voigt 映射
<span class="math inline">\([\cdot]: \mathbb{R}^3 \times \mathbb{R}^3
\mapsto \mathbb{R}^6\)</span> <span class="math display">\[
\begin{aligned}[]
[A]: ~
&amp;[A]_{1} = A_{11}, \quad
[A]_{2} = A_{22}, \quad
[A]_{3} = A_{33}, \quad \\
&amp;[A]_{4} = A_{23}, \quad
[A]_{5} = A_{13}, \quad
[A]_{6} = A_{12}  \quad \\
\end{aligned}
\]</span> 对于四阶张量, Voigt 映射会将该张量映射为一个 6x6 的矩阵.
如果该张量具有<strong>次对称性</strong>, 那么在 Voigt 映射下,
<strong>不会丢失掉该张量任何一个分量的信息</strong>. 特别的,
如果四阶张量还具有<strong>主对称性</strong>, 那么使用 Voigt
映射之后得到的矩阵是<strong>对称矩阵.</strong> <!--more--></p>
<div class="note primary no-icon"><h5 id="例-四阶弹性模量张量-l_ijkl-的-voigt-表示">例: 四阶弹性模量张量
<span class="math inline">\(L_{ijkl}\)</span> 的 Voigt 表示</h5>
<p>对于各向同性材料, 四阶弹性模量张量 <span
class="math inline">\(L_{ijkl}\)</span> 可以用 Lame 系数表示为 <span
class="math display">\[
L_{ijkl} = \lambda \delta_{ij} \delta_{kl}
                       + \mu \delta_{ik} \delta_{jl}
                       + \mu \delta_{il} \delta_{jk},
\]</span> 式中的 Kronecker 记号可以用 Voigt 映射为矩阵 <span
class="math display">\[
[\delta_{ij}\delta_{kl}] = \begin{pmatrix}
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
      \end{pmatrix}, \quad
[\delta_{ik}\delta_{jl}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}, \quad
[\delta_{il}\delta_{jl}] = \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}.
\]</span></p>
<p>所以 <span class="math inline">\(L_{ijkl}\)</span> 写成 <span
class="math display">\[
\begin{aligned}[]
[{L}_{ijkl}] &amp;= \lambda \begin{pmatrix}
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
      \end{pmatrix}
+ \mu \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}
+ \mu \begin{pmatrix}
      1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{pmatrix}  \\
&amp;= \begin{pmatrix}
      \lambda+2\mu &amp; \lambda &amp; \lambda &amp; 0 &amp; 0 &amp; 0
\\
      \lambda &amp; \lambda+2\mu &amp; \lambda &amp; 0 &amp; 0 &amp; 0
\\
      \lambda &amp; \lambda &amp; \lambda+2\mu &amp; 0 &amp; 0 &amp; 0
\\
      0 &amp; 0 &amp; 0 &amp; \mu &amp; 0 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; \mu &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \mu
    \end{pmatrix}
\end{aligned}
\]</span></p>
</div>
<h2 id="voigt-映射下的张量运算">Voigt 映射下的张量运算</h2>
<p>我们现在关心的是, 在 Voigt 映射下, 张量运算将会转变为怎样的矩阵运算?
在下文的例子中, 如果不特别说明, 我们默认四阶张量具有次对称性,
二阶张量具有对称性.</p>
<h3 id="张量的线性组合">张量的线性组合</h3>
<p>Voigt 映射是线性的，因此，对任意张量 <span class="math display">\[
[\lambda A + \mu B] = \lambda [A] + \mu [B]
\]</span></p>
<h3 id="张量的双点积运算">张量的双点积运算</h3>
<p>给定四阶张量 <span class="math inline">\(\mathbb{L}\)</span>,
二阶张量 <span class="math inline">\(\epsilon\)</span>,
双点积得到另一个二阶张量 <span class="math inline">\(\sigma\)</span> :
<span class="math display">\[
\sigma_{ij} = \mathbb{L} : \epsilon = L_{ijkl} \epsilon_{kl}
\]</span> 我们考虑张量分量 <span
class="math inline">\(\sigma_{11}\)</span>, 也是 Voigt 形式下向量 <span
class="math inline">\([\sigma]\)</span> 的第一个分量 <span
class="math inline">\([\sigma]_{1}\)</span> <span
class="math display">\[
\begin{aligned}
\sigma_{11} &amp;= [\sigma]_{1} = L_{11kl} \epsilon_{kl} \\
&amp;= L_{1111} \epsilon_{11} + L_{1122} \epsilon_{22} + L_{1133}
\epsilon_{33} \\
&amp;+ L_{1123} \epsilon_{23} + L_{1113} \epsilon_{13} + L_{1112}
\epsilon_{12} \\
&amp;+ L_{1132} \epsilon_{32} + L_{1131} \epsilon_{31} + L_{1121}
\epsilon_{21}
\end{aligned}
\]</span> 由于 <span class="math inline">\(L\)</span> 和 <span
class="math inline">\(\epsilon\)</span> 张量的次对称性, 我们有 <span
class="math display">\[
L_{1123} \epsilon_{23} = L_{1132} \epsilon_{32}, \quad
L_{1113} \epsilon_{13} = L_{1131} \epsilon_{31}, \quad
L_{1112} \epsilon_{12} = L_{1121} \epsilon_{21}
\]</span> 所以 <span class="math display">\[
\begin{aligned}[]
[\sigma]_{1} &amp;= L_{1111} \epsilon_{11} + L_{1122} \epsilon_{22} +
L_{1133} \epsilon_{33}
+ 2L_{1123} \epsilon_{23} + 2L_{1113} \epsilon_{13} + 2L_{1112}
\epsilon_{12} \\
&amp;= [\mathbb{L}]_{11} [\epsilon]_{1}  + [\mathbb{L}]_{12}
[\epsilon]_{2}  + [\mathbb{L}]_{13} [\epsilon]_{3}
+ 2[\mathbb{L}]_{14} [\epsilon]_{4} + 2[\mathbb{L}]_{15} [\epsilon]_{5}
+ 2[\mathbb{L}]_{16} [\epsilon]_{6}
\end{aligned}
\]</span> 因此在使用 Voigt 记法时, 四阶张量与二阶张量之间的双点积,
如果写成矩阵形式的话, 并不是 <span class="math display">\[
[\sigma] \neq [\mathbb{L}] [\epsilon],
\]</span> 而是 <span class="math display">\[
[\sigma] = [\mathbb{L}] [:] [\epsilon]
\]</span> 式中, <span class="math inline">\([:]\)</span>​ 定义为 6x6
常数矩阵: <span class="math display">\[
[:] := \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2
\end{pmatrix}
\]</span> 在本文中使用四阶和二阶张量的双点积举例,
同样也可以推广到四阶与四阶张量之间, 二阶与二阶张量之间的双点积运算.
例如, 二阶张量之间的点积写成矩阵形式为: <span class="math display">\[
\sigma : \epsilon = [\sigma][:][\epsilon]
\]</span></p>
<p>以及四阶张量之间的双点积运算: <span class="math display">\[
\mathbb{L} : \mathbb{I} = [\mathbb{L}] [:] [\mathbb{I}]
\]</span></p>
<div class="note primary no-icon"><h5 id="例-四阶单位张量的矩阵形式">例: 四阶单位张量的矩阵形式</h5>
<p>对任意的四阶张量, 有 <span class="math display">\[
\mathbb{L} : \mathbb{I} = \mathbb{L}
\]</span> 两边作 Voigt 变换得到 <span class="math display">\[
[\mathbb{L}] [:] [\mathbb{I}] = [\mathbb{L}]
\]</span> 我们选取某个 <span class="math inline">\(\mathbb{L}\)</span>,
使得它在 Voigt 映射为 6x6 单位矩阵 <span
class="math inline">\([I]\)</span>​ <span class="math display">\[
[\mathbb{L}] := [I]
\]</span> 所以 <span class="math display">\[
[:] [\mathbb{I}] = [I]
\]</span> 也即 <span class="math display">\[
[\mathbb{I}] = [:]^{-1} = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0.5 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.5 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.5
\end{pmatrix}
\]</span></p>
</div>
<h3 id="四阶张量求逆">四阶张量求逆</h3>
<p>如果四阶张量 <span class="math inline">\(\mathbb{L}\)</span> <span
class="math inline">\(\mathbb{M}\)</span> 满足 <span
class="math display">\[
\mathbb{L} : \mathbb{M} = \mathbb{M} : \mathbb{L} = \mathbb{I}, \quad
\text{or} \quad
L_{ijkl} M_{klmn} = I_{ijmn}
\]</span> 那么称张量 <span class="math inline">\(\mathbb{M}\)</span>
为张量 <span class="math inline">\(\mathbb{L}\)</span> 的逆: <span
class="math display">\[
\mathbb{L}^{-1} \triangleq \mathbb{M}
\]</span> 在 Voigt 映射下, 有 <span class="math display">\[
[\mathbb{L}] [:] [\mathbb{M}] = [\mathbb{M}] [:] [\mathbb{L}] =
[\mathbb{I}]
\]</span> 所以 <span class="math display">\[
[\mathbb{M}] = [:]^{-1} [\mathbb{L}]^{-1} [\mathbb{I}] = ([:]
[\mathbb{L}] [:])^{-1}
\]</span></p>
<h3 id="张量的单点积运算">张量的单点积运算</h3>
<p>张量的单点积运算很难用 Voigt 记法写成规范的矩阵运算,
因此在这里只给出分量之间的关系. 给定两个二阶张量 <span
class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>
, 单点积运算得到另一个二阶张量 <span class="math inline">\(C\)</span>:
<span class="math display">\[
C_{ik} = A \cdot B = A_{ij} B_{jk}
\]</span> 我们考虑张量分量 <span class="math inline">\(C_{11}\)</span>,
也是 <span class="math inline">\([C]_1\)</span> : <span
class="math display">\[
C_{11} = A_{1j} B_{j1} = A_{11} B_{11} + A_{12} B_{21} + A_{13} B_{31}
\]</span> 再根据张量的对称性, 我们得到 <span class="math display">\[
\begin{aligned}[]
[C]_{1} = [A]_1 [B]_1 + [A]_5 [B]_5 + [A]_6 [B]_6\\
[C]_{2} = [A]_2 [B]_2 + [A]_4 [B]_4 + [A]_6 [B]_6\\
[C]_{3} = [A]_3 [B]_3 + [A]_4 [B]_4 + [A]_5 [B]_5
\end{aligned}
\]</span> 以及 <span class="math display">\[
\begin{aligned}[]
[C]_{4} = [A]_6 [B]_5 + [A]_2 [B]_4 + [A]_4 [B]_3\\
[C]_{5} = [A]_1 [B]_5 + [A]_6 [B]_4 + [A]_5 [B]_3\\
[C]_{6} = [A]_1 [B]_6 + [A]_6 [B]_2 + [A]_5 [B]_4
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>四阶单位张量</tag>
      </tags>
  </entry>
  <entry>
    <title>三节点膜单元列式</title>
    <url>/mech/fem/%E4%B8%89%E8%8A%82%E7%82%B9%E8%86%9C%E5%8D%95%E5%85%83%E6%9C%89%E9%99%90%E5%85%83%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<p>参考文献：[1]TAYLOR R L, OÑATE E, UBACH P A. Finite Element Analysis
of Membrane Structures[M/OL]//OÑATE E, KRÖPLIN B. Textile Composites and
Inflatable Structures: 卷 3. Berlin/Heidelberg: Springer-Verlag, 2005:
47-68[2024-05-24]. http://link.springer.com/10.1007/1-4020-3317-6_4.
DOI:<span class="exturl" data-url="aHR0cHM6Ly9kb2kub3JnLzEwLjEwMDcvMS00MDIwLTMzMTctNl80">10.1007/1-4020-3317-6_4<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="单元的插值函数">单元的插值函数</h2>
<p>考虑三节点的膜单元, 如图所示</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202405241827279.png" alt="image-20240524182715120" style="zoom:50%;" /></p>
<p>在大变形的框架下推导膜单元的运动学表述, 参考构型中的物质点使用 <span
class="math inline">\(\boldsymbol{X}\)</span> 表示,
当前构型中的物质点使用 <span
class="math inline">\(\boldsymbol{x}\)</span> 表示. 物质点 <span
class="math inline">\(\boldsymbol{X}\)</span> 从参考构型中经过位移 <span
class="math inline">\(\boldsymbol{u}\)</span> 运动到点 <span
class="math inline">\(\boldsymbol{x}\)</span>: <span
class="math display">\[
\boldsymbol{x} = \boldsymbol{X} + \boldsymbol{u}
\]</span> 单元内部的点通过节点线性插值得到, 也即 <span
class="math display">\[
\boldsymbol{x} = N^{a} \tilde {\boldsymbol{x}}^a, \quad
\boldsymbol{X} = N^{a} \tilde{\boldsymbol{X}}^a
\]</span> 式中, <span class="math inline">\(N^a\)</span>
为三角形单元节点处的形函数, <span class="math inline">\(\tilde
\square\)</span> 表示节点处的物理量.
上式以及在接下来的陈述中默认对成对的节点指标进行求和, 求和范围为 <span
class="math inline">\(1,2,\ldots,\mathrm{nen}\)</span>. <span
class="math inline">\(\mathrm{nen}\)</span> 为单元节点数,
本文中三节点膜单元 <span class="math inline">\(\mathrm{nen}=3\)</span>.
三角形三节点单元, 在自然坐标系下的形函数为 <span class="math display">\[
N^{1}(\xi_1, \xi_2) = 1 - \xi_1 - \xi_2, \quad
N^{2}(\xi_1, \xi_2) = \xi_1, \quad
N^{3}(\xi_1, \xi_2) = \xi_2
\]</span> 待求解的未知量为变形映射函数 <span
class="math inline">\(\boldsymbol{\varphi}\)</span>: <span
class="math display">\[
\boldsymbol{x} = \boldsymbol{\varphi}(\boldsymbol{X}, t)
\]</span> &gt; [!NOTE] &gt; &gt; 在本文中, <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(\varphi\)</span> 是同一个函数. 一般使用 <span
class="math inline">\(\delta \varphi\)</span> 表示对 <span
class="math inline">\(x\)</span> 的变分.</p>
<h2 id="膜单元的面内坐标系">膜单元的面内坐标系</h2>
<p>上述列式是在一般的三维空间中确定了膜单元的运动过程.
但我们更关心膜单元面内的运动, 所以定义单元的面内坐标系 <span
class="math inline">\(y\)</span> 和 <span
class="math inline">\(Y\)</span>​​. 在引入面内坐标系之前,
需要约定单元的编号顺序与单元法向方向. 使用 ABAQUS 的惯例如下:
编号顺序与单元正法向符合右手螺旋方式:</p>
<figure>
<img
src="http://qiuxiaohuo:4040/English/SIMA3DXRefImages/emembrane-gen-normal-nls.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在此基础之上, 定义面内坐标1 方向单位向量 <span
class="math inline">\(\boldsymbol{m}_1\)</span> 与三角形单元边 <span
class="math inline">\(12\)</span> 重合, 并指向节点 <span
class="math inline">\(2\)</span>: <span class="math display">\[
\boldsymbol{m}_1 \triangleq \frac{ \tilde{\boldsymbol{x}}^{21}}{\|
\tilde{\boldsymbol{x}}^{21} \|}, \quad
\tilde{\boldsymbol{x}}^{ij} \triangleq \tilde{\boldsymbol{x}}^i -
\tilde{\boldsymbol{x}}^j, \quad i,j=1,2,3
\]</span> 单元的法向 <span
class="math inline">\(\boldsymbol{m}_3\)</span> 由边 <span
class="math inline">\(12\)</span>, <span
class="math inline">\(13\)</span> 叉乘得到: <span
class="math display">\[
\boldsymbol{m}_3 \triangleq \frac{ \tilde{\boldsymbol{x}}^{21}
\times  \tilde{\boldsymbol{x}}^{31}}
{\| \tilde{\boldsymbol{x}}^{21} \times \tilde{\boldsymbol{x}}^{31}\|}
\]</span> 边 <span class="math inline">\(12\)</span>, <span
class="math inline">\(13\)</span> 叉乘得到的向量模长为膜单元面积 <span
class="math inline">\(A\)</span> 的 2 倍: <span class="math display">\[
2A \triangleq \| \tilde{\boldsymbol{x}}^{21} \times
\tilde{\boldsymbol{x}}^{31} \|
\]</span> 面内坐标的另一方向 <span
class="math inline">\(\boldsymbol{m}_2\)</span> 可通过 <span
class="math inline">\(\boldsymbol{m}_3\)</span> 与 <span
class="math inline">\(\boldsymbol{m}_1\)</span> 之间叉乘得到 <span
class="math display">\[
\boldsymbol{m}_2 \triangleq \boldsymbol{m}_3 \times \boldsymbol{m}_1
\]</span> 同样的过程可以定义参考构型下的面内坐标系 <span
class="math inline">\(\{\boldsymbol{M}_1, ~\boldsymbol{M}_2, ~
\boldsymbol{M}_3 \}\)</span>.</p>
<h3 id="面内坐标与全局坐标的变换关系">面内坐标与全局坐标的变换关系</h3>
<p>当面内坐标系的原点放在节点 <span class="math inline">\(1\)</span>
处时, 全局坐标 <span class="math inline">\(x\)</span>, <span
class="math inline">\(X\)</span> 到单元面内坐标 <span
class="math inline">\(y\)</span>, <span class="math inline">\(Y\)</span>
的变换关系为 <span class="math display">\[
Y_i = (\boldsymbol{X} - \tilde{\boldsymbol{X}}^1) \cdot \boldsymbol{M}_i
, \quad
y_i = (\boldsymbol{x} - \tilde{\boldsymbol{x}}^1) \cdot \boldsymbol{m}_i
\]</span> 如果定义坐标变换矩阵 <span
class="math inline">\([\mathrm{Q}]\)</span>, <span
class="math inline">\([\mathrm{q}]\)</span> 为 <span
class="math display">\[
[\mathrm{Q}] \triangleq [\mathbf{M}_1, \mathbf{M}_2, \mathbf{M}_3],
\quad
[\mathrm{q}] \triangleq [\mathbf{m}_1, \mathbf{m}_2, \mathbf{m}_3]
\]</span> 式中, <span class="math inline">\(\mathbf{M}_i\)</span>, <span
class="math inline">\(\mathbf{m}_i\)</span>
是在全局坐标系下表示的列向量. 式 (3) 可以改写成如下形式 <span
class="math display">\[
Y_{i} = Q_{mi}(X_m - \tilde{X}_m^1), \quad
y_{i} = q_{mi}(x_m - \tilde{x}_m^1)
\]</span> 因此得到变换公式为</p>
<p><strong>关于坐标的导数变换</strong> <span class="math display">\[
\frac{ \partial ~ }{ \partial Y_i } = Q_{mi} \frac{ \partial ~ }{
\partial X_m }, \quad
\frac{ \partial ~ }{ \partial y_i } = q_{mi} \frac{ \partial ~ }{
\partial x_m }
\]</span> <strong>节点坐标之间的变换</strong> <span
class="math display">\[
\begin{equation}
\tilde Y_i^a =  \tilde{\boldsymbol{X}}^{a1} , \quad
\tilde y_i^a =  \tilde{\boldsymbol{x}}^{a1} \cdot \boldsymbol{m}_i
\quad a = 1,2,3 \quad i = 1,2
\label{eq:coord_transform}
\end{equation}
\]</span> 在新坐标系 <span class="math inline">\(y\)</span> 下,
单元内的点可以表示为 <span class="math display">\[
\boldsymbol{Y} = N^a \tilde{\boldsymbol{Y}}^a, \quad
\boldsymbol{y} = N^a \tilde{\boldsymbol{y}}^a
\]</span> 注意到, 此时节点 <span class="math inline">\(1\)</span>
在坐标系 <span class="math inline">\(y\)</span> 中的坐标为 <span
class="math inline">\((0,0)\)</span>, 所以上式展开为 <span
class="math display">\[
\boldsymbol{Y} = N^2 \tilde{\boldsymbol{Y}}^2 + N^3
\tilde{\boldsymbol{Y}}^3, \quad
\boldsymbol{y} = N^2 \tilde{\boldsymbol{y}}^2 + N^3
\tilde{\boldsymbol{y}}^3
\]</span></p>
<h2 id="应变度量">应变度量</h2>
<p>面内坐标系下的变形梯度定义为 <span class="math display">\[
F_{iI} \triangleq \frac{\partial y_{i}}{\partial Y_{I}}
\]</span> 注意到在面内坐标系下, <span class="math inline">\(y_3, Y_3
\equiv 0\)</span>, 因此上述指标的范围为 <span class="math inline">\(i,I
= 1,2\)</span>.</p>
<blockquote>
<p>[!NOTE]</p>
<p>在全局坐标系下, 变形梯度为 <span class="math display">\[
F_{jJ} \triangleq \frac{\partial x_j}{\partial X_J}, \quad j,J = 1,2,3
\]</span> 在矩阵记法下, <span
class="math inline">\([\mathrm{F}]\)</span> 是 <span
class="math inline">\(3 \times 3\)</span> 的矩阵.
可以通过坐标变换得到面内坐标系下的变形梯度转换关系 <span
class="math display">\[
F_{jJ} = \frac{\partial x_j}{\partial y_i}
\frac{\partial y_i}{\partial Y_I}
\frac{\partial Y_I}{\partial X_J}
= q_{ji} Q_{JI} \frac{\partial y_i}{\partial Y_I}, \quad
j,J = 1,2,3, \quad i,I = 1,2
\]</span></p>
</blockquote>
<p>在自然坐标系下, 变形梯度可以通过链式法则得到 <span
class="math display">\[
F_{iI} = \frac{\partial y_i}{\partial \xi_k} \frac{\partial
\xi_k}{\partial Y_I}
\]</span> 如果记不同构型下对自然坐标的 Jacobian 变换 <span
class="math inline">\(\partial \square / \partial \xi\)</span> 分别为
<span class="math display">\[
j \triangleq \frac{\partial y}{\partial \xi}, \quad
J \triangleq \frac{\partial Y}{\partial \xi}
\]</span> 那么, 变形梯度可写作 <span class="math display">\[
F = j \cdot J^{-1}
\]</span> 对应的右 Cauchy-Green 变形张量为 <span class="math display">\[
\begin{equation}
C \triangleq F^{\top} \cdot F = J^{-\top} \cdot j^{\top} \cdot j \cdot
J^{-1}
\label{eq:C_rep_as_jacobian}
\end{equation}
\]</span> 将上式写作矩阵形式, 并注意到, 对于线性插值的三角形三节点单元,
Jacobian 为常数, 为面内坐标系的节点坐标: <span class="math display">\[
[\mathrm{j}] = \begin{bmatrix}
\tilde y_1^2 &amp; \tilde y_1^3  \\
\tilde y_2^2 &amp; \tilde y_2^3
\end{bmatrix}, \quad
[\mathrm{J}] = \begin{bmatrix}
\tilde Y_1^2 &amp; \tilde Y_1^3  \\
\tilde Y_2^2 &amp; \tilde Y_2^3
\end{bmatrix}
\]</span> 再根据式 <span
class="math inline">\(\ref{eq:coord_transform}\)</span>
给出的节点坐标关系, 可以得到 <span class="math display">\[
[\mathrm{j}] = \begin{bmatrix}
\tilde{\boldsymbol{x}}^{21} \cdot \boldsymbol{m}_1
&amp;  \tilde{\boldsymbol{x}}^{31} \cdot \boldsymbol{m}_1 \\
\tilde{\boldsymbol{x}}^{21} \cdot \boldsymbol{m}_2
&amp;  \tilde{\boldsymbol{x}}^{31} \cdot \boldsymbol{m}_2
\end{bmatrix}
\]</span> 在面内坐标系下, 节点 2 的 <span
class="math inline">\(2\)</span> 方向分量恒等于 0, 因此 Jacobian
矩阵可以进一步简化为 <span class="math display">\[
[\mathrm{j}] = \begin{bmatrix}
\| \tilde{\boldsymbol{x}}^{21} \| &amp; \tilde{\boldsymbol{x}}^{31}
\cdot \boldsymbol{m}_1 \\
0 &amp; \tilde{\boldsymbol{x}}^{31} \cdot \boldsymbol{m}_2
\end{bmatrix}
\]</span> 类似的, 参考构型中的 Jacobian 矩阵可以写作 <span
class="math display">\[
[\mathrm{J}] = \begin{bmatrix}
\| \tilde{\boldsymbol{X}}^{21} \| &amp; \tilde{\boldsymbol{X}}^{31}
\cdot \boldsymbol{M}_1 \\
0 &amp; \tilde{\boldsymbol{X}}^{31} \cdot \boldsymbol{M}_2
\end{bmatrix}
\]</span> 在给出参考构型与当前构型中的 Jacobian 矩阵之后, 就可以将式
<span class="math inline">\(\ref{eq:C_rep_as_jacobian}\)</span> 中的右
Cauchy-Green 变形张量表示为 <span class="math display">\[
C = G^\top g ~G
\]</span> 式中, <span class="math inline">\(G\)</span> 为参考构型
Jacobian 变换的逆, <span class="math inline">\(G \triangleq
J^{-1}\)</span>, <span class="math inline">\(g \triangleq j^\top
j\)</span>. 将它们写成矩阵形式为 <span class="math display">\[
\begin{equation}
[\mathrm{G}]  = \frac{1}{J_{11} J_{22}}
\begin{bmatrix}
J_{22} &amp; -J_{12} \\
0 &amp; J_{11}
\end{bmatrix}, \quad
[\mathrm{g}] = \begin{bmatrix}
j_{11}^2 &amp; j_{11}j_{12} \\
j_{11}j_{12}  &amp; j_{12}^2 + j_{22}^2
\end{bmatrix}
= \begin{bmatrix}
\tilde{\boldsymbol{x}}^{21} \cdot  \tilde{\boldsymbol{x}}^{21}
&amp; \tilde{\boldsymbol{x}}^{21} \cdot  \tilde{\boldsymbol{x}}^{31} \\
\tilde{\boldsymbol{x}}^{21} \cdot  \tilde{\boldsymbol{x}}^{31}
&amp; \tilde{\boldsymbol{x}}^{31} \cdot  \tilde{\boldsymbol{x}}^{31}
\end{bmatrix}
\label{eq:G_and_g}
\end{equation}
\]</span> 所以, 张量 <span class="math inline">\(C\)</span>
最终可以表示为如下矩阵形式 <span class="math display">\[
[\mathrm{C}] = [\mathrm{G}]^\top [\mathrm{g}] [\mathrm{G}]
\]</span></p>
<p>Green 应变定义为 <span class="math display">\[
E \triangleq \frac{1}{2}(C - I)
\]</span></p>
<h2 id="本构方程">本构方程</h2>
<h3 id="st.venant-kirchhoff-材料">St.Venant-Kirchhoff 材料</h3>
<p>使用 St.Venant-Kirchhoff 材料模型, 膜单元上的应力 <span
class="math inline">\(S\)</span> 为 <span class="math display">\[
\begin{equation}
S = \mathbb{L} : E
\label{eq:constitutive}
\end{equation}
\]</span> 式中, <span class="math inline">\(\mathbb{L}\)</span>
为弹性模量.</p>
<h3 id="neo-hookean-材料">Neo-Hookean 材料</h3>
<p>内能密度函数为 <span class="math display">\[
\boxed{
W(\bar{\mathscr{I}}_1, J)
= \frac{1}{2} \mu (\bar{\mathscr{I}}_1 - 3)
+ \frac{1}{2} K (J - 1)^2
}
\]</span></p>
<p>式中, <span class="math inline">\(\mu\)</span> 和 <span
class="math inline">\(K\)</span> 为材料参数,
在小变形的情况下分别对应剪切和 bulk 模量. 对于近不可压缩材料, <span
class="math inline">\(K \gg \mu\)</span>. 其它应变不变量分别为 <span
class="math display">\[
\begin{equation}
\begin{aligned}
\bar{\mathscr{I}}_1 &amp;= \frac{\mathscr{I}_1}{J^{2/3}}, \quad
\mathscr{I}_1 = \mathrm{tr} B \\
\bar{\mathscr{I}}_2 &amp;= \frac{\mathscr{I}_2}{J^{4/3}}, \quad
\mathscr{I}_2 =  \frac{1}{2} \left( (\mathrm{tr}B)^2 - \mathrm{tr}B^2
\right)\\
J &amp;= \det F
\end{aligned}
\label{eq:cons_rep_as_B_inva_3}
\end{equation}
\]</span> 将 <span class="math inline">\(W\)</span>
对不变量的导数带入到式 <span
class="math inline">\(\ref{eq:cons_rep_as_B_inva_3}\)</span> 中得到
<span class="math display">\[
\begin{equation}
\boxed{
\boldsymbol{\sigma}
= \frac{\mu}{J^{5/3}} ~\mathrm{dev}\boldsymbol{B}
+  K(J-1)\boldsymbol{I}, \quad
\mathrm{dev} \boldsymbol{B} = \boldsymbol{B} - \frac{1}{3} \mathscr{I}_1
\boldsymbol{I}
}
\label{eq:neo_hookean_cttt}
\end{equation}
\]</span></p>
<h2 id="控制方程弱形式">控制方程弱形式</h2>
<p>膜单元的控制方程的弱形式由下式给出: <span class="math display">\[
\begin{equation}
\boxed{
\begin{aligned}
\delta \Pi &amp; =
  \int_{S_0} \delta \varphi_i \rho_0 \ddot{\varphi}_i h \mathrm{~d} X
+ \int_{S_0} \delta \varphi_i c_0 \dot{\varphi}_i h \mathrm{~d} X
+ \int_{S_0} \delta E_{I J} S_{I J} h \mathrm{~d} X \\
&amp;- \int_{S} \delta \varphi_i n_i p \mathrm{~d} x
- \int_{\partial S_{t}} \delta \varphi_i \bar{t}_i \mathrm{~d} \sigma(x)
= 0
\end{aligned}
}
\label{eq:weak_form}
\end{equation}
\]</span> 式中, 积分区域 <span class="math inline">\(S\)</span> 和 <span
class="math inline">\(S_0\)</span>
分别指代当前构型和参考构型的膜单元区域. <span
class="math inline">\(h\)</span> 表示膜的厚度, 在本问题中考虑为常数.
<span class="math inline">\(n_i\)</span> 为当前构型下的面法向, <span
class="math inline">\(p\)</span> 为<strong>内</strong>压力. <span
class="math inline">\(\partial S_{t}\)</span> 表示力边界, <span
class="math inline">\(\bar t_i\)</span> 表示施加在力边界上的作用力.
前三项积分在<strong>参考构型</strong>中得到,
后两项积分在<strong>当前构型</strong>中得到.</p>
<p>上式中内力虚功使用的是功共轭的 PK2 应力 <span
class="math inline">\(S_{IJ}\)</span> 和 Green 应变 <span
class="math inline">\(E_{IJ}\)</span>. 对于 Neo-Hookean 材料, 本构关系由
Cauchy 应力和变形梯度给出. 因此使用功共轭的 Kirchhoff 应力 $ _{ij}$ 和
变形率张量 <span class="math inline">\(D_{ij}\)</span>
(在参考构型下积分) 更方便一些: <span class="math display">\[
\begin{equation}
\delta W^{\mathrm{int}} = \int_{S_0} \delta D_{ij} \tau_{ij} ~\mathrm{d}
X
\label{eq:tau-D}
\end{equation}
\]</span></p>
<h3 id="内力虚功">内力虚功</h3>
<h4 id="e---s-共轭对"><span class="math inline">\(E\)</span> - <span
class="math inline">\(S\)</span> 共轭对</h4>
<p>考察积分项 <span class="math inline">\(\delta E_{IJ}S_{IJ}\)</span>,
<span class="math display">\[
\delta E_{IJ} S_{IJ}
= \delta \tilde{\boldsymbol{\varphi}}^a
\cdot \frac{ \partial E_{IJ}}{ \partial \tilde{\boldsymbol{\varphi}}^a}
S_{IJ}
= [\delta \varphi]^{\top} [\mathrm{B}]^{\top} [\mathrm{S}]
\]</span> 将单元上的自由度变量 <span
class="math inline">\(\tilde{\boldsymbol{\varphi}}^a\)</span>
排列为列向量, 对称的 PK2 应力按照 Voigt 记法记作列向量 <span
class="math display">\[
[\delta \varphi]
= \begin{bmatrix}
\delta \tilde{\boldsymbol{\varphi}}^{1} \\
\delta \tilde{\boldsymbol{\varphi}}^{2} \\
\delta \tilde{\boldsymbol{\varphi}}^{3}
\end{bmatrix}_{9 \times 1}, \quad
[\mathrm{S}] = \begin{bmatrix}
S_{11}\\
S_{22}\\
S_{12}
\end{bmatrix}_{3 \times 1}
\]</span> 在定义矩阵 <span class="math inline">\([\mathrm{S}]\)</span>
和 <span class="math inline">\([\delta \varphi]\)</span> 的形式之后,
<span class="math inline">\([\mathrm{B}]\)</span>
矩阵的形式也就唯一确定了: <span class="math display">\[
[\mathrm{B}] = \begin{bmatrix}
\dfrac{ \partial E_{11} }{ \partial \tilde{\boldsymbol{\varphi}}^1 }
&amp;
\dfrac{ \partial E_{11} }{ \partial \tilde{\boldsymbol{\varphi}}^2 }
&amp;
\dfrac{ \partial E_{11} }{ \partial \tilde{\boldsymbol{\varphi}}^3 } \\
\dfrac{ \partial E_{22} }{ \partial \tilde{\boldsymbol{\varphi}}^1 }
&amp;
\dfrac{ \partial E_{22} }{ \partial \tilde{\boldsymbol{\varphi}}^2 }
&amp;
\dfrac{ \partial E_{22} }{ \partial \tilde{\boldsymbol{\varphi}}^3 } \\
2\dfrac{ \partial E_{12} }{ \partial \tilde{\boldsymbol{\varphi}}^1 }
&amp;
2\dfrac{ \partial E_{12} }{ \partial \tilde{\boldsymbol{\varphi}}^2 }
&amp;
2\dfrac{ \partial E_{12} }{ \partial \tilde{\boldsymbol{\varphi}}^3 }
\end{bmatrix}_{3 \times 9}
\]</span> 继续写出 <span class="math inline">\([\mathrm{B}]\)</span>
矩阵分量的具体形式. 因为变分符号只作用在与函数变量 <span
class="math inline">\(\varphi\)</span> 相关的变量上, 所以 <span
class="math display">\[
\delta E_{IJ} S_{IJ} = \frac{1}{2} \delta C_{IJ} S_{IJ} = \frac{1}{2}
\delta g_{ij} G_{iI} G_{jJ} S_{IJ}
\]</span> 若定义应力 <span class="math inline">\(s\)</span> 为 <span
class="math display">\[
s_{ij} \triangleq G_{iI} G_{jJ} S_{IJ}
\]</span> 并将 <span class="math inline">\(s\)</span> 写成如下矩阵形式
<span class="math display">\[
[\mathrm{s}] = \begin{bmatrix}
s_{11}\\
s_{22}\\
s_{12}
\end{bmatrix}
\]</span> 那么, 对应的映射矩阵 <span
class="math inline">\([\mathrm{M}]\)</span> 以及分量为 <span
class="math display">\[
\boxed{
[\mathrm{s}] = [\mathrm{M}]^{\top} [\mathrm{S}], \quad
[\mathrm{M}] = \begin{bmatrix}
1/J_{11}^2 &amp; 0 &amp; 0 \\
1/J_{22}^2 &amp; 1/J_{22}^2 &amp; -J_{12}/J_{11}J_{22}^2 \\
-2J_{12}/J_{11}^2J_{22} &amp; 0 &amp; 1/J_{11}J_{22} \\
\end{bmatrix}
}
\]</span> 将 <span class="math inline">\(\delta g_{ij}\)</span>
排列为列向量的形式: <span class="math display">\[
[\delta g] = \begin{bmatrix} \delta g_{11} \\ \delta g_{22} \\ 2\delta
g_{12} \end{bmatrix}
\]</span> 因此, 功共轭项可以写成如下矩阵形式 <span
class="math display">\[
\delta E_{IJ} S_{IJ} = \frac{1}{2} [\delta g]^{\top} [\mathrm{s}]
\]</span> 对 <span class="math inline">\(g_{ij}\)</span>
的变分转换为对节点位移的变分. 根据式 <span
class="math inline">\(\ref{eq:G_and_g}\)</span>, <span
class="math inline">\(g\)</span> 的分量可以表示为 <span
class="math display">\[
g_{11} = \tilde{\boldsymbol{x}}^{21} \cdot \tilde{\boldsymbol{x}}^{21},
\quad
g_{22} = \tilde{\boldsymbol{x}}^{31} \cdot \tilde{\boldsymbol{x}}^{31},
\quad
g_{12} = g_{21} = \tilde{\boldsymbol{x}}^{21} \cdot
\tilde{\boldsymbol{x}}^{31}
\]</span> 因此, <span class="math display">\[
\begin{equation}
\begin{aligned}
\delta g_{11}
&amp;=  2(\delta \tilde{\boldsymbol{\varphi}}^2 - \delta
\tilde{\boldsymbol{\varphi}}^1) \cdot \tilde{\boldsymbol{x}}^{21}
&amp;= -2\tilde{\boldsymbol{x}}^{21} \cdot \delta
\tilde{\boldsymbol{\varphi}}^1
&amp;+  2\tilde{\boldsymbol{x}}^{21} \cdot \delta
\tilde{\boldsymbol{\varphi}}^2 &amp; \\
\delta g_{22}
&amp;= 2(\delta \tilde{\boldsymbol{\varphi}}^3 - \delta
\tilde{\boldsymbol{\varphi}}^1) \cdot \tilde{\boldsymbol{x}}^{31}
&amp;= -2\tilde{\boldsymbol{x}}^{31} \cdot \delta
\tilde{\boldsymbol{\varphi}}^1  
&amp;&amp;+ 2\tilde{\boldsymbol{x}}^{31} \cdot \delta
\tilde{\boldsymbol{\varphi}}^3 \\
2\delta g_{12}
&amp;= 2(\delta \tilde{\boldsymbol{\varphi}}^2 -
\delta\tilde{\boldsymbol{\varphi}}^1) \cdot \tilde{\boldsymbol{x}}^{31}
+ 2(\delta \tilde{\boldsymbol{\varphi}}^3 - \delta
\tilde{\boldsymbol{\varphi}}^1) \cdot \tilde{\boldsymbol{x}}^{21}
&amp;= -2(\tilde{\boldsymbol{x}}^{21} + \tilde{\boldsymbol{x}}^{31})
\cdot \delta \tilde{\boldsymbol{\varphi}}^1
&amp;+ 2\tilde{\boldsymbol{x}}^{31} \cdot \delta
\tilde{\boldsymbol{\varphi}}^2
&amp;+ 2\tilde{\boldsymbol{x}}^{21} \cdot \delta
\tilde{\boldsymbol{\varphi}}^3
\end{aligned}
\label{eq:variation_g}
\end{equation}
\]</span> 写成矩阵形式 <span class="math display">\[
\boxed{
[\delta g] =
2 \begin{bmatrix}
-\tilde{\boldsymbol{x}}^{21} &amp; \tilde{\boldsymbol{x}}^{21} &amp; 0
\\
-\tilde{\boldsymbol{x}}^{31} &amp; 0                     &amp;
\tilde{\boldsymbol{x}}^{31} \\
-\tilde{\boldsymbol{x}}^{21} - \tilde{\boldsymbol{x}}^{31} &amp;
\tilde{\boldsymbol{x}}^{31} &amp; \tilde{\boldsymbol{x}}^{21}
\end{bmatrix}_{3\times 9}
\begin{bmatrix}
\delta \tilde{\boldsymbol{\varphi}}^{1} \\
\delta \tilde{\boldsymbol{\varphi}}^{2} \\
\delta \tilde{\boldsymbol{\varphi}}^{3}
\end{bmatrix}_{9 \times 1}
\triangleq
2 [\mathrm{b}] [\delta \varphi]
}
\]</span> 式中, <span
class="math inline">\(\tilde{\boldsymbol{x}}^{ab}\)</span> 是行向量.
积分项 <span class="math inline">\(\delta E_{IJ}S_{IJ}\)</span>
写成矩阵形式为 <span class="math display">\[
\delta E_{IJ}S_{IJ}
= [\delta \varphi]^{\top} [\mathrm{b}]^\top [\mathrm{M}]^{\top}
[\mathrm{S}]
\]</span></p>
<p>定义单元上的 <span class="math inline">\([\mathrm{B}]\)</span> 矩阵:
<span class="math display">\[
[\mathrm{B}] = [\mathrm{M}][\mathrm{b}]
\]</span> 最终得到 <span class="math display">\[
\delta E_{IJ}S_{IJ} = [\delta \varphi]^{\top} ~[\mathrm{B}]^\top
[\mathrm{S}]
\]</span> 对于线性插值得到的位移场函数, 膜单元上的应变为常值,
又因为材料本构方程 <span
class="math inline">\(\ref{eq:constitutive}\)</span> 同样是常数,
所以单元上的应力也是常数, 所以, 弱形式 <span
class="math inline">\(\ref{eq:weak_form}\)</span> 中内力虚功项为 <span
class="math display">\[
\begin{equation}
\boxed{
[\mathrm{f}^{\mathrm{int}}] \triangleq h A_0 [\mathrm{B}]^\top
[\mathrm{S}], \quad
\delta W^{\mathrm{int}}
= \int_{S_0} \delta E_{I J} S_{I J} h \mathrm{~d} X
= [\delta \varphi]^{\top} [\mathrm{f}^{\mathrm{int}}]
}
\label{eq:work_int}
\end{equation}
\]</span> 式中, <span class="math inline">\(A_0\)</span>
为参考构型中单元的面积.</p>
<h4 id="d---tau-共轭对"><span class="math inline">\(D\)</span> - <span
class="math inline">\(\tau\)</span> 共轭对</h4>
<p>将插值函数代入到式 <span
class="math inline">\(\ref{eq:tau-D}\)</span> 中得到内力项: <span
class="math display">\[
\begin{equation}
f_{i}^{\mathrm{int},a} = \int_{S_0} \tau_{ij} N_{,I}^a F_{Ij}^{-1}
~\mathrm{d} X
\label{eq:f_int_tau_D}
\end{equation}
\]</span></p>
<h3 id="惯性力和粘力虚功">惯性力和粘力虚功</h3>
<p>式 <span class="math inline">\(\ref{eq:weak_form}\)</span>
中的惯性力虚功为 <span class="math display">\[
\delta W^{\mathrm{kin}} = \int_{S_0} \delta \varphi_i  \rho_0
h  \ddot{\varphi}_i  ~\mathrm{d} X
\]</span> 将插值形函数代入得到 <span class="math display">\[
\delta W^{\mathrm{kin}} =
\delta \varphi_i^a \int_{S_0} \rho_0 h N^a N^b ~\mathrm{d} X
~\ddot{\varphi}_i^b
\triangleq \delta \varphi_i^a M^{ab} \ddot{\varphi}_i^b
\]</span> 因此惯性力虚功写成矩阵形式为 <span class="math display">\[
\begin{equation}
\boxed{
\begin{gathered}
\underbrace{[\mathrm{M}]}_{\rm 3 nen \times 3 nen} = [\mathrm{M}^{ab}],
\quad
\underbrace{[\mathrm{M}^{ab}]}_{3 \times 3}
= 2 h A_0 \int_{\triangle} \rho_0 N^a N^b ~\mathrm{d} \xi
\underbrace{[\mathrm{I}]}_{3 \times 3} \\
\delta W^{\mathrm{kin}}
= [\delta \varphi]^{\top} [\mathrm{M}] [\ddot{\varphi}]
\end{gathered}
}
\label{eq:work_kin}
\end{equation}
\]</span> &gt; [!TIP] &gt; &gt; 如果材料的密度为常数,
那么积分得到单元的质量矩阵为 &gt; <span class="math display">\[
&gt; [\mathrm{M}]_{9 \times 9} = \rho_0 A_0 h \begin{bmatrix}
&gt; \frac{1}{6} \mathrm{I} &amp; \frac{1}{12} \mathrm{I} &amp;
\frac{1}{12} \mathrm{I} \\
&gt; \frac{1}{12} \mathrm{I} &amp; \frac{1}{6} \mathrm{I} &amp;
\frac{1}{12} \mathrm{I} \\
&gt; \frac{1}{12} \mathrm{I} &amp; \frac{1}{12} \mathrm{I} &amp;
\frac{1}{6} \mathrm{I}
&gt; \end{bmatrix}
&gt; \]</span> &gt; 一般使用 lump matrix, 矩阵 <span
class="math inline">\([\mathrm{M}]\)</span> 对角线元素为每一行之和,
其它元素置为 0: &gt; <span class="math display">\[
&gt; [\tilde{\mathrm{M}}]_{9 \times 9} = \frac{\rho_0 A_0 h}{3}
\begin{bmatrix}
&gt; \mathrm{I} &amp;&amp; \\
&gt; &amp; \mathrm{I} &amp; \\
&gt; &amp;&amp; \mathrm{I}
&gt; \end{bmatrix}
&gt; \]</span></p>
<p>类似的, 粘力虚功和粘性矩阵为 <span class="math display">\[
\begin{equation}
\boxed{
\begin{gathered}
\underbrace{[\mathrm{C}]}_{\rm 3 nen \times 3 nen} = [\mathrm{C}^{ab}],
\quad
\underbrace{[\mathrm{C}^{ab}]}_{3 \times 3}
= 2 h A_0 \int_{\triangle} c_0 N^a N^b ~\mathrm{d} \xi
\underbrace{[\mathrm{I}]}_{3 \times 3}\\
\delta W^{\mathrm{vic}} = [\delta \varphi]^{\top} [\mathrm{C}]
[\dot{\varphi}]
\end{gathered}
}
\end{equation}
\]</span></p>
<h3 id="外力虚功">外力虚功</h3>
<p>式 <span class="math inline">\(\ref{eq:weak_form}\)</span>
中的外力虚功项为 <span class="math display">\[
\delta W^{\mathrm{ext}}
= \int_{S} \delta \varphi_i n_i p \mathrm{~d} x
+ \int_{\partial S_{t}} \delta \varphi_i \bar{t}_i \mathrm{~d} \sigma(x)
\]</span> 第一项是作用在膜单元的 SNEG 面压强造成的外力: <span
class="math display">\[
\int_{S} \delta \varphi_i n_i p \mathrm{~d} x
= \delta \boldsymbol{\varphi}^{a} \cdot \int_{S} N^a p \boldsymbol{n}
~\mathrm{d}x
\triangleq [\delta \varphi^{a}]^{\top} [\mathrm{f}_{p}^{a}]
\]</span> 对于三节点膜单元, 单元的法向 <span
class="math inline">\(\boldsymbol{n}\)</span> 在单元内是常数,
因此单元节点上的外力指向与面法向一致. 同时如果假设 <span
class="math inline">\(p\)</span> 也是常数,
那么单元节点上由压力造成的外力相等: <span class="math display">\[
\boldsymbol{f}_{p}^{a} = \frac{1}{3} p A \boldsymbol{n}
\]</span> 式中, <span class="math inline">\(A\)</span>
为变形后的单元面积. 注意到 <span class="math inline">\(A
\boldsymbol{n}\)</span> 可以通过变形后单元边向量叉乘得到: <span
class="math display">\[
\boldsymbol{f}_{p}^{a} = \frac{1}{6} p \tilde{\boldsymbol{x}}^{21}
\times \tilde{\boldsymbol{x}}^{31}
\]</span> 上式中的叉乘也可以写成矩阵的形式, 构造 <span
class="math inline">\(3\times 3\)</span>矩阵 <span
class="math inline">\([\widehat{\tilde{x}^{21}}]\)</span> <span
class="math display">\[
[\widehat{\tilde{x}^{21}}] = \begin{bmatrix}
0 &amp; -\tilde{x}^{21}_3 &amp; \tilde{x}^{21}_2 \\
\tilde{x}^{21}_3 &amp; 0 &amp; -\tilde{x}^{21}_1 \\
\tilde{x}^{21}_3 &amp; -\tilde{x}^{21}_2 &amp; 0
\end{bmatrix}
\]</span> 并将 <span
class="math inline">\(\tilde{\boldsymbol{x}}^{31}\)</span>
写作列向量的形式 <span class="math inline">\([\tilde{x}^{31}]\)</span>,
因此有 <span class="math display">\[
\begin{equation}
\boxed{
\begin{gathered}
\underbrace{[\mathrm{f}^{\mathrm{ext}}]}_{\rm 3 nen \times 1} =
[\mathrm{f}_{p}^{a}], \quad
\underbrace{[\mathrm{f}_{p}^{a}]}_{3 \times 1}
= \frac{1}{6} p [\widehat{\tilde{x}^{21}}] [\tilde{x}^{31}] \\
\delta W^{\mathrm{ext}} = [\delta \varphi]^{\top}
[\mathrm{f}^{\mathrm{ext}}]
\end{gathered}
}
\label{eq:work_ext}
\end{equation}
\]</span></p>
<h3 id="空间离散方程组">空间离散方程组</h3>
<p>在使用形函数对空间离散之后, 结合式 <span
class="math inline">\(\ref{eq:work_int}\)</span> ~ <span
class="math inline">\(\ref{eq:work_ext}\)</span>, 就得到 <span
class="math display">\[
\delta W^{\mathrm{kin}} + \delta W^{\mathrm{vic}}
+ \delta W^{\mathrm{int}} - \delta W^{\mathrm{ext}} = 0, \quad \forall~
\delta \varphi \\
\Rightarrow
[\delta \varphi]^{\top}
\left( [\mathrm{M}] [\ddot{\varphi}]
+ [\mathrm{C}] [\dot{\varphi}]
+ h A_0 [\mathrm{B}]^\top [\mathrm{S}]
- [\mathrm{f}_{p}]
\right)
= 0, \quad \forall ~ [\delta \varphi]
\]</span> 由 <span class="math inline">\([\delta \varphi]\)</span>
在未约束自由度的任意性, 得到关于节点自由自由度处的时域的常微分方程组:
<span class="math display">\[
\begin{equation}
\boxed{
[\mathrm{M}] [\ddot{\varphi}]
+ [\mathrm{C}] [\dot{\varphi}]
+ h A_0 [\mathrm{B}]^\top [\mathrm{S}]
- [\mathrm{f}_{p}] = 0
}
\label{eq:ode}
\end{equation}
\]</span></p>
<h2 id="隐式求解方法">隐式求解方法</h2>
<h3 id="newmark-方法-瞬态问题">Newmark 方法 – 瞬态问题</h3>
<p>对于瞬态问题, 一般使用 Newmark 方法进行求解. 设在 <span
class="math inline">\(t_n\)</span> 时刻的变量 <span
class="math inline">\(\{ \varphi_{n},~ \dot{\varphi}_n, ~
\ddot{\varphi}_n\}\)</span> 已知, 根据中值定理: <span
class="math display">\[
\frac{\dot{\varphi}_{n+1} - \dot{\varphi}_n}{\Delta t} =
\ddot{\varphi}_{n+\xi}, \quad \xi \in [0,1]
\]</span> 假设 <span
class="math inline">\(\ddot{\varphi}_{n+\xi}\)</span> 在 <span
class="math inline">\(\ddot{\varphi}_{n}\)</span> 和 <span
class="math inline">\(\ddot{\varphi}_{n+1}\)</span> 之间变化, 引入参数
<span class="math inline">\(\gamma\)</span>, 对 <span
class="math inline">\(\ddot{\varphi}_{n}\)</span> 和 <span
class="math inline">\(\ddot{\varphi}_{n+1}\)</span> 插值得到 <span
class="math inline">\(\ddot{\varphi}_{n+\xi}\)</span>: <span
class="math display">\[
\dot{\varphi}_{n+1} = \dot{\varphi}_n + \Delta t
\ddot{\varphi}_{\gamma}, \quad
\ddot{\varphi}_{\gamma} = (1 - \gamma) \ddot{\varphi}_{n} + \gamma
\ddot{\varphi}_{n+1}, \quad
\gamma \in [0,1]
\]</span> 确定 <span class="math inline">\(\gamma\)</span>
后就确定了下一时刻的速度更新方程.
下一时刻的位移项通过修正的加速度项得到: <span class="math display">\[
\varphi_{n+1} = \varphi_n + \Delta t \dot{\varphi}_{n} + \frac{1}{2}
\Delta t^2 \ddot{\varphi}_{\beta}, \quad
\ddot{\varphi}_{\beta} = (1 - 2 \beta) \ddot{\varphi}_{n} + 2 \beta
\ddot{\varphi}_{n+1}, \quad
2\beta \in [0,1]
\]</span> 再根据微分方程 <span
class="math inline">\(\ref{eq:ode}\)</span> 在时刻 <span
class="math inline">\(t_{n+1}\)</span> 得到的等式, 就得到关于 <span
class="math inline">\(\{ \varphi_{n+1},~ \dot{\varphi}_{n+1}, ~
\ddot{\varphi}_{n+1}\}\)</span> 的非线性代数方程组: <span
class="math display">\[
\boxed{
\begin{aligned}
M \ddot{\varphi}_{n+1}
&amp;= f^{\mathrm{ext}}(\varphi_{n+1}, t_{n+1})
- f^{\mathrm{int}}(\varphi_{n+1}, t_{n+1}) -C \dot{\varphi}_{n+1}  \\
\dot{\varphi}_{n+1} &amp;= \dot{\varphi}_n
+ (1 - \gamma) \Delta t \ddot{\varphi}_{n}
+ \gamma \Delta t \ddot{\varphi}_{n+1} \\
\varphi_{n+1} &amp;= \varphi_n + \Delta t \dot{\varphi}_{n}
+ (\frac{1}{2} - \beta) \Delta t^2 \ddot{\varphi}_{n} + \beta \Delta t^2
\ddot{\varphi}_{n+1}
\end{aligned}
}
\]</span> 整理得到关于 <span
class="math inline">\(\varphi_{n+1}\)</span> 的非线性方程组: <span
class="math display">\[
\boxed{
\begin{aligned}
K^{\mathrm{nmk}} \varphi_{n+1}
&amp;+ f^{\mathrm{int}}(\varphi_{n+1}, t_{n+1})
- f^{\mathrm{ext}}(\varphi_{n+1}, t_{n+1}) \\
&amp;=
\underbrace{
K^{\mathrm{nmk}} \left(
\varphi_{n} + \Delta t \dot{\varphi}_n
+ (\frac{1}{2} - \beta) \Delta t^2 \ddot{\varphi}_{n}
\right)
-C \left(
\dot{\varphi}_n
+ (1 - \gamma) \Delta t \ddot{\varphi}_{n}
\right)
}_{\triangleq f_n^{\mathrm{nmk}}}
\end{aligned}
}
\]</span> 式中, <span class="math inline">\(K^{\mathrm{nmk}}\)</span>
是根据 Newmark 算法产生的刚度矩阵, 维度和质量矩阵相同; <span
class="math inline">\(f_n^{\mathrm{nmk}}\)</span> 通过时刻 <span
class="math inline">\(t_n\)</span> 的变量 <span class="math inline">\(\{
\varphi_{n},~ \dot{\varphi}_n, ~ \ddot{\varphi}_n\}\)</span> 计算得到.
<span class="math display">\[
\begin{equation}
\boxed{
K^{\mathrm{nmk}} \triangleq \frac{1}{\beta \Delta t } (\frac{1}{\Delta
t} M + \gamma C)
}
\label{eq:stiff_nmk}
\end{equation}
\]</span> 定义 <span class="math inline">\(t_{n+1}\)</span>
时刻的残差函数 <span class="math inline">\(R_{n+1}:
\mathbb{R}^{\mathrm{ndof}} \mapsto \mathbb{R}^{\mathrm{ndof}}\)</span>:
<span class="math display">\[
\begin{equation}
R_{n+1}(\varphi_{n+1} )
\triangleq f^{\mathrm{int}}(\varphi_{n+1}, t_{n+1})
- f^{\mathrm{ext}}(\varphi_{n+1}, t_{n+1})
+  K^{\mathrm{nmk}} \varphi_{n+1}
- f_{n}^{\mathrm{nmk}}
\label{eq:residual}
\end{equation}
\]</span> 式中, <span class="math inline">\(f^{\mathrm{int}}\)</span> 和
<span class="math inline">\(f^{\mathrm{ext}}\)</span>
是方程非线性的来源, 使用 Newton 迭代法进行求解. 设第 <span
class="math inline">\(i\)</span> 步迭代初始值为 <span
class="math inline">\(\varphi_{n+1}^{(i)}\)</span>,
在该位置对残差函数进行 Taylor 展开至一阶项: <span
class="math display">\[
R_{n+1}(\varphi_{n+1})
= R_{n+1}(\varphi_{n+1}^{(i)})
+ \left. \frac{\partial R_{n+1}}{\partial \varphi_{n+1}}
\right|_{\varphi_{n+1}^{(i)}}
\cdot (\varphi_{n+1} - \varphi_{n+1}^{(i)})
\]</span> 记 <span class="math display">\[
\begin{equation}
K_{n+1}^{(i)} \triangleq \left. \frac{\partial R_{n+1}}{\partial
\varphi_{n+1}} \right|_{\Delta \varphi_{n+1}^{(i)}}, \quad
\Delta \varphi_{n+1}^{(i+1)} \triangleq \varphi_{n+1} -
\varphi_{n+1}^{(i)}
\label{eq:derive_of_residual}
\end{equation}
\]</span> 令 Taylor 展开式等于 0, 就得到关于 <span
class="math inline">\(\Delta \varphi_{n+1}^{(i+1)}\)</span>
的线性方程组: <span class="math display">\[
K_{n+1}^{(i)} \Delta \varphi_{n+1}^{(i+1)} =
-R_{n+1}(\varphi_{n+1}^{(i)})
\]</span> 求解上述方程组后, 下一迭代步更新为 <span
class="math display">\[
\varphi_{n+1}^{(i+1)} := \varphi_{n+1}^{(i)} + \Delta
\varphi_{n+1}^{(i+1)}
\]</span></p>
<h3 id="consistent-tangent-matrix">Consistent tangent matrix</h3>
<p>将残差函数表达式 <span
class="math inline">\(\ref{eq:residual}\)</span> 代入到式 <span
class="math inline">\(\ref{eq:derive_of_residual}\)</span> 中得到: <span
class="math display">\[
\frac{\partial R_{n+1}}{\partial \varphi_{n+1}}
= \frac{\partial f^{\mathrm{int}}(\varphi_{n+1}, t_{n+1})}{\partial
\varphi_{n+1}}
- \frac{\partial f^{\mathrm{ext}}(\varphi_{n+1}, t_{n+1})}{\partial
\varphi_{n+1}}
+ K^{\mathrm{nmk}}
\]</span> 由上式可见, 刚度矩阵由 内力 外力 Newmark 算法三部分构成. 其中
<span class="math inline">\(K^\mathrm{nmk}\)</span> 由式 <span
class="math inline">\(\ref{eq:stiff_nmk}\)</span> 给出,
接下来将讨论前两项对刚度矩阵的贡献.</p>
<h4 id="内力刚度">内力刚度</h4>
<h5 id="st.venant-kirchhoff-材料-1">St.Venant-Kirchhoff 材料</h5>
<p>需要刻画函数变量 <span class="math inline">\(\varphi\)</span>
的增量对单元内力的影响. 内力虚功可以写作节点虚位移和内力的点积形式:
<span class="math display">\[
\delta W^{\mathrm{int}}
= \int_{S_0} \delta E_{I J} S_{I J} h \mathrm{~d} S_0
= [\delta \varphi]^{\top} [\mathrm{f}^{\mathrm{int}}]
= \delta \varphi_{i}^{a} f_i^{\mathrm{int},a}
\]</span></p>
<p>对上式关于 <span class="math inline">\(\varphi_{j}^{b}\)</span>
求偏导数得到内力的刚度矩阵 <span class="math display">\[
\frac{ \partial (\delta \varphi_{i}^{a} f_i^{\mathrm{int},a}) }{
\partial \varphi_j^b }
= 0 + \delta \varphi_{i}^{a} K_{ij}^{\mathrm{int},ab}
\]</span></p>
<p>求导与积分交换次序得到, <span class="math display">\[
\begin{equation}
\delta \varphi_{i}^{a} K_{ij}^{\mathrm{int},ab}
= \frac{ \partial ~}{ \partial \varphi_{j}^{b}} \int_{S_0} \delta E_{I
J} S_{I J} h \mathrm{~d} X
= \int_{S_0} \delta  E_{I J} \frac{ \partial S_{I J}}{ \partial
\varphi_{j}^{b}} h \mathrm{~d} X
+ \int_{S_0} \delta  \frac{ \partial E_{I J}}{ \partial \varphi_{j}^{b}}
S_{I J} h \mathrm{~d} X
\label{eq:mem_tg_mat}
\end{equation}
\]</span></p>
<p>式中, 第一项是由材料本构引起的刚度项, 代入材料本构 <span
class="math inline">\(\ref{eq:constitutive}\)</span> <span
class="math display">\[
\int_{S_0} \delta  E_{I J} \frac{ \partial S_{I J}}{ \partial
\varphi_{j}^{b}} h \mathrm{~d} S_0
= \int_{S_0} \delta  E_{I J} L_{IJKL} \frac{ \partial E_{KL}}{ \partial
\varphi_{j}^{b}} h \mathrm{~d} S_0
= [\delta \varphi]^{\top} \cdot
\int_{S_0} [\mathrm{B}]^{\top} [\mathrm{D}] [\mathrm{B}] h ~\mathrm{d} X
\]</span></p>
<p>式中, <span class="math inline">\([\mathrm{D}]\)</span> 是四阶张量
<span class="math inline">\(\mathbb{L}\)</span> 在 Voigt
记法下的矩阵形式. 因此, <span class="math display">\[
\boxed{
[\mathrm{K}^{\mathrm{mat}}] = \int_{S_0} [\mathrm{B}]^{\top}
[\mathrm{D}] [\mathrm{B}] h ~\mathrm{d} X
= h A_0 [\mathrm{B}]^{\top} [\mathrm{D}] [\mathrm{B}]
}
\]</span> 式 <span class="math inline">\(\ref{eq:mem_tg_mat}\)</span>
中的第二项的刚度由几何非线性导致, <span class="math display">\[
\int_{S_0} \delta  \frac{ \partial E_{I J}}{ \partial \varphi_{j}^{b}}
S_{I J} h \mathrm{~d} X
= \frac{1}{2} \int_{S_0} \delta \frac{ \partial g_{ij}}{ \partial
\varphi_{j}^{b}} s_{ij} h \mathrm{~d} X
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp; ~\mathrm{d}\left(\delta g_{11}\right)=2\left(\delta
\tilde{\boldsymbol{\varphi}}^2-\delta
\tilde{\boldsymbol{\varphi}}^1\right)^\top \cdot \left(~\mathrm{d}
\tilde{\boldsymbol{\varphi}}^2-~\mathrm{d}
\tilde{\boldsymbol{\varphi}}^1\right) \\
&amp; ~\mathrm{d}\left(\delta g_{22}\right)=2\left(\delta
\tilde{\boldsymbol{\varphi}}^3-\delta
\tilde{\boldsymbol{\varphi}}^1\right)^\top \cdot \left(~\mathrm{d}
\tilde{\boldsymbol{\varphi}}^3-~\mathrm{d}
\tilde{\boldsymbol{\varphi}}^1\right) \\
&amp; ~\mathrm{d}\left(2\delta g_{12}\right)=2\left(\delta
\tilde{\boldsymbol{\varphi}}^2-\delta
\tilde{\boldsymbol{\varphi}}^1\right)^\top \cdot \left(~\mathrm{d}
\tilde{\boldsymbol{\varphi}}^3-~\mathrm{d}
\tilde{\boldsymbol{\varphi}}^1\right)
+2\left(\delta \tilde{\boldsymbol{\varphi}}^3-\delta
\tilde{\boldsymbol{\varphi}}^1\right)^\top \cdot \left(~\mathrm{d}
\tilde{\boldsymbol{\varphi}}^2-~\mathrm{d}\tilde{\boldsymbol{\varphi}}^1\right)
\end{aligned}
\]</span></p>
<p>因此 $$ <em>{S_0} ~( g</em>{11} ) s_{11} ~ X = []^{} _{[_{11}]} [~ ]
\</p>
<p><em>{S_0} ~( g</em>{22} ) s_{22} ~ X = []^{} _{[_{22}]} [~ ] \</p>
<p><em>{S_0} ~( 2g</em>{12} ) s_{12} ~ X = []^{} _{[_{12}]} [~ ] <span
class="math display">\[
最终得到
\]</span> $$</p>
<h5 id="neo-hookean-材料-1">Neo-Hookean 材料</h5>
<p>式 <span class="math inline">\(\ref{eq:f_int_tau_D}\)</span>
对节点位移微分, 得到刚度矩阵: <span class="math display">\[
~\mathrm{d} f_{i}^{\mathrm{int},a} = K_{ik}^{\mathrm{int},ab}
~\mathrm{d} \varphi_{k}^{b}
\]</span> 微分与积分号交换顺序, 得到 <span class="math display">\[
\begin{equation}
~\mathrm{d} f_{i}^{\mathrm{int},a}
= \underbrace{\int_{S_0} ~\mathrm{d} \tau_{ij} N_{,I}^a F_{Ij}^{-1}
~\mathrm{d} X}_{\triangleq I_1}
+ \underbrace{\int_{S_0} \tau_{ij} N_{,I}^a ~\mathrm{d} F_{Ij}^{-1}
~\mathrm{d} X}_{\triangleq I_2}
\label{eq:neo_hookean_stiff}
\end{equation}
\]</span> 等号右边第一项积分中, 对 Kirchhoff 应力的微分为 <span
class="math display">\[
\mathrm{d} \tau_{ij} = \frac{ \partial \tau_{ij} }{ \partial F_{lL} }
\frac{ \partial F_{lL} }{ \partial \varphi_{k}^{b} } ~\mathrm{d}
\varphi_{k}^{b}
\]</span> 其中, <span class="math display">\[
\frac{ \partial F_{lL} }{ \partial \varphi_{k}^{b} }
= \frac{ \partial \varphi_l^a }{ \partial \varphi_{k}^{b} } N_{,L}^{a}
= \delta_{kl} N_{,L}^{b}
\]</span> 代入积分项中得到 <span class="math display">\[
I_1 = \int_{S_0} \frac{ \partial \tau_{ij} }{ \partial F_{kL} }
N_{,L}^{b} N_{,I}^a F_{Ik}^{-1} ~\mathrm{d} X ~\mathrm{d}
\varphi_{k}^{b}
\]</span> 如果取形函数的微分为关于空间坐标的微分, 那么有 <span
class="math display">\[
N_{,j}^a = N_{,I}^a F_{Ij}^{-1}
\]</span> 定义 <span class="math display">\[
\begin{equation}
C_{ijkl} \triangleq \frac{ \partial \tau_{ij} }{ \partial F_{kL} }
F_{lL}
= J \delta_{kl} \sigma_{ij} + J \frac{ \partial \sigma_{ij} }{ \partial
F_{kL} } F_{lL}
\label{eq:def_C}
\end{equation}
\]</span> 上两式代入 <span class="math inline">\(I_1\)</span> 中得到
<span class="math display">\[
\boxed{
I_1 = \int_{S_0} C_{ijkl}
N_{,l}^{b}  N_{,j}^a  ~\mathrm{d} X ~\mathrm{d} \varphi_{k}^{b}
}
\]</span> 接下来要考虑 <span class="math inline">\(C_{ijkl}\)</span>
定义式 <span class="math inline">\(\ref{eq:def_C}\)</span> 中出现的
<span class="math inline">\({ \partial \sigma_{ij} }/{ \partial F_{kL}
}\)</span> 项. Neo-Hookean 材料应力应变关系式为 <span
class="math display">\[
\sigma_{ij}
= \frac{\mu}{J^{5/3}} \left( B_{ij} - \frac{1}{3} B_{kk} \delta_{ij}
\right)
+  K ( J - 1 ) \delta_{ij}
\]</span> 根据如下导数公式 <span class="math display">\[
\frac{ \partial (F_{iI} F_{jI}) }{ \partial F_{kL} } = \delta_{ik}
F_{jL} + \delta_{jk} F_{iL} \\
\frac{ \partial B_{ii} }{ \partial F_{kL} } = 2 F_{kL} \\
\frac{ \partial J }{ \partial F_{kL} } = J F_{Lk}^{-1}
\]</span> 就得到 <span class="math display">\[
\begin{aligned}
\frac{ \partial \sigma_{ij} }{ \partial F_{kL} }
&amp;= \mu (-\frac{5}{3}) J^{-5/3} F_{Lk}^{-1} \left( B_{ij} -
\frac{1}{3} B_{kk} \delta_{ij} \right) \\
&amp;+ \mu J^{-5/3} \left( \delta_{ik} F_{jL} + \delta_{jk} F_{iL} -
\frac{2}{3} F_{kL} \delta_{ij} \right) \\
&amp;+ K J F_{Lk}^{-1} \delta_{ij}
\end{aligned}
\]</span> 再代入到式 <span class="math inline">\(\ref{eq:def_C}\)</span>
得到 <span class="math display">\[
\begin{equation}
\boxed{
C_{ijkl} = \mu J^{-2/3} \left(
\delta_{ik} B_{jl} + \delta_{jk} B_{il}
- \frac{2}{3} \delta_{ij} B_{kl} - \frac{2}{3} B_{ij} \delta_{kl}
+ \frac{2}{9} B_{kk} \delta_{ij} \delta_{kl}
\right) +  K J ( 2J - 1 ) \delta_{ij} \delta_{kl}
}
\label{eq:fml_C}
\end{equation}
\]</span> 现在来考察积分式 <span class="math inline">\(I_2\)</span>.
<span class="math inline">\(I_2\)</span> 中出现的 <span
class="math inline">\(~\mathrm{d} F_{Ij}^{-1}\)</span> 的微分为 <span
class="math display">\[
~\mathrm{d} \boldsymbol{F}^{-1} = (\boldsymbol{I} + \boldsymbol{F}^{-1}
\cdot \mathrm{d}\boldsymbol{F} )^{-1} \cdot \boldsymbol{F}^{-1}
-\boldsymbol{F}^{-1}
\sim -\boldsymbol{F}^{-1} \cdot \mathrm{d}\boldsymbol{F} \cdot
\boldsymbol{F}^{-1}\quad
\scriptsize{\left( (I + A)^{-1} \sim I - A \right)}
\]</span> 因此有 <span class="math display">\[
~\mathrm{d} F_{Ij}^{-1} = -F_{Ik}^{-1} F_{Jj}^{-1} N_{,J}^b ~\mathrm{d}
\varphi_{k}^{b}
\]</span> 代入到式 <span
class="math inline">\(\ref{eq:neo_hookean_stiff}\)</span> 中积分项 <span
class="math inline">\(I_2\)</span> 有 <span class="math display">\[
\boxed{
I_2 = -\int_{S_0} \tau_{ij} N_{,I}^a N_{,J}^b F_{Ik}^{-1} F_{Jj}^{-1}
~\mathrm{d} X, \quad
\text{或者} \quad
I_2 = -\int_{S_0} \tau_{ij} N_{,k}^a N_{,j}^b ~\mathrm{d} X
}
\]</span></p>
<h4 id="载荷刚度">载荷刚度</h4>
<p><span class="math display">\[
\begin{align*}
~\mathrm{d} \boldsymbol{f}_{p}^{a}
&amp;= \frac{1}{6} p \left(
~\mathrm{d}\tilde{\boldsymbol{x}}^{21} \times
\tilde{\boldsymbol{x}}^{31}
+ \tilde{\boldsymbol{x}}^{21} \times
~\mathrm{d}\tilde{\boldsymbol{x}}^{31}
\right) \\
&amp;= \frac{1}{6} p \left(
( \tilde{\boldsymbol{x}}^{31} - \tilde{\boldsymbol{x}}^{21}) \times
\mathrm{d}\tilde{\boldsymbol{x}}^{1}
- \tilde{\boldsymbol{x}}^{31} \times
~\mathrm{d}\tilde{\boldsymbol{x}}^{2}
+ \tilde{\boldsymbol{x}}^{21} \times
~\mathrm{d}\tilde{\boldsymbol{x}}^{3}
\right) \\
&amp;= \frac{1}{6}p
\begin{bmatrix}
[\widehat{\tilde{x}^{31}}] - [\widehat{\tilde{x}^{21}}] &amp;
- [\widehat{\tilde{x}^{31}}] &amp;
[\widehat{\tilde{x}^{21}}]
\end{bmatrix}_{3 \times 9} [~\mathrm{d} \varphi]
\end{align*}
\]</span></p>
<p>所以载荷刚度矩阵为 <span class="math display">\[
\boxed{
\mathrm{K}^{\mathrm{ext}}
= \begin{bmatrix}
[\widehat{\tilde{x}^{31}}] - [\widehat{\tilde{x}^{21}}] &amp;
- [\widehat{\tilde{x}^{31}}] &amp;
[\widehat{\tilde{x}^{21}}] \\
[\widehat{\tilde{x}^{31}}] - [\widehat{\tilde{x}^{21}}] &amp;
- [\widehat{\tilde{x}^{31}}] &amp;
[\widehat{\tilde{x}^{21}}] \\
[\widehat{\tilde{x}^{31}}] - [\widehat{\tilde{x}^{21}}] &amp;
- [\widehat{\tilde{x}^{31}}] &amp;
[\widehat{\tilde{x}^{21}}] \\
\end{bmatrix}
}
\]</span></p>
<h3 id="准稳态问题">准稳态问题</h3>
<p>膜结构一般在初始阶段没有刚度, 因此即使对于准静态问题,
也应添加人为的阻尼项稳定计算, 在速率项足够小的情况下再切换到稳态计算.
稳态计算需要保留方程 <span class="math inline">\(\ref{eq:ode}\)</span>
中的阻尼项: <span class="math display">\[
[\mathrm{C}] [\dot{\varphi}]
+ h A_0 [\mathrm{B}]^\top [\mathrm{S}]
- [\mathrm{f}] = 0
\]</span> 并使用向后欧拉方法进行求解: <span class="math display">\[
\varphi_{n+1} = \varphi_{n} + \Delta t \dot{\varphi}_{n+1}
\]</span> 这对应 Newmark 方法中 <span class="math inline">\(\beta =
\gamma\)</span>.</p>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>膜单元</tag>
      </tags>
  </entry>
  <entry>
    <title>完全拉格朗日形式的矩阵列式</title>
    <url>/mech/fem/%E5%AE%8C%E5%85%A8%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%BD%A2%E5%BC%8F%E7%9A%84%E7%9F%A9%E9%98%B5%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<p>完全拉格朗日形式的弱形式可以解释为虚功原理,
也即<strong>内力虚功等于惯性力和外力虚功</strong>: <span
class="math display">\[
\delta w^{\mathrm{int}} = \delta w^{\mathrm{kin}} + \delta
w^{\mathrm{ext}}
\tag{1}
\]</span> 使用形函数将待求解的变量 <span
class="math inline">\(\varphi(X,t)\)</span> 的空间维度进行离散得到 <span
class="math display">\[
\varphi_i^{h}(X,t) = N^a(X) \varphi_{i}^{a}(t)
\]</span> 式中, 指标 <span class="math inline">\(i\)</span>
表示拉格朗日描述下的空间指标, 指标 <span
class="math inline">\(a\)</span> 表示节点编号指标, 并默会 Einstein
求和约定. 在完全拉格朗日形式下, 节点内力, 节点外力,
和单元质量矩阵分别在空间维度上离散为 <span class="math display">\[
M_{ij}^{ab} \triangleq \delta_{ij}\int_{B_0} \rho_0 N^{a} N^{b}
~\mathrm{d} X, \\
f_{i}^{a,\mathrm{int}} \triangleq \int_{B_0} P_{iJ} \frac{ \partial
N^a}{ \partial X_J}
~\mathrm{d} X, \\
f_{i}^{a,\mathrm{ext}} \triangleq \int_{B_0} \rho_0 b_{i} N^a
~\mathrm{d} X
+ \int_{\partial B_0^t} \overline{T}_i N^a ~\mathrm{d} \Sigma(X)
\tag{2}
\]</span> 式中, <span class="math inline">\(\rho_0(X)\)</span>
为参考构型的材料密度; <span class="math inline">\(P_{IJ}\)</span> 为 PK1
应力, <span class="math inline">\(P \triangleq J \sigma \cdot
F^{-\top}\)</span>; <span class="math inline">\(b_i(X)\)</span>
为体积力; <span class="math inline">\(\overline{T}_{i}(X)\)</span>
为力边界条件上指定的面力; <span class="math inline">\(N^a\)</span>
为形函数. 上式中出现的积分是对物质坐标 <span
class="math inline">\(X\)</span> 的积分,
因此积分域为参考构型或参考构型的边界. 在式 (2) 的定义下, 虚功原理 (1)
可以表示为 <span class="math display">\[
\delta \varphi_{i}^{a} (M_{ij}^{ab} \ddot{\varphi}_{j}^{b}
+ f_{i}^{a,\mathrm{int}}
- f_{i}^{a,\mathrm{ext}})
= 0
\]</span> 对任意可允许的节点虚位移 <span class="math inline">\(\delta
\varphi_{i}^{a}\)</span> 成立, 所以得到在 <span
class="math inline">\((a,i)\)</span> 自由的方程组 <span
class="math display">\[
M_{ij}^{ab} \ddot{\varphi}_{j}^{b}
+ f_{i}^{a,\mathrm{int}}
- f_{i}^{a,\mathrm{ext}}
= 0
\]</span></p>
<hr />
<p>式 (1) 中的虚功项可以拆解成各个单元上的积分, 以内力虚功为例: <span
class="math display">\[
\delta w^{\mathrm{int}} = \delta \varphi_{i}^{a} \sum_{e}\int_{B_0^e}
P_{iJ} \frac{ \partial N^a}{ \partial X_J}
~\mathrm{d} X
\tag{3}
\]</span> 如果定义单元内力为 <span class="math display">\[
(f_{i}^{a,\mathrm{int}})^{e} \triangleq \int_{B_0^e} P_{iJ} \frac{
\partial N^a}{ \partial X_J}
~\mathrm{d} X
\]</span> 那么式 (3) 可以重新写作 <span class="math display">\[
\delta w^{\mathrm{int}} = \delta \varphi_{i}^{a}
\sum_{e}(f_{i}^{a,\mathrm{int}})^{e}
\]</span> 由于有限元插值函数的局部性,
单元内力只会和所属于该单元的节点处做功,
在其它节点处的虚位移不会对虚功做出贡献. 因此,
内力虚功可以分解为单元内力虚功之和: <span class="math display">\[
\delta w^{\mathrm{int}} = \sum_{e}\delta \varphi_{i}^{a,e}
(f_{i}^{a,\mathrm{int}})^{e}
= \sum_{e} \delta w^{\mathrm{int},e}
\]</span> 上式说明, 单元上的虚功列式在形式上与系统的虚功列式完全相同.
因此总是可以在单元上计算得到单元的内力,外力, 质量矩阵, 再通过 “gather” -
“scatter” 数据操作组装得到系统的内力, 外力和质量矩阵. 在之后的叙述中,
我们总是默认式 (2) 的运算在单元上进行, 不再加上标 <span
class="math inline">\(e\)</span>.</p>
<hr />
<h3 id="定义的标量值">定义的标量值</h3>
<table>
<thead>
<tr class="header">
<th>变量名</th>
<th>变量说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>nedim</code></td>
<td>参数坐标维数</td>
</tr>
<tr class="even">
<td><code>nsdim</code></td>
<td>空间维数</td>
</tr>
<tr class="odd">
<td><code>nndof</code></td>
<td>节点自由度数</td>
</tr>
<tr class="even">
<td><code>nen</code></td>
<td>单元节点数</td>
</tr>
<tr class="odd">
<td><code>nedof</code></td>
<td>单元自由度数, <code>nedof = nndof * nen</code></td>
</tr>
</tbody>
</table>
<p>在实现中, <span class="math inline">\(\varphi_I^a\)</span>
经常被排列成列向量的形式: <span class="math display">\[
[\varphi] \triangleq [\varphi^{1}; \varphi^{2}; \ldots;
\varphi^{\mathrm{nen}}]
\]</span> 上式中的列向量长度为 <code>nedof*nn</code>. 引入自由度指标
<span class="math inline">\(\alpha: (a,i) \mapsto \alpha\)</span>,
并定义形函数矩阵 <span
class="math inline">\([\mathrm{N}]_{I\overline{a}}\)</span>:
<code>nndof</code> x <code>nndof</code> <span class="math display">\[
[\mathrm{N}]_{I \alpha} = [N^{1} \mathrm{I}, N^{2} \mathrm{I}, \ldots,
N^{\mathrm{nn}} \mathrm{I}]
\]</span> 式中, <span class="math inline">\(\mathrm{I}\)</span> 是维度为
<code>nndof</code> 的单位矩阵, 因此, 被插值的变量可以写成如下矩阵形式
<span class="math display">\[
[\varphi^{h}] = [\mathrm{N}] [\varphi]
\]</span> 或者按照指标记法 <span class="math display">\[
\varphi_{I}^{h} = N_{I \alpha} \varphi_{\alpha}
\]</span> 使用这种指标记法, 式 (2) 可以改写为 <span
class="math display">\[
M_{\alpha \beta} = \int_{B_0} \rho_0 N_{i \alpha}  N_{i
\beta}  ~\mathrm{d} X, \\
f_{\alpha}^{\mathrm{int}} = \int_{B_0} P_{iJ} \frac{ \partial N_{i
\alpha} }{ \partial X_J}
~\mathrm{d} X, \\
f_{\alpha}^{\mathrm{ext}} = \int_{B_0} \rho_0 b_{i} N_{i
\alpha}  ~\mathrm{d} X
+ \int_{\partial B_0^t} \overline{T}_i N_{i \alpha}  ~\mathrm{d}
\Sigma(X)
\tag{2&#39;}
\]</span></p>
<hr />
<h2 id="b-矩阵">B 矩阵</h2>
<p>内力 <span class="math inline">\(F_{\alpha}^{\mathrm{int}}\)</span>
在写成向量形式时, 因为式中 PK1 应力 <span
class="math inline">\(P_{iJ}\)</span> 是不对称的, 所以没有办法将应力张量
<span class="math inline">\(P\)</span> 按照 Voigt 记法压缩成一列.
在这里我们将 PK1 转换为对称的 PK2 应力, 并且用式 (2) 的形式表示形函数
<span class="math display">\[
f_{i}^{a,\mathrm{int}} \triangleq \int_{B_0} F_{iI} S_{IJ} \frac{
\partial N^a}{ \partial X_J}
~\mathrm{d} X
\]</span> 定义 B 矩阵为 <span class="math display">\[
B_{(I,J)(a,i)} \triangleq \frac{ \partial x_i}{ \partial X_I} \frac{
\partial N^a}{ \partial X_J}
\]</span> 式中, <span class="math inline">\((a,i)\)</span>
通过自由度编号映射压缩为 B 矩阵列的索引 <span
class="math inline">\(\alpha\)</span>, <span
class="math inline">\((I,J)\)</span> 通过 Voigt 映射压缩为 B
矩阵行的索引 <span class="math inline">\(I&#39;\)</span>. 固定节点 <span
class="math inline">\(a\)</span>, 得到 B 矩阵的子矩阵 <span
class="math inline">\([\mathrm{B}^{a}]\)</span>, 由此 B 矩阵可以写作
<span class="math display">\[
[\mathrm{B}] = [[\mathrm{B}^{1}], [\mathrm{B}^{2}], \ldots,
[\mathrm{B}^{\mathrm{nnd}}]]
\]</span> 单元内力写成矩阵形式为 <span class="math display">\[
[f^{\mathrm{int}}] = \int_{B_0} [\mathrm{B}]^{\top} [\mathrm{S}]
\]</span> <span class="math inline">\([S]\)</span> 是按照 Voigt
排布的列向量.</p>
<p>二维情景下, 矩阵 <span
class="math inline">\([\mathrm{B}^{a}]\)</span> 的维度为 <code>3</code>
x <code>2</code>, 三维情景下的维度为 <code>6</code> x <code>3</code>.
对应 B 矩阵的维度分别为 <code>3</code> x <code>nedof</code> 和
<code>6</code> x <code>nedof</code>. B 矩阵的展开式为 <span
class="math display">\[
[\mathrm{B}^{a}] = \left[\begin{array}{cc}
\frac{\partial N^a}{\partial X} \frac{\partial x}{\partial X} &amp;
\frac{\partial N^a}{\partial X} \frac{\partial y}{\partial X} \\
\frac{\partial N^a}{\partial Y} \frac{\partial x}{\partial Y} &amp;
\frac{\partial N^a}{\partial Y} \frac{\partial y}{\partial Y} \\
\frac{\partial N^a}{\partial X} \frac{\partial x}{\partial
Y}+\frac{\partial N^a}{\partial Y} \frac{\partial x}{\partial X} &amp;
\frac{\partial N^a}{\partial X} \frac{\partial y}{\partial
Y}+\frac{\partial N^a}{\partial Y} \frac{\partial y}{\partial X}
\end{array}\right]
\]</span></p>
<p>以及三维情景: <span class="math display">\[
[\mathrm{B}^{a}] = \left[\begin{array}{ccc}
\frac{\partial N^a}{\partial X} \frac{\partial x}{\partial X} &amp;
\frac{\partial N^a}{\partial X} \frac{\partial y}{\partial X} &amp;
\frac{\partial N^a}{\partial X} \frac{\partial z}{\partial X} \\
\frac{\partial N^a}{\partial Y} \frac{\partial x}{\partial Y} &amp;
\frac{\partial N^a}{\partial Y} \frac{\partial y}{\partial Y} &amp;
\frac{\partial N^a}{\partial Y} \frac{\partial z}{\partial Y} \\
\frac{\partial N^a}{\partial Z} \frac{\partial x}{\partial Z} &amp;
\frac{\partial N^a}{\partial Z} \frac{\partial y}{\partial Z} &amp;
\frac{\partial N^a}{\partial Z} \frac{\partial z}{\partial Z} \\
\frac{\partial N^a}{\partial Y} \frac{\partial x}{\partial
Z}+\frac{\partial N^a}{\partial Z} \frac{\partial x}{\partial Y} &amp;
\frac{\partial N^a}{\partial Y} \frac{\partial y}{\partial
Z}+\frac{\partial N^a}{\partial Z} \frac{\partial y}{\partial Y} &amp;
\frac{\partial N^a}{\partial Y} \frac{\partial z}{\partial
Z}+\frac{\partial N^a}{\partial Z} \frac{\partial z}{\partial Y} \\
\frac{\partial N^a}{\partial X} \frac{\partial x}{\partial
Z}+\frac{\partial N^a}{\partial Z} \frac{\partial x}{\partial X} &amp;
\frac{\partial N^a}{\partial X} \frac{\partial y}{\partial
Z}+\frac{\partial N^a}{\partial Z} \frac{\partial y}{\partial X} &amp;
\frac{\partial N^a}{\partial X} \frac{\partial z}{\partial
Z}+\frac{\partial N^a}{\partial Z} \frac{\partial z}{\partial X} \\
\frac{\partial N^a}{\partial X} \frac{\partial x}{\partial
Y}+\frac{\partial N^a}{\partial Y} \frac{\partial x}{\partial X} &amp;
\frac{\partial N^a}{\partial X} \frac{\partial y}{\partial
Y}+\frac{\partial N^a}{\partial Y} \frac{\partial y}{\partial X} &amp;
\frac{\partial N^a}{\partial X} \frac{\partial z}{\partial
Y}+\frac{\partial N^a}{\partial Y} \frac{\partial z}{\partial X}
\end{array}\right]
\]</span></p>
<p>系统中的格林应变可通过 B 矩阵得到 <span class="math display">\[
[\dot{\mathrm{E}}] = [\mathrm{B}] [\dot{\varphi}]
\]</span></p>
<h2 id="单元坐标系">单元坐标系</h2>
<p>式 (2) 的积分是在参考构型的单元上进行, 可以通过积分换元,
将单元上的积分转换到同一个标准形状的单元上进行. 如果用 <span
class="math inline">\(\xi\)</span> 表示单元坐标,
那么微元之间的映射关系为 <span class="math display">\[
~\mathrm{d} X = \frac{ \partial X }{ \partial \xi } \cdot \mathrm{d} \xi
\triangleq F_{\xi}^{0} \cdot \mathrm{d} \xi
\]</span> 因此式 (2) 转换为 <span class="math display">\[
M_{\alpha \beta} = \int_{\square} \rho_0 N_{I \alpha}  N_{I \beta}
F_{\xi}^{0} ~\mathrm{d} \xi, \\
F_{\alpha}^{\mathrm{int}} = \int_{\square} S_{IJ} \frac{ \partial N_{I
\alpha} }{ \partial \xi_K}
\left( \frac{ \partial X_K }{ \partial \xi_J } \right)^{-1}
~\mathrm{d} \xi, \\
F_{\alpha}^{\mathrm{ext}} = \int_{\square} \rho_0 f_{I} N_{I \alpha}
F_{\xi}^{0}  ~\mathrm{d} \xi
+ \int_{\partial \Omega_0^t} \overline{T}_I N_{I \alpha}  ~\mathrm{d}
S_0
\tag{2&#39;}
\]</span></p>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>完全拉格朗日</tag>
      </tags>
  </entry>
  <entry>
    <title>几何单元的矩阵列式</title>
    <url>/mech/fem/%E5%87%A0%E4%BD%95%E5%8D%95%E5%85%83%E7%9A%84%E7%9F%A9%E9%98%B5%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="notation">Notation</h2>
<p>在确定单元的几何类型, 并已知单元的节点坐标之后,
理应可以得到关于该单元的任何几何信息, 比如单元内部积分点的全局坐标,
形函数的取值, 形函数偏导数的取值等等.
这些在转化为代码中实际的矩阵计算时,
需要约定矩阵的行列分别对应的指标类型.
接下来将建立公式与实际计算中矩阵列式之间一一对应的关系.</p>
<p>在进行公式推导和变量定义之前, 有必要首先声明文中用到的 Notation:</p>
<ul>
<li>使用 <span class="math inline">\(i,j,k,\ldots\)</span>
表示空间和参数指标, 一般放在下标位置</li>
<li>使用 <span class="math inline">\(a, b,c,\ldots\)</span>
表示单元节点的指标, 一般放在上标位置</li>
<li>如无特别说明, 均默认指标使用 Einstein 求和约定</li>
<li>公式字体 <span class="math inline">\(varible\)</span>
表示一般的公式推导; 字体 <span
class="math inline">\(\mathrm{matrix}\)</span> 表示对应变量的矩阵形式,
并一般使用方括号 <span class="math inline">\([\cdot]\)</span> 包围.
<span class="math inline">\([\cdot]_{ij}\)</span> 表示矩阵分量</li>
<li>按照 MATLAB 惯例, <span class="math inline">\([1 ~ 2 ~ 3]\)</span>
或 <span class="math inline">\([1,2,3]\)</span> 表示行向量; <span
class="math inline">\([1;2;3]\)</span> 表示列向量</li>
</ul>
<h3 id="定义的标量值">定义的标量值</h3>
<table>
<thead>
<tr class="header">
<th>变量名</th>
<th>变量说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>nedim</code></td>
<td>参数坐标维数</td>
</tr>
<tr class="even">
<td><code>nsdim</code></td>
<td>空间维数</td>
</tr>
<tr class="odd">
<td><code>nndof</code></td>
<td>节点自由度数</td>
</tr>
<tr class="even">
<td><code>nen</code></td>
<td>单元节点数</td>
</tr>
<tr class="odd">
<td><code>nedof</code></td>
<td>单元自由度数, <code>nedof = nndof * nen</code></td>
</tr>
</tbody>
</table>
<h3 id="定义的向量与矩阵值">定义的向量与矩阵值</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 26%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>变量名</th>
<th>变量维度</th>
<th>变量说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>x</code></td>
<td><code>1</code> x <code>nsdim</code></td>
<td>全局坐标</td>
</tr>
<tr class="even">
<td><code>x'</code></td>
<td><code>1</code> x <code>nsdim</code></td>
<td>单元坐标</td>
</tr>
<tr class="odd">
<td><code>N</code></td>
<td><code>1</code> x <code>nen</code></td>
<td>形函数在给定某一参数坐标下的取值</td>
</tr>
<tr class="even">
<td><code>encrd</code></td>
<td><code>nen</code> x <code>nsdim</code></td>
<td>单元节点在全局坐标系下的坐标</td>
</tr>
<tr class="odd">
<td><code>encrd_ecsys</code></td>
<td><code>nen</code> x <code>nsdim</code></td>
<td>单元节点在单元坐标系下的坐标</td>
</tr>
<tr class="even">
<td><code>Q</code></td>
<td><code>nsdim</code> x <code>nsdim</code></td>
<td>坐标变换矩阵</td>
</tr>
<tr class="odd">
<td><code>J</code></td>
<td><code>nsdim</code> x <code>nedim</code></td>
<td>全局坐标系下的 Jacobian 矩阵</td>
</tr>
<tr class="even">
<td><code>J'</code></td>
<td><code>nsdim</code> x <code>nedim</code></td>
<td>单元坐标系下的 Jacobian 矩阵</td>
</tr>
<tr class="odd">
<td><code>J''</code></td>
<td><code>nedim</code> x <code>nedim</code></td>
<td>去除零行后的 Jacobian 矩阵 (方阵)</td>
</tr>
<tr class="even">
<td><code>dNdxi</code></td>
<td><code>nen</code> x <code>nedim</code></td>
<td>形函数对参数坐标的偏导数</td>
</tr>
<tr class="odd">
<td><code>dNdx</code></td>
<td><code>nen</code> x <code>nsdim</code></td>
<td>形函数对全局坐标的偏导数</td>
</tr>
<tr class="even">
<td><code>dNdx'</code></td>
<td><code>nen</code> x <code>nedim</code></td>
<td>形函数对单元坐标的偏导数</td>
</tr>
<tr class="odd">
<td><code>epsilon</code></td>
<td><code>[3|4|6]</code> x <code>1</code></td>
<td>积分点处的应变</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td><code>nedof</code> x <code>1</code></td>
<td>单元自由度变量</td>
</tr>
</tbody>
</table>
<h5 id="参数坐标得到全局坐标">参数坐标得到全局坐标</h5>
<p>给定单元的某一参数坐标 <span class="math inline">\(\xi \in
\mathbb{R}^{\rm nedim}\)</span> 后, 该点的全局坐标 <span
class="math inline">\(x \in \mathbb{R}^{\rm nsdim}\)</span> 为: <span
class="math display">\[
x(\xi) = x^a N^a(\xi)
\tag{1}
\]</span> 其变量关系为 <span class="math display">\[
\boxed{
\mathrm{ [x] = [N] [encrd]}
}
\]</span></p>
<h5 id="jacobian">Jacobian</h5>
<p>Jacobian 可以看作是参数坐标系中的微元 <span
class="math inline">\(\mathrm{d} \xi\)</span> 到全局坐标系中的微元 <span
class="math inline">\(\mathrm{d} x\)</span> 的仿射变换 <span
class="math display">\[
\mathrm{d} x = J \cdot \mathrm{d} \xi
\]</span> 写成分量形式为 <span class="math display">\[
\mathrm{d} x_i = \frac{\partial x_i}{\partial \xi_j} \mathrm{d} \xi_j
\]</span> 记 Jacobian 的矩阵形式为 <span class="math display">\[
[\mathrm{J}]_{ij} = \frac{\partial x_i}{\partial \xi_j}
\]</span> 当使用式 (1) 表示的映射关系时, Jacobian
矩阵可以表示为形函数关于参数坐标导数的线性组合: <span
class="math display">\[
[\mathrm{J}]_{ij} = x_i^a \frac{\partial N^{a}}{\partial \xi_j}
\]</span> 将形函数关于参数坐标的导数组成的矩阵记作变量
<code>dNdXi</code>, Jacobian 矩阵就可以表示为 <span
class="math display">\[
\boxed{
[\mathrm{J}] = \rm [encrd]^{\top} [dNdxi]
}
\tag{2}
\]</span></p>
<h5 id="partial-n-partial-x-矩阵"><span class="math inline">\(\partial N
/ \partial x\)</span> 矩阵</h5>
<p>对于某一点处形函数对 <span class="math inline">\(x\)</span> 的偏导数,
可以通过链式法则获得: <span class="math display">\[
\frac{\partial N^{a}}{\partial x_i}
= \frac{\partial N^{a}}{\partial \xi_j} \frac{\partial \xi_j}{\partial
x_i}
\]</span> 上式中, 当单元类型确定之后, 形函数关于参数坐标 <span
class="math inline">\(\xi\)</span> 的导数就是已知并有解析表达式的,
但是参数坐标关于全局坐标的函数表示, 并不总是那么方便地得到. 但庆幸地是,
我们只需要知道某一点上的取值, 而这可以通过反函数定理很快地得到: <span
class="math display">\[
\left.\frac{\partial x_i}{\partial \xi_k}\right|_{\xi}
\left.\frac{\partial \xi_k}{\partial x_j}\right|_{x} = \delta_{ij}
\]</span> 当 <code>nsdim</code> = <code>nedim</code> 时, 可以通过
Jacobian 逆矩阵得到 <span class="math display">\[
\boxed{
\mathrm{[dNdx] = [dNdxi]} [J]^{-1}
}
\]</span> 当 <code>nsdim</code> &gt; <code>nedim</code> 时
(空间维度总是大于或等于单元维度), 建立单元坐标系 <span
class="math inline">\(\{e_1, e_2, e_3\}\)</span> 为</p>
<ol type="1">
<li>二维单元: <span class="math inline">\(e_3\)</span>
垂直于单元所在平面, <span class="math inline">\(e_1\)</span> 平行于边
<span class="math inline">\(1-2\)</span> 并指向节点 <span
class="math inline">\(2\)</span>, <span class="math inline">\(e_2 = e_3
\times e_1\)</span> ;</li>
<li>一维单元: <span class="math inline">\(e_1\)</span> 从节点 <span
class="math inline">\(1\)</span> 指向节点 <span
class="math inline">\(2\)</span>, 其它基矢量与 <span
class="math inline">\(e_1\)</span> 满足右手坐标系关系.</li>
</ol>
<p>如果记 <span class="math inline">\(\{e_1, e_2, e_3\}\)</span>
在旧坐标系下的坐标矩阵为 <span class="math display">\[
[Q] \triangleq [e_1 ~ e_2 ~ e_3]
\]</span> 那么, 新旧坐标之间的变换关系为 <span class="math display">\[
[x] = [x&#39;] [Q]^{\top} , \quad
[x&#39;] = [x] [Q]
\]</span> 节点在新坐标系下坐标为 <span
class="math inline">\(x&#39;^{a}\)</span>, 并且单元内所有点的坐标分量
<span class="math inline">\(x&#39;_i\)</span> ( 二维单元 <span
class="math inline">\(i=3\)</span>, 一维单元 <span
class="math inline">\(i=2,3\)</span> ) 为常数.
如果记变换后的单元的节点坐标变量为 <code>encrd_ecsys</code>, 那么与变量
<code>encrd</code> 之间的关系为 <span class="math display">\[
\boxed{
\rm [encrd\_ecsys] = [encrd] [Q]
}
\tag{3}
\]</span> 在新坐标系下, 用形函数表示为参数坐标的映射关系为 <span
class="math display">\[
x&#39; = x&#39;^a N^a(\xi)
\]</span> 式中的形函数形式上与未变换之前的形函数是一致的,
因此微元之间的关系同样为 <span class="math display">\[
\mathrm{d} x&#39; = J&#39; \cdot \mathrm{d} \xi
\]</span> 式中, <span class="math inline">\(J&#39;\)</span>
为新坐标系下的 Jacobian, 类似于式 (2) <span class="math display">\[
[\mathrm{J}&#39;] = \rm [encrd\_ecsys]^{\top} [dNdxi]
\]</span> 再根据坐标变换关系 (3), 就得到不同坐标系下 Jacobian 之间的关系
<span class="math display">\[
\boxed{
[\mathrm{J}&#39;] = \rm [Q]^{\top} [encrd]^{\top} [dNdxi] = [Q]^{\top}
[J]
}
\]</span></p>
<p>矩阵 <span class="math inline">\([J&#39;]\)</span> 大于
<code>nedim</code> 的行元素全部等于 0. 去除零行之后得到 <span
class="math inline">\([J&#39;&#39;]\)</span>: <code>nedim</code> x
<code>nedim</code>, 得到在新坐标系下的形函数偏导数为: <span
class="math display">\[
\mathrm{[dNdx&#39;] = [dNdxi]} [J&#39;&#39;]^{-1}
\]</span> 如果希望得到关于旧坐标系的偏导数值, 那么根据坐标变换关系:
<span class="math display">\[
\frac{\partial ~~}{\partial x_{\beta}}
= \frac{\partial ~~}{\partial x&#39;_{i}} \frac{\partial
x&#39;_{i}}{\partial x_{\beta}}
= Q_{\beta i} \frac{\partial ~~}{\partial x&#39;_{i}}
\]</span> 需要强调的是上式中指标的范围. <span
class="math inline">\(\beta\)</span> 是旧坐标系下的指标, 因此范围为
<span class="math inline">\(1,2,3\)</span>. <span
class="math inline">\(i\)</span> 是新坐标系下的指标, 在新坐标系下, <span
class="math inline">\(i\)</span> 的范围是 <span
class="math inline">\(1,2\)</span> (二维单元) 或 <span
class="math inline">\(1\)</span> (一维单元). 写成矩阵的形式为 <span
class="math display">\[
\boxed{
\rm [dNdx] = [dNdx&#39;] [Q(0,0,nsdim,nedim)]^{\top}
}
\]</span></p>
<p>六节点单元, 形函数没有问题, 积分点上每次计算得到的应变增量没有问题,
应力计算应该也是没有问题的, 但是在线性第二次迭代时, 得不到正确结果?
这是为什么?</p>
<p>问题应该出现在
<code>src\PField\FElement\FSolid2D\FElemSld2D.cpp</code> 中的迭代过程.
需要再想想</p>
<p>应该不是迭代方法的问题, 还是第一次迭代步中最后的位移计算出错了</p>
<h2 id="b-矩阵">B 矩阵</h2>
<p><span class="math inline">\(B\)</span>
矩阵的形式与应变向量的排布相关. 在小位移假设下, 应变总是关于位移对 <span
class="math inline">\(x\)</span> 偏导数的<strong>线性组合</strong>,
也即关于 <span class="math inline">\(\partial N / \partial x\)</span>
的线性组合: <span class="math display">\[
\varepsilon_{ij} = \frac{1}{2}(u_{i,j} + u_{j,i})
\]</span> 对位移使用形函数进行插值, 得到 <span class="math display">\[
u_{i}(x) = u_{i}^{a} N^{a}(x)
\tag{4}
\]</span> 式中, <span class="math inline">\(u_{i}^{a}\)</span>
为节点上的位移分量, 为待求解的未知量. 将上式代入到小应变的表达式当中得到
<span class="math display">\[
\varepsilon_{ij}
= \frac{1}{2}(u_{i}^{a} \frac{\partial N^{a}}{\partial x_j}
+ u_{j}^{a} \frac{\partial N^{a}}{\partial x_i})
\tag{5}
\]</span> 将上式写成矩阵形式, 得到 <span class="math display">\[
\boxed{
\rm [epsilon] = [B] [d]
}
\]</span> 接下来我们将阐述上式中变量具体的排布方式. 对于变量 <span
class="math inline">\(\rm [epsilon]\)</span>, 我们使用 Voigt 记法,
将应变存储为向量形式: <span class="math display">\[
[\mathrm{epsilon}] = [\varepsilon_{11}; ~ \varepsilon_{22}; ~
2\varepsilon_{12}] \quad \text{二维情景} \\
[\mathrm{epsilon}] = [\varepsilon_{11}; ~ \varepsilon_{22}; ~
\varepsilon_{33};
~ 2\varepsilon_{23}; ~ 2\varepsilon_{13}; ~ 2\varepsilon_{12}]  \quad
\text{三维情景}
\]</span> 对于变量 <span class="math inline">\([d]\)</span>, 设节点
<span class="math inline">\(a\)</span> 上自由度变量排布为 <span
class="math display">\[
[\mathrm{u}^a] = [u_1^a ; ~ u_2^a ; ~ \cdots u_{\mathrm{nndof}}^a]
\]</span> 单元自由度向量通过 <span
class="math inline">\([u^{a}]\)</span> 进行组装 <span
class="math display">\[
\rm [d] = [u^1 ; u^2 ; \cdots ; u^{nen}]
\]</span> 在定义单元自由度向量和应变向量之后, 式 (5)
中将之联系起来的矩阵 <span class="math inline">\(B\)</span>
就唯一确定了. 我们首先使用定义的单元自由度向量表示式 (4) 中的 <span
class="math inline">\(u(x)\)</span> <span class="math display">\[
[\mathrm{u}](x) = N^{a}(x) [\mathrm{u}^a]
= [N^{1}(x)[\mathrm{I}] , N^2(x)[\mathrm{I}], \ldots ,
N^{\mathrm{nen}}(x)[\mathrm{I}]] [\mathrm{d}]
\]</span> 式中, <span class="math inline">\([\mathrm{I}]\)</span> 为维度
<code>nndof</code> 的单位阵. 定义算子矩阵 <span class="math display">\[
[\mathrm{D}]
= \begin{bmatrix}
\frac{\partial }{\partial x_1} &amp; \\
&amp; \frac{\partial }{\partial x_2} \\
\frac{\partial }{\partial x_2} &amp; \frac{\partial }{\partial x_1}
\end{bmatrix} (\text{二维情景}), \quad
\begin{bmatrix}
\frac{\partial }{\partial x_1} &amp; &amp; \\
&amp; \frac{\partial }{\partial x_2} &amp; \\
&amp; &amp; \frac{\partial }{\partial x_3} \\
&amp; \frac{\partial }{\partial x_3} &amp; \frac{\partial }{\partial
x_2} \\
\frac{\partial }{\partial x_3} &amp; &amp; \frac{\partial }{\partial
x_1} \\
\frac{\partial }{\partial x_2} &amp; \frac{\partial }{\partial x_1}
&amp;
\end{bmatrix} (\text{三维情景})
\]</span> 由此应变可以表示为 <span class="math display">\[
[\mathrm{epsilon}] = [\mathrm{D}] [\mathrm{u}](x)
= [\mathrm{D}] [N^{1}(x)[\mathrm{I}] , N^2(x)[\mathrm{I}], \ldots ,
N^{\mathrm{nen}}(x)[\mathrm{I}]] [\mathrm{d}]
\]</span> 如果定义 <span class="math display">\[
[\mathrm{D}] N^{a}(x) = [\mathrm{B}^{a}]
\]</span> 那么 <span class="math display">\[
[\mathrm{B}] = [\mathrm{D}] [N^{1}(x)[I] , N^2(x)[I], \ldots ,
N^{\mathrm{nen}}(x)[I]]
= [\mathrm{B}^1, \mathrm{B}^2, \ldots, \mathrm{B}^{\mathrm{nen}}]
\]</span></p>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>形函数</tag>
        <tag>B 矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>平面单元的积分方法</title>
    <url>/mech/fem/%E5%B9%B3%E9%9D%A2%E5%8D%95%E5%85%83%E7%9A%84%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>使用下标 <span class="math inline">\(i,j,k\)</span>
表示空间维度的指标; 使用上标 <span class="math inline">\(a\)</span>
表示单元节点的指标; 使用上标 <span class="math inline">\(i\)</span>
表示单元积分点的指标</p>
<h2 id="三角形单元">三角形单元</h2>
<p>高阶三角形单元的形函数</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202407250951870.png" alt="image-20240725095112642" style="zoom:50%;" /></p>
<p>一阶的三角形单元形函数为 <span class="math display">\[
N^1 = L_1, \quad N^2 = L_2, \quad N^3 = L_3
\]</span> 三角形单元随着阶次增加,
其所覆盖的完备的多项式阶数也恰好逐次增加, 不会像四边形单元,
增加节点数也会增加不完备的多项式项. 更高阶的三角形单元形函数可以通过
Lagrange 函数进行构造, 其构造方法为 <span class="math display">\[
N^{a} = l_{I}^{I}(L_1) l_{J}^{J}(L_2) l_{K}^{K}(L_3)
\]</span> 式中, <span class="math inline">\(I+J+K = M\)</span>, <span
class="math inline">\(M\)</span> 为三角形单元的阶数. <span
class="math inline">\(l_{k}^{n}(\xi)\)</span> 为 Lagrange 函数, 定义为
<span class="math display">\[
l_{k}^{n}(\xi) \triangleq
\frac{(\xi - \xi_0)(\xi - \xi_1) \cdots (\xi - \xi_{k-1})(\xi -
\xi_{k+1}) \cdots (\xi - \xi_n)}
{(\xi_k - \xi_0)(\xi_k - \xi_1) \cdots (\xi_k - \xi_{k-1})(\xi_k -
\xi_{k+1}) \cdots (\xi_k - \xi_n)}
\]</span> 如此构造的 <span class="math inline">\(N^a\)</span> 是满足性质
<span class="math inline">\(N^a(L^{b}) = \delta_{ab}\)</span> 的.
对于节点 <span class="math inline">\(a\)</span>, <span
class="math display">\[
l_{I}^{I}(L_1^a)=1,\quad l_{J}^{J}(L_2^a)=1,\quad  l_{K}^{K}(L_3^a)=1
\]</span> 对于其它节点 <span class="math inline">\(a&#39;\)</span>,
其索引为 <span class="math inline">\((I&#39;, J&#39;, K&#39;)\)</span>,
总存在一个索引分量 (不妨选取 <span
class="math inline">\(I&#39;\)</span>), 使得 <span
class="math inline">\(I&#39; &lt; I\)</span>, 这样就得到 <span
class="math display">\[
l_{I}^{I}(L_1^{a&#39;}) = 0 \Rightarrow N^a(L^{a&#39;}) = 0
\]</span> 对于二阶单元, 备选的 Lagrange 函数为 <span
class="math display">\[
l_0^0(\xi) = 1, \quad
l_1^1(\xi) = 2\xi, ~\{0,~\frac{1}{2}\}, \quad
l_2^2(\xi) = \xi(2\xi-1), ~\{0,~\frac{1}{2},~1\}
\]</span> 花括号中是 Lagrange 函数的插值点. 因此,
二阶三角形单元的形函数为</p>
<p>角点处的节点: <span class="math display">\[
N^a = L_a (2L_a - 1), \quad a=1,2,3
\]</span> 边上的节点: <span class="math display">\[
N^4 = 4 L_1 L_2, \quad
N^5 = 4 L_2 L_3, \quad
N^S6 = 4 L_3 L_1
\]</span></p>
<p>三角形单元内的坐标可以使用面积坐标进行表示 <span
class="math display">\[
x(L_1, L_2, L_3) = x_1 L_1 + x_2 L_2 + x_3 L_3 \\
y(L_1, L_2, L_3) = y_1 L_1 + y_2 L_2 + y_3 L_3
\]</span> 式中, <span class="math inline">\((x_i, y_i)\)</span>
是三角形节点在笛卡尔全局坐标系下的坐标, 面积坐标 <span
class="math inline">\(L_i\)</span> 在 <span
class="math inline">\([0,1]\)</span> 内变化, 并满足如下关系: <span
class="math display">\[
L_{i}(x^a, y^a) = \delta_{ia}, \quad \sum_{i} L_i = 1
\]</span> 在有限元中, 需要计算单元 <span
class="math inline">\(\Omega^e\)</span> 上形如 <span
class="math display">\[
I = \iint_{\Omega^e} f(x,y) ~\mathrm{d}x \mathrm{d}y
\]</span> 的积分, 而面积坐标提供了一种坐标变换的方式,
使得在任意形状三角形区域的积分可以转化到标准区域进行.
这对数值积分非常友好, 因为 Gauss
型数值积分的精度通常是在标准区域上进行衡量的. 进行积分变换,
第一步是要计算 Jacobian 矩阵, 衡量微元之间的仿射变换关系: <span
class="math display">\[
\begin{pmatrix} \mathrm{d}x \\ \mathrm{d}y \end{pmatrix}
= \frac{\partial (x,y)}{\partial(L_1,L_2)}
\begin{pmatrix} \mathrm{d}L_1 \\ \mathrm{d}L_2 \end{pmatrix}
\]</span> 对于实体单元, 微元之间的系数为 Jacobian 矩阵的行列式值: <span
class="math display">\[
\mathrm{d}x \mathrm{d}y = \det \frac{\partial (x,y)}{\partial(L_1,L_2)}
\mathrm{d}L_1 \mathrm{d}L_2
\]</span> 对于三节点三角形单元. 行列式值为常值, 等于 2 倍的单元面积:
<span class="math display">\[
J \triangleq \det \frac{\partial (x,y)}{\partial(L_1,L_2)} =
2S_{\Omega^e}
\]</span> 经过坐标变换, 就得到原积分 <span
class="math inline">\(I\)</span> 为 <span class="math display">\[
I = J \iint_{\triangle} \tilde f(L_1, L_2) ~\mathrm{d}L_1 \mathrm{d}L_2
\tag{1}
\]</span> 式中, <span class="math inline">\(\triangle\)</span>
表示标准单元区域, 在文中设置的面积坐标下, <span
class="math inline">\(\triangle\)</span> 为 <span
class="math inline">\((0,0)\)</span> <span
class="math inline">\((1,0)\)</span> <span
class="math inline">\((0,1)\)</span> 三节点连线围成的直角三角形区域.
在标准区域 <span class="math inline">\(\triangle\)</span> 中,
考虑如下积分:</p>
<p><span class="math display">\[
\iint_{\triangle} \tilde f(L_1, L_2) ~\mathrm{d}L_1 \mathrm{d}L_2
\]</span> 数值积分将积分近似为单元区域某些点的取值和权重的乘积,
并进行求和: <span class="math display">\[
\iint_{\triangle} \tilde f(L_1, L_2) ~\mathrm{d}L_1 \mathrm{d}L_2
\approx \sum_i \tilde f(\xi^i) w^i
\]</span> 为了方便验证求积公式的代数精度,
给出多项式函数在标准区域的积分解析公式: <span class="math display">\[
\iint_{\triangle} L_1^a L_2^b L_3^c ~\mathrm{d}L_1 \mathrm{d}L_2
= \frac{a!b!c!}{(a+b+c+2)!}
\]</span> 一种常用的三角形区域的数值积分方式为 Hammer 积分,
这里列举选用一个积分点和三个积分点的情景. 只选取一个积分点时 <span
class="math display">\[
\xi^{1} = (\frac{1}{3}, \frac{1}{3}), \quad w^{1}   = \frac{1}{2}
\]</span> 可以验证, 这种求积公式是满足一阶代数精度的. 选取三个积分点时,
有两种可能: 第一种求积公式为 <span class="math display">\[
\xi^{1} = (0, \frac{1}{2}), \quad
\xi^{2} = (\frac{1}{2}, 0), \quad  
\xi^{3} = (\frac{1}{2}, \frac{1}{2}) \\
w^{1} = w^{2} = w^{3} = \frac{1}{6}
\]</span>
<img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202407240954792.png" alt="image-20240724095409555" style="zoom:67%;" /></p>
<p>第二种求积公式为</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202407240956427.png" alt="image-20240724095518257" style="zoom:67%;" /></p>
<p>现在将标准区域的求积公式代入到原积分公式 (1) 当中得到 <span
class="math display">\[
I \approx J \sum_i \tilde f(\xi^i) w^i
\]</span> 令 <span class="math inline">\(\widetilde{w}^i \triangleq J
w^i\)</span>, 就得到 <span class="math display">\[
I \approx \sum_i \tilde f(\xi^i) \widetilde{w}^i
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<p>一些教材 (Zienkiewicz) 在处理三角形单元的数值积分时, 将 Jacobian
行列式写成 2 倍的三角形面积, 并将系数 2 并入权重当中: <span
class="math display">\[
I \approx S_{\Omega^e} \sum_i \tilde f(\xi^i) \hat{w}^i, \quad \hat{w}^i
= 2 w^i
\]</span> 由此得到的一阶 Hammer 积分: <span class="math display">\[
\xi^{1} = (\frac{1}{3}, \frac{1}{3}), \quad w^{1} = 1
\]</span> 和二阶 Hammer 积分 <span class="math display">\[
\xi^{1} = (0, \frac{1}{2}), \quad
\xi^{2} = (\frac{1}{2}, 0), \quad  
\xi^{3} = (\frac{1}{2}, \frac{1}{2}) \\
w^{1} = w^{2} = w^{3} = \frac{1}{3}
\]</span></p>
</blockquote>
<h2 id="四边形单元">四边形单元</h2>
<p>对于四边形四节点单元, 使用的形函数为 <span class="math display">\[
N^{I}(\xi, \eta) = \frac{1}{4} (1 + \xi^I \xi) (1 + \eta^I \eta)
\]</span> 式中, <span class="math inline">\((\xi^I, \eta^I)\)</span>
为节点 <span class="math inline">\(I\)</span> 的参数坐标. 等参变换为
<span class="math display">\[
x(\xi, \eta) = \sum_{I=1}^{4} x^I N^{I}(\xi, \eta), \quad
y(\xi, \eta) = \sum_{I=1}^{4} y^I N^{I}(\xi, \eta)
\]</span> 将积分转换到参数坐标区域中, 对应的 Jacobian 为 <span
class="math display">\[
J(\xi, \eta) = \frac{1}{4}  \begin{bmatrix}
\sum\limits_{I=1}^{4} x^I \xi^I (1 + \eta^I \eta)
&amp; \sum\limits_{I=1}^{4} x^I \eta^I (1 + \xi^I \xi) \\
\sum\limits_{I=1}^{4} y^I \xi^I (1 + \eta^I \eta)
&amp; \sum\limits_{I=1}^{4} y^I \eta^I (1 + \xi^I \xi)
\end{bmatrix}
\]</span> 因此, 对于原积分为 <span class="math display">\[
I = \iint_{\Omega^e} f(x,y) ~\mathrm{d}x \mathrm{d}y
\]</span> 将积分区域转换到参数坐标区域, 得到 <span
class="math display">\[
I = \int_{ -1}^{1}\int_{-1}^{ 1}
\tilde f(\xi, \eta) J(\xi, \eta) ~\mathrm{d}\xi \mathrm{d}\eta
\]</span> 对上述乘积区域的积分 (<span class="math inline">\((-1,1)
\times (-1,1)\)</span>), 可以使用 Gauss 积分方式进行计算. 首先,
一维情景下, 在区间 <span class="math inline">\((-1,1)\)</span> 上的
Gauss 积分列式为 <span class="math display">\[
\int_{-1}^{1} f(\xi) ~\mathrm{d}\xi \approx \sum_{i=1}^{N_{\rm ipt}}
w^{i} f(\xi^{i})
\]</span> 式中, <span class="math inline">\(N_{\rm ipt}\)</span>
是积分点的数量. 常用的 Gauss 积分点和权重如下表所示</p>
<p><img src="./../../../../AppData/Roaming/Typora/typora-user-images/image-20240802125731311.png" alt="image-20240802125731311" style="zoom:67%;" /></p>
<p>在给出一维情景的 Gauss 积分列式之后,
二维或更高维的情景可以通过一维的例子方便地得到. 对于维度为 <span
class="math inline">\(N_{\rm d}\)</span> 的情景, 在乘积空间 <span
class="math inline">\(\Pi(-1,1)\)</span> 中, Gauss 积分的列式为 <span
class="math display">\[
\int_{\scriptsize \Pi(-1,1)} f(\xi_1, \xi_{2}, \ldots, \xi_{N^{\rm d}})
\mathrm{d} \xi
\approx \underbrace{\sum_{i=1}^{N_{\rm ipt}} \sum_{j=1}^{N_{\rm ipt}}
\cdots \sum_{k=1}^{N_{\rm ipt}}}_{N^{\rm d}}
f(\xi_1^i, \xi_{2}^j, \ldots, \xi_{N^{\rm d}}^k)
\underbrace{w^{i} w^{j} \cdots w^{k}}_{N^{\rm d}}
\]</span> 例如, 二维情景的 Gauss 积分为 <span class="math display">\[
I = \int_{ -1}^{1}\int_{-1}^{ 1}
\tilde f(\xi, \eta) J(\xi, \eta)  ~\mathrm{d}\xi \mathrm{d}\eta
\approx \sum_{i=1}^{N_{\rm ipt}} \sum_{j=1}^{N_{\rm ipt}}
\tilde f(\xi^{i}, \eta^{j}) J(\xi^{i}, \eta^{j}) w^i w^{j}
\]</span> 当 <span class="math inline">\(N_{\rm ipt} = 1\)</span> 时,
积分公式为 <span class="math display">\[
I \approx 4\tilde f(0, 0) J(0, 0)
\]</span></p>
<blockquote>
<p>[!NOTE]</p>
<p>四边形单元 Jacobian 在参数坐标点 <span
class="math inline">\((0,0)\)</span> 取值为 <span
class="math display">\[
J(0,0) = \frac{1}{4}S_{\Omega^e}
\]</span></p>
</blockquote>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>数值积分</tag>
        <tag>平面单元</tag>
      </tags>
  </entry>
  <entry>
    <title>壳单元列式</title>
    <url>/mech/fem/%E5%A3%B3%E5%8D%95%E5%85%83%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="壳体插值函数">壳体插值函数</h3>
<p>三维空间中壳单元的插值函数为 <span class="math display">\[
\boldsymbol{x}(\xi, \eta, \zeta) = \overline{\boldsymbol{x}}(\xi, \eta)
+ \boldsymbol{X}(\xi, \eta, \zeta) \\
\overline{\boldsymbol{x}}(\xi, \eta) = \sum_{a}^{\mathrm{nen}}N^{a}(\xi,
\eta) \overline{\boldsymbol{x}}^a \\
\boldsymbol{X}(\xi, \eta, \zeta) = \sum_{a}^{\mathrm{nen}} N^{a}(\xi,
\eta) \boldsymbol{X}^a(\zeta) \\
\boldsymbol{X}^a(\zeta) = z^{a}(\zeta) \hat{\boldsymbol{X}}^a
\quad(\text{不求和})\\
z^a(\zeta) = N_{+}(\zeta) z_{+}^{a} + N_{-}(\zeta) z_{-}^{a} \\
N_{+}(\zeta) = \frac{1}{2}(1 + \zeta), \quad N_{-}(\zeta) =
\frac{1}{2}(1 - \zeta)
\tag{1}
\]</span> 式中, <span
class="math inline">\(\overline{\boldsymbol{x}}\)</span>
为壳单元中参考面中的点; <span
class="math inline">\(\boldsymbol{X}\)</span> 是参考平面中指向 “纤维”
方向的向量, <span class="math inline">\(\hat{\boldsymbol{X}}^a\)</span>
是节点处纤维法向量 (注意, 纤维方向并不一定垂直于参考平面); <span
class="math inline">\(z_a\)</span> 是厚度方程. 壳单元需要输入的参数为
<span class="math display">\[
\boxed{
\overline{\boldsymbol{x}}^a, \quad \hat{\boldsymbol{X}}^a, \quad
z_{+}^{a}, \quad z_{-}^{a}
}
\tag{2}
\]</span></p>
<ul>
<li>纤维: 固定坐标 <span class="math inline">\((\xi, \eta)\)</span>
得到的关于 <span class="math inline">\(\zeta\)</span> 的参数曲线;</li>
<li>lamina: 固定坐标 <span class="math inline">\(\zeta\)</span>
得到的关于 <span class="math inline">\((\xi, \eta)\)</span>
的参数曲面</li>
</ul>
<p>壳单元的另一类参数: 如果给出节点纤维的上下端点 <span
class="math inline">\(\boldsymbol{x}_{+}^a\)</span>, <span
class="math inline">\(\boldsymbol{x}_{-}^a\)</span>,
以及参考面对应的参数 <span
class="math inline">\(\overline{\zeta}\)</span>, 那么由此得到式 (2)
所需要的参数为 <span class="math display">\[
\overline{\boldsymbol{x}}^a = \frac{1}{2}(1 + \overline{\zeta})
\boldsymbol{x}_{+}^a
+ \frac{1}{2}(1 - \overline{\zeta}) \boldsymbol{x}_{-}^a \\
\hat{\boldsymbol{X}}^a = \frac{\boldsymbol{x}_{+}^a -
\boldsymbol{x}_{-}^a}
{\| \boldsymbol{x}_{+}^a - \boldsymbol{x}_{-}^a \|} \\
\quad z_{+}^{a} = \frac{1}{2}(1 - \overline{\zeta}) \|
\boldsymbol{x}_{+}^a - \boldsymbol{x}_{-}^a \| \\
\quad z_{-}^{a} = -\frac{1}{2}(1 + \overline{\zeta}) \|
\boldsymbol{x}_{+}^a - \boldsymbol{x}_{-}^a \|
\]</span></p>
<h3 id="壳单元坐标系">壳单元坐标系</h3>
<h4 id="单元积分点处-lamina-坐标系">单元积分点处 Lamina 坐标系</h4>
<p>定义在单元积分点上的笛卡尔坐标系 <span class="math inline">\(\{
\boldsymbol{e}_1^l, ~\boldsymbol{e}_2^l, ~\boldsymbol{e}_3^l
\}\)</span>, 其中 <span
class="math inline">\(\boldsymbol{e}_3^l\)</span> 垂直于过该点的 Lamina.
该坐标系需要进行构造. 首先根据单元的插值函数得到: <span
class="math display">\[
\boldsymbol{e}_{\xi} =
\frac{\boldsymbol{x}_{,\xi}}{\|\boldsymbol{x}_{,\xi}\|}, \quad
\boldsymbol{e}_{\eta} =
\frac{\boldsymbol{x}_{,\eta}}{\|\boldsymbol{x}_{,\eta}\|}
\]</span> 这两个单位向量不一定相互垂直, 但是切于 Lamina. 因此 <span
class="math inline">\(e_{3}^l\)</span> 可通过这两个向量叉乘得到 <span
class="math display">\[
\boldsymbol{e}_{3}^{l}\triangleq \frac{\boldsymbol{e}_{\xi} \times
\boldsymbol{e}_{\eta}}
{\| \boldsymbol{e}_{\xi} \times \boldsymbol{e}_{\eta} \|}
\]</span> <span class="math inline">\(\boldsymbol{e}_\xi\)</span>, <span
class="math inline">\(\boldsymbol{e}_\eta\)</span> 的角平分单位向量为
<span class="math display">\[
\boldsymbol{e}_{\alpha} = \frac{\boldsymbol{e}_\xi +
\boldsymbol{e}_\eta}
{\|\boldsymbol{e}_\xi + \boldsymbol{e}_\eta\|}, \quad
\boldsymbol{e}_{\beta} = \frac{\boldsymbol{e}_3^l \times
\boldsymbol{e}_\alpha}
{\|\boldsymbol{e}_3^l \times \boldsymbol{e}_\alpha\|}
\]</span> 绕 <span class="math inline">\(\boldsymbol{e}_3^l\)</span>
顺时针旋转 <span class="math inline">\(45\deg\)</span> 得到 <span
class="math display">\[
\boldsymbol{e}_1^l = \frac{\sqrt{2}}{2} (\boldsymbol{e}_{\alpha} -
\boldsymbol{e}_{\beta}), \quad
\boldsymbol{e}_2^l = \frac{\sqrt{2}}{2} (\boldsymbol{e}_{\alpha} +
\boldsymbol{e}_{\beta})
\]</span></p>
<h4 id="节点处-fiber-direction-坐标系">节点处 fiber direction
坐标系</h4>
<p>节点处坐标系要求 <span
class="math inline">\(\boldsymbol{e}_3^f\)</span> 与 <span
class="math inline">\(\hat{\boldsymbol{X}}^a\)</span> 重合.
其它两个方向不定, Hughes 给出一个算法, 能够在 <span
class="math inline">\(\hat{\boldsymbol{X}}^a\)</span> 接近 <span
class="math inline">\(e_3\)</span> 时 保持与全局坐标系近乎一致.
不过这类算法, 应该不是唯一的, 只要能避免 <span
class="math inline">\(\hat{\boldsymbol{X}}^a\)</span>
与一个接近平行的向量叉乘即可.</p>
<h4 id="坐标变换">坐标变换</h4>
<p>宏观坐标系与上述定义的坐标系之间的坐标变换关系为 <span
class="math display">\[
\boldsymbol{e}_{i}^{\cdot} = Q_{\alpha i}^{\cdot}
\boldsymbol{e}_{\alpha}
\]</span> 式中, <span class="math inline">\(\cdot\)</span>
表示积分点上的 lamina 坐标系或节点处的 fiber 坐标系. 因此, 向量 <span
class="math inline">\(\boldsymbol{e}_{i}^{\cdot}\)</span>
在宏观坐标系中的坐标列向量排布得到旋转矩阵 <span
class="math inline">\([\mathrm{Q}]\)</span>: <span
class="math display">\[
[\mathrm{Q}^{\cdot}] = [\boldsymbol{e}_{1}^{\cdot},
~\boldsymbol{e}_{2}^{\cdot}, ~\boldsymbol{e}_{3}^{\cdot}]
\]</span> 由此得到坐标变换矩阵为 <span class="math display">\[
[\mathrm{x}^{\cdot}] = [\mathrm{Q}^{\cdot}]^{\top} [\mathrm{x}]
\]</span> lamina 和 fiber 坐标系之间的关系为 <span
class="math display">\[
\boldsymbol{e}_{i}^{f} = Q_{\alpha i}^{f} \boldsymbol{e}_{\alpha} \\
\boldsymbol{e}_{i}^{l} = Q_{\alpha i}^{l} \boldsymbol{e}_{\alpha} \\
\]</span></p>
<h3 id="单元的运动学描述">单元的运动学描述</h3>
<p><span class="math display">\[
\boldsymbol{u}(\xi, \eta, \zeta) = \overline{\boldsymbol{u}}(\xi, \eta)
+ \boldsymbol{U}(\xi, \eta, \zeta) \\
\overline{\boldsymbol{u}}(\xi, \eta) = \sum_{a}^{\mathrm{nen}}
N^{a}(\xi, \eta) \overline{\boldsymbol{u}}^a \\
\boldsymbol{U}(\xi, \eta, \zeta) = \sum_{a}^{\mathrm{nen}} N^{a}(\xi,
\eta) \boldsymbol{U}^a(\zeta) \\
\boldsymbol{U}^a(\zeta) = z^{a}(\zeta) \hat{\boldsymbol{U}}^a
\quad(\text{不求和})
\]</span></p>
<p>壳单元假设纤维方向只有旋转没有拉伸, 因此在小转动假设下,
节点处的向量为 <span
class="math inline">\(\hat{\boldsymbol{U}}^a\)</span> <span
class="math display">\[
\hat{\boldsymbol{U}}^a = \theta_2^a \boldsymbol{e}_{a1}^f - \theta_1^a
\boldsymbol{e}_{a2}^f
\]</span></p>
<h3 id="本构方程">本构方程</h3>
<p>在壳体 Lamina 坐标系下的线弹性本构方程为 <span
class="math display">\[
\sigma^{l} = \mathbb{L}^{l} : \varepsilon^{l}
\]</span> 表示成 Voigt 记法后的矩阵形式为 <span class="math display">\[
[\sigma^{l}] = [\mathrm{L}^{l}] : [\varepsilon^{l}]
\]</span> 壳体的 zero normal stress 假设要求应力分量 <span
class="math inline">\(\sigma_{33}^{l}\)</span> 等于 0, 由此得到关于
<span class="math inline">\(\varepsilon_{3}^{l}\)</span> 的方程: <span
class="math display">\[
\varepsilon_{3}^{l} = -\frac{1}{L_{33}^{l}} (L_{3i&#39;}^{l}
\varepsilon_{i&#39;}^{l})
\]</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(i&#39;\)</span></th>
<th><span class="math inline">\(1\)</span></th>
<th><span class="math inline">\(2\)</span></th>
<th><span class="math inline">\(3\)</span></th>
<th><span class="math inline">\(4\)</span></th>
<th><span class="math inline">\(5\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(ij\)</span></td>
<td><span class="math inline">\(11\)</span></td>
<td><span class="math inline">\(22\)</span></td>
<td><span class="math inline">\(12\)</span></td>
<td><span class="math inline">\(23\)</span></td>
<td><span class="math inline">\(13\)</span></td>
</tr>
</tbody>
</table>
<p>本构方程 <span class="math display">\[
\sigma_{i&#39;}^{l} = L_{i&#39;j}^{l} \varepsilon_{j}^{l}
= L_{i&#39;j&#39;}^{l} \varepsilon_{j&#39;}^{l} + L_{i&#39;3}^{l}
\varepsilon_{3}^{l}
= \left( L_{i&#39;j&#39;}^{l} - \frac{1}{L_{33}}^{l}
L_{i&#39;3}L_{3j&#39;}^{l} \right) \varepsilon_{j&#39;}^{l}
\]</span> 得到各向同性线弹性本构矩阵 <span class="math display">\[
[\mathrm{L}^{l}] = \frac{E}{(1-\nu^2)}
\begin{bmatrix}
1 &amp; \nu &amp; &amp; &amp; \\
&amp; 1 &amp; &amp; &amp; \\
&amp;&amp; \dfrac{1-\nu}{2} &amp;&amp; \\
&amp;&amp;&amp; \kappa\dfrac{1-\nu}{2} &amp; \\
&amp;&amp;&amp;&amp; \kappa \dfrac{1-\nu}{2}
\end{bmatrix}
\]</span> 再加上 bending 修正系数 <span class="math inline">\(\kappa =
5/6\)</span></p>
<h3 id="b-矩阵的构造">B 矩阵的构造</h3>
<p>节点的自由度为 3 个位移自由度和 2 个转角自由度. 由此得到 B
矩阵的列式为 <span class="math display">\[
[\varepsilon^{l}] = \sum_{a}^{\mathrm{nen}} [\mathrm{B}^a]
\begin{bmatrix}
\boldsymbol{u}^a \\
\theta_{a1} \\
\theta_{a2}
\end{bmatrix}
\]</span> 式中, 矩阵 <span class="math inline">\([\mathrm{B}^a]\)</span>
定义为 <span class="math display">\[
[\mathrm{B}^a] = \left[\begin{array}{ll}
b_I^u &amp; b_I^\theta
\end{array}\right]=\left[\begin{array}{cc}
b_1^u &amp; b_1^\theta \\
b_2^u &amp; b_2^\theta \\
b_3^u &amp; b_3^\theta \\
\hdashline
b_4^u &amp; b_4^\theta \\
b_5^u &amp; b_5^\theta
\end{array}\right]
\]</span> 式中的 <span class="math inline">\(b_{I}^u\)</span> 和 <span
class="math inline">\(b_{I}^{\theta}\)</span> 是行向量, <span
class="math display">\[
\begin{aligned}
&amp; b_I^u=\left\langle b_{I
m}^u\right\rangle=\left\langle\begin{array}{lll}
b_{I1}^u &amp; b_{I2}^u &amp; b_{I3}^u
\end{array}\right\rangle \\
&amp; b_I^\theta=\left\langle b_{I
a}^\theta\right\rangle=\left\langle\begin{array}{lll}
b_{I 1}^\theta &amp; b_{I2}^\theta
\end{array}\right\rangle
\end{aligned}
\]</span> 注意到,
节点上的位移自由度是在<strong>全局坐标系下</strong>的分量, 应变是 Lamina
坐标系下的表达式, 因此在求位移导数时需要进行坐标变换.
根据壳单元的运动学方程, 得到 Lamina 坐标系下的位移导数为 <span
class="math display">\[
\frac{ \partial u_{i}^{l} }{ \partial x_{j}^{l}}
= Q_{im}^{l} \frac{ \partial u_{m} }{ \partial x_{j}^{l}}
= Q_{im}^{l} \sum_{a}^{\mathrm{nen}}\left(
\frac{ \partial N^{a} }{ \partial x_{j}^{l}} \overline{u}_m^a
+ \frac{ \partial (N^{a} z^a)}{ \partial x_{j}^{l}} (\theta_2^a
\boldsymbol{e}_{a1}^f - \theta_1^a \boldsymbol{e}_{a2}^f) \cdot
\boldsymbol{e}_{m}
\right)\\
= Q_{im}^{l} \sum_{a}^{\mathrm{nen}}\left(
\frac{ \partial N^{a} }{ \partial x_{j}^{l}} \overline{u}_m^a
- \frac{ \partial (N^{a} z^a)}{ \partial x_{j}^{l}}
\boldsymbol{e}_{am2}^f ~\theta_1^a
+ \frac{ \partial (N^{a} z^a)}{ \partial x_{j}^{l}}
\boldsymbol{e}_{am1}^f ~\theta_2^a
\right)
\]</span> <img
src="./../../../../AppData/Roaming/Typora/typora-user-images/image-20240818151636114.png"
alt="image-20240818151636114" /></p>
<p>式中出现的关于 lamina 坐标的导数,
可以通过坐标变换转换为宏观坐标导数的计算: <span class="math display">\[
\frac{ \partial ~}{ \partial x_{i}^{l}} = Q_{im} \frac{ \partial ~}{
\partial x_{m}}
\]</span></p>
<h3 id="刚度矩阵">刚度矩阵</h3>
<p><span class="math display">\[
\underbrace{[\mathrm{k}]}_{\rm 5 nen \times 5 nen}
= [[\mathrm{k}^{ab}]], \\
\underbrace{[\mathrm{k}^{ab}]}_{\rm 5 \times 5}
= \int_{\square} \int_{-1}^{+1} [\mathrm{B}^a]^{\top} [\mathrm{L}^{l}]
[\mathrm{B}]
J  ~\mathrm{d} \zeta ~\mathrm{d} \square
\]</span></p>
<h3 id="外力向量">外力向量</h3>
<h4 id="体积力">体积力</h4>
<p><span class="math display">\[
\underbrace{[f^{\mathrm{body}}]}_{\rm 5 nen \times 1}
= [[f_a^{\mathrm{body}}]] \\
\underbrace{[f_a^{\mathrm{body}}]}_{\rm 5 \times 1}
= \int_{\square} \int_{-1}^{+1} [\mathrm{N}^a]^{\top} [\mathrm{b}]
J  ~\mathrm{d} \zeta ~\mathrm{d} \square
\]</span></p>
<p>式中, 矩阵 <span class="math inline">\([\mathrm{N}^a]\)</span> 为
<span class="math display">\[
[\mathrm{N}^a]
= \left[\begin{array}{ccc:cc}
N^a &amp; 0 &amp; 0 &amp; -N^a z^a e_{a 12}^f &amp; N^a z^a e_{a 11}^f
\\
0 &amp; N^a &amp; 0 &amp; -N^a z^a e_{a 22}^f &amp; N^a z^a e_{a 21}^f
\\
0 &amp; 0 &amp; N^a &amp; -N^a z^a e_{a 32}^f &amp; N^a z^a e_{a 31}^f
\end{array}\right]
\]</span></p>
<h4 id="面力">面力</h4>
<p><span class="math display">\[
\underbrace{[f^{\mathrm{surf}}]}_{\rm 5 nen \times 1}
= [[f_a^{\mathrm{surf}}]] \\
\underbrace{[f_a^{\mathrm{surf}}]}_{\rm 5 \times 1}
= \int_{\square} [\mathrm{N}^a]^{\top} [\mathrm{t}]
J_s  ~\mathrm{d} \square, \quad
\zeta = \begin{cases}
+1 &amp; \text{top surface} \\
-1 &amp; \text{bottom surface}
\end{cases}
\]</span></p>
<p>式中, <span class="math inline">\(J_s = \| \boldsymbol{x}_{,\xi}
\times \boldsymbol{x}_{,\eta} \|\)</span>.</p>
<p>当面力为压力时, 对应的面力为 <span class="math display">\[
t = -\zeta p \boldsymbol{n}, \quad
\boldsymbol{n} = \frac{\boldsymbol{x}_{,\xi} \times
\boldsymbol{x}_{,\eta}}
{\| \boldsymbol{x}_{,\xi} \times \boldsymbol{x}_{,\eta} \|}
\]</span> 当面力为壳体面内的剪切力时, 假设已知沿参数坐标线的面力分量,
由此得到 <span class="math display">\[
t = h_{\xi} \boldsymbol{e}_{\xi} + h_{\eta} \boldsymbol{e}_{\eta}
\]</span></p>
<h4 id="边力">边力</h4>
<p><span class="math display">\[
[f^{\mathrm{edge}}]
= [[f_a^{\mathrm{edge}}]] \\
[f_a^{\mathrm{edge}}]
= \int_{-1}^{+1} \int_{-1}^{+1} [\mathrm{N}^a]^{\top} [\mathrm{t}]
J_e  ~\mathrm{d} \xi ~\mathrm{d} \zeta, \quad
\eta = \{+1, -1\}
\]</span></p>
<p>式中, <span class="math inline">\(J_e = \| \boldsymbol{x}_{,\xi}
\times \boldsymbol{x}_{,\zeta} \|\)</span>.</p>
<h3 id="应力结果">应力结果</h3>
<p>弯矩, 膜力以及横向剪力可以通过对应力分量 在 <span
class="math inline">\(\zeta\)</span> 方向积分得到</p>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>壳单元</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式迭代方法</title>
    <url>/mech/fem/%E9%9A%90%E5%BC%8F%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一般的有限元平衡方程">一般的有限元平衡方程</h2>
<p>平衡态的方程可以表示为: <span class="math display">\[
0 = \mathbf{f}^{\rm int}(\mathbf{d}^{n+1}, t^{n+1})
- \mathbf{f}^{\rm ext}(\mathbf{d}^{n+1}, t^{n+1})
\triangleq \mathbf{r}^{n+1}(\mathbf{d}^{n+1})
\]</span> 式中, <span class="math inline">\(\mathbf{f}^{\rm
int}\)</span> 和 <span class="math inline">\(\mathbf{f}^{\rm
ext}\)</span> 分别表示 <span class="math inline">\(t^{n+1}\)</span>
时刻的内力与外力. 内力与外力是关于节点位移 <span
class="math inline">\(\mathbf{d}^{n+1}\)</span> 和时刻 <span
class="math inline">\(t^{n+1}\)</span> 的函数. <span
class="math inline">\(\mathbf{r}^{n+1}: \mathbb{R}^n \mapsto
\mathbb{R}^n\)</span> 表示在时刻 <span
class="math inline">\(t^{n+1}\)</span> 关于节点 <span
class="math inline">\(\mathbf{d}\)</span> 的非线性函数, 方程 <span
class="math display">\[
\mathbf{r}^{n+1}(\mathbf{d})=0
\tag{1}
\]</span> 的零点即为使得系统在 <span
class="math inline">\(t^{n+1}\)</span> 平衡的节点位移.</p>
<p>为求解上述平衡方程, 我们使用 Newton 迭代法. 设迭代的初始位移为 <span
class="math inline">\(\mathbf{d}_{(0)}\)</span>, 并定义第 <span
class="math inline">\(i\)</span> 个迭代步方程的残差为 <span
class="math display">\[
\mathbf{r}_{(i)}^{n+1} \triangleq
\mathbf{r}^{n+1}(\mathbf{d}_{(i)}^{n+1}),
\quad i=0,1,2,\ldots
\]</span> 在 <span class="math inline">\(\mathbf{d} =
\mathbf{d}_{(i)}\)</span> 处展开残差函数 <span
class="math inline">\(\mathbf{r}^{n+1}\)</span>, 就得到 <span
class="math display">\[
\mathbf{r}^{n+1}(\mathbf{d})
= \mathbf{r}_{(i)}^{n+1}
+ \left. \frac{\partial \mathbf{r} ^{\scriptsize n+1}}{\partial
\mathbf{d}}
\right|_{\mathbf{d} = \mathbf{d}_{(i)}} (\mathbf{d} - \mathbf{d}_{(i)})
+ \mathcal{O}(\mathbf{d} - \mathbf{d}_{(i)})^2
\]</span> 忽略关于 <span class="math inline">\((\mathbf{d} -
\mathbf{d}_{(i)})\)</span> 的高阶项, 并将上式代入到待求解的方程 (1)
当中, 就得到关于 <span class="math inline">\(\mathbf{d}\)</span>
的线性近似方程: <span class="math display">\[
\mathbf{r}_{(i)}^{n+1}
+ \left. \frac{\partial \mathbf{r} ^{\scriptsize n+1}}{\partial
\mathbf{d}}
\right|_{\mathbf{d} = \mathbf{d}_{(i)}} (\mathbf{d} - \mathbf{d}_{(i)})
= 0
\]</span> 为了方便表示上述方程, 重新定义符号: <span
class="math display">\[
A_{(i)}^{n+1}
\triangleq \left. \frac{\partial \mathbf{r} ^{\scriptsize n+1}}{\partial
\mathbf{d}}
\right|_{\mathbf{d} = \mathbf{d}_{(i)}}, \quad
\Delta \mathbf{d}_{(i+1)}
\triangleq \mathbf{d} - \mathbf{d}_{(i)}
\]</span> 得到 <span class="math display">\[
\mathbf{r}_{(i)}^{n+1}
+ A_{(i)}^{n+1} \Delta \mathbf{d}_{(i+1)} = 0
\tag{2}
\]</span> 求解方程 (2) 得到 <span class="math inline">\(\Delta
\mathbf{d}_{(i+1)}\)</span>, 下一迭代步的初值更新为 <span
class="math display">\[
\mathbf{d}_{(i+1)} = \mathbf{d}_{(i)} + \Delta \mathbf{d}_{(i+1)}
\]</span> 为完成 Newton 迭代法, 还需要设置收敛准则, 在满足准则之后, 跳出
Newton 迭代法.</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/image-20240727161539419.png"
alt="image-20240727161539419" />
<figcaption aria-hidden="true">image-20240727161539419</figcaption>
</figure>
<h5 id="基于残差的收敛准则">基于残差的收敛准则</h5>
<p><span class="math display">\[
\| \mathbf{r}_{(i)}^{n+1} \| \leq \varepsilon
\max \left( \|\mathbf{f}^{\rm int}(\mathbf{d}_{(i)}^{n+1}, t^{n+1})\| ,
\|\mathbf{f}^{\rm ext}(\mathbf{d}_{(i)}^{n+1}, t^{n+1})\|
\right)
\]</span></p>
<h5 id="基于位移增量的收敛准则">基于位移增量的收敛准则</h5>
<p><span class="math display">\[
\|\Delta \mathbf{d}_{(i+1)}\| \leq \varepsilon \|
\mathbf{d}_{(i+1)}^{n+1} \|
\]</span></p>
<p>平衡问题的隐式求解算法陈述如下:</p>
<ol type="1">
<li>初始化: 节点位移 <span class="math inline">\(\mathbf{d}^{0} :=
\mathbf{0}\)</span>; 单元应力 <span
class="math inline">\(\boldsymbol{\sigma}^{0}\)</span>; 增量步索引 <span
class="math inline">\(n := 0\)</span>; 分析步时刻 <span
class="math inline">\(t := 0\)</span>;</li>
<li>开始计算增量步 <span class="math inline">\(n+1\)</span>,
对应增量时间为 <span class="math inline">\(\Delta t^{n+1}\)</span>.
初始化 Newton 迭代法: 迭代步索引 <span class="math inline">\(i :=
0\)</span>, <span class="math inline">\(\mathbf{d}_{(i)}^{n+1} :=
\mathbf{d}^{n}\)</span>, 最大迭代步数 <code>MAXITER</code>
<ol type="1">
<li>计算系统内力 <span class="math inline">\(\mathbf{f}^{\rm
int}(\mathbf{d}_{(i)}^{n+1}, t^{n+1})\)</span> 与外力 <span
class="math inline">\(\mathbf{f}^{\rm ext}(\mathbf{d}_{(i)}^{n+1},
t^{n+1})\)</span>, 得到内外力之差 <span
class="math inline">\(\mathbf{r}_{(i)}^{n+1}\)</span></li>
<li>计算系统刚度矩阵 <span
class="math inline">\(A_{(i)}^{n+1}\)</span></li>
<li>求解线性方程组 (2), 得到 <span class="math inline">\(\Delta
\mathbf{d}_{(i+1)}\)</span></li>
<li>更新节点位移 <span class="math inline">\(\mathbf{d}_{(i+1)}^{n+1} :=
\mathbf{d}_{(i)}^{n+1} + \Delta \mathbf{d}_{(i+1)}\)</span>; 迭代步索引
<span class="math inline">\(i := i+1\)</span></li>
<li>检查收敛性, 若不收敛, 则回到迭代步骤 1</li>
</ol></li>
<li>更新节点位移: <span class="math inline">\(\mathbf{d}^{n+1} :=
\mathbf{d}_{(i+1)}^{n+1}\)</span>; 分析步时刻 <span
class="math inline">\(t := t + \Delta t^{n+1}\)</span>; 增量步索引 <span
class="math inline">\(n := n+1\)</span>;</li>
</ol>
<blockquote>
<p>[!NOTE]</p>
<p>不同的收敛准则, 检查收敛性的位置是不同的,
上述算法设定的是基于位移增量的收敛准则</p>
</blockquote>
<h2 id="线性问题求解">线性问题求解</h2>
<p>对于线性问题, 系统的刚度 $A_{(i)}^{n+1} $
对所有的增量步与迭代步保持恒定, 记为 <span
class="math inline">\(K\)</span>. 因此, 式 (2) 可以改写为 <span
class="math display">\[
K \Delta \mathbf{d}_{(i+1)} = \mathbf{f}^{\rm
ext}(\mathbf{d}_{(i)}^{n+1}, t^{n+1})
-\mathbf{f}^{\rm int}(\mathbf{d}_{(i)}^{n+1}, t^{n+1})
\]</span> 线性问题不需要使用多个增量步,
只需要在一个增量步中进行迭代即可, 因此将上式中关于增量步的上标去掉:
<span class="math display">\[
K \Delta \mathbf{d}_{(i+1)} = \mathbf{f}^{\rm ext}(\mathbf{d}_{(i)})
-\mathbf{f}^{\rm int}(\mathbf{d}_{(i)})
\]</span></p>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>Newton 迭代法</tag>
        <tag>收敛准则</tag>
      </tags>
  </entry>
  <entry>
    <title>有限元中的能量原理</title>
    <url>/mech/fem/%E6%9C%89%E9%99%90%E5%85%83%E4%B8%AD%E7%9A%84%E8%83%BD%E9%87%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="初边值问题的陈述">初边值问题的陈述</h2>
<h3 id="物质描述">物质描述</h3>
<p>使用物质描述的控制方程定义在 <span class="math inline">\(B_0 \times
(0,t_0)\)</span> 区域上, 方程的未知量为 <span
class="math inline">\(\varphi(X,t)\)</span>, 满足守恒定律的控制方程为
<span class="math display">\[
(\varphi \nabla_0) \cdot S \cdot \nabla_0 + \rho_0 b
= \rho_0 \frac{ \partial^2 \varphi }{ \partial t^2 }
\tag{1.1.a}
\]</span> 式中, <span class="math inline">\(S\)</span> 为 PK2 应力.
对于是初边值问题, 定解需要给定初始条件和边界条件. 其中初始条件为 <span
class="math display">\[
\varphi(X,0) = X, \quad \frac{ \partial \varphi }{ \partial t}(X,0) =
v_0(X)
\tag{1.1.b}
\]</span> 方程的边界条件有两类, 一类是位移边界条件,
在参考构型中的边界处指定 <span class="math inline">\(t&gt;0\)</span>
时刻的位移: <span class="math display">\[
\varphi(X,t) = \overline{x}(X,t), \quad X \in \partial B_{0u},~ t &gt; 0
\tag{1.1.c}
\]</span> 另一类是力边界条件, 在参考构型的边界处指定 <span
class="math inline">\(t&gt;0\)</span> 时刻的面力: <span
class="math display">\[
F \cdot S \cdot N(X) = \overline{T}(X,t) \quad X \in \partial B_{0t},~ t
&gt; 0
\tag{1.1.d}
\]</span> 这两类边界条件不能重叠,
也即不能在边界点同一个分量处指定两种边界条件, 否则就是 ill-posed: <span
class="math display">\[
\partial B_{0u} \cup \partial B_{0t} = \partial B_{0}, \quad
\partial B_{0u} \cap \partial B_{0t} = \empty
\]</span> 除上述初边值条件之外, 还需要提供本构关系, 将 PK2
应力与变形和变形历史相关联, 以及 <span
class="math inline">\(t=0\)</span> 时刻的密度 <span
class="math inline">\(\rho_0 = \rho_0(X)\)</span> 和 <span
class="math inline">\(t&gt;0\)</span> 时刻的体积力 <span
class="math inline">\(b = b(X,t)\)</span>. 至此, 待求解的力学初边值问题
(1) 才算完整地陈述.</p>
<blockquote>
<p>[!NOTE]</p>
<h5 id="使用位移-u-作为未知量表述的初边值问题">使用位移 <span
class="math inline">\(u\)</span> 作为未知量表述的初边值问题</h5>
<p>方程中的未知量也可以是位移 <span class="math inline">\(u\)</span>, 与
<span class="math inline">\(\varphi\)</span> 的关系为 <span
class="math display">\[
u(X,t) = \varphi(X,t) - X
\tag{1.2}
\]</span> 相应的初始条件为 <span class="math display">\[
u(X,0) = 0, \quad \frac{ \partial u }{ \partial t}(X,0) = v_0(X)
\]</span> 以及位移边界条件为 <span class="math display">\[
u(X,t) = \overline{u}(X,t), \quad X \in \partial B_{0u},~ t &gt; 0
\]</span> 上式与式 (1.1.c) 的关系为 <span class="math display">\[
\overline{u}(X,t) = \overline{x}(X,t) - X
\]</span></p>
</blockquote>
<h3 id="空间描述">空间描述</h3>
<h2 id="势能原理">势能原理</h2>
<p>在这一节中, 我们将平衡方程与某一能量泛函取驻值的条件等价,
由此得到势能驻值原理. 泛函的驻值点可能是极大值或极小值或鞍点,
我们将指出系统的稳定平衡状态对应能量泛函的极小值,
这也是最小势能原理.</p>
<h3 id="平衡方程的势能泛函">平衡方程的势能泛函</h3>
<p>若不考虑方程 (1.1.a) 中的加速度项,
就得到材料在平衡状态下满足的控制方程为 <span class="math display">\[
(\varphi \nabla_0) \cdot S \cdot \nabla_0 + \rho_0 b  = 0
\tag{2.1.a}
\]</span> 以及边界条件 <span class="math display">\[
\varphi(X) = \overline{x}(X), \quad X \in \partial B_{0u} \\
F \cdot S \cdot N(X) = \overline{T}(X) \quad X \in \partial B_{0t}
\tag{2.1.b}
\]</span> 接下来, 我们将构造一个与上述边值问题等价的变分问题.
首先构造如下能量泛函 <span class="math inline">\(\Pi:L \mapsto
\mathbb{R}\)</span>, 等于材料中的应变能与外力势能之和: <span
class="math display">\[
\Pi(\varphi) = \underbrace{\int_{B_0} W(F) ~\mathrm{d} X }_{应变能}
\underbrace{
- \int_{B_0} \rho_0 b \cdot \varphi ~\mathrm{d} X
- \int_{\partial B_{0t}} \overline{T} \cdot \varphi ~\mathrm{d}
\Sigma(X)
}_{外力势能}
\tag{2.2.a}
\]</span> 式中, <span class="math inline">\(W\)</span> 为应变能密度函数
(质量密度), 变形梯度 <span class="math inline">\(F = \varphi
\nabla_0\)</span>. 泛函 <span class="math inline">\(\Pi\)</span>
定义在函数空间上, 为了建立等价关系, 除了确定泛函的形式之外,
<strong>还需要确定函数变量 <span class="math inline">\(\varphi\)</span>
所在的空间 <span class="math inline">\(L\)</span></strong>.
我们约束变形映射 <span class="math inline">\(\varphi\)</span>
满足与边值问题的位移边界条件 (2.1.b) 一致: <span class="math display">\[
\varphi \in L = \{ f \mid f \in C^0(B_0), \quad f = \overline{x}
~~\text{on}~~ \partial B_{0u} \}
\tag{2.2.b}
\]</span></p>
<h3 id="泛函的变分">泛函的变分</h3>
<p>在函数空间 <span class="math inline">\(L\)</span> 中点 <span
class="math inline">\(\varphi_0\)</span> 附近, 定义一条经过点 <span
class="math inline">\(\varphi_0\)</span> 的参数曲线: <span
class="math display">\[
\varphi(\varepsilon) = \varphi_0 + \varepsilon \eta, \quad \varepsilon
\in \mathbb{R}
\tag{2.3}
\]</span> 由此得到关于参数 <span
class="math inline">\(\varepsilon\)</span> 的函数 <span
class="math inline">\(\phi(\varepsilon)\)</span>: <span
class="math display">\[
\phi(\varepsilon) \triangleq \Pi(\varphi_0 + \varepsilon \eta)
\]</span> 若泛函在点 <span class="math inline">\(\varphi_0\)</span>
处取极大(小)值, 那么对应函数 <span class="math inline">\(\phi\)</span>
在 <span class="math inline">\(\varepsilon = 0\)</span> 处取极大(小)值,
因此 <span class="math display">\[
\left. \frac{\mathrm{d} \phi}{\mathrm{d} \varepsilon}
\right|_{\varepsilon=0} = 0
\tag{2.4}
\]</span> 是泛函取极值的一个必要条件. 如果定义运算 <span
class="math inline">\(\delta_{\eta}: L \mapsto L\)</span> <span
class="math display">\[
\boxed{
\delta_{\eta}[f](\varphi_0) \triangleq
\left. \frac{\mathrm{d} ~}{\mathrm{d} \varepsilon} f(\varphi_0 +
\varepsilon \eta) \right|_{\varepsilon=0}
}
\tag{2.5}
\]</span> 那么条件 (2.4) 就可以重新叙述为 <span class="math display">\[
\delta_{\eta}[\Pi](\varphi_0) = 0, \quad \forall \eta \in \overline{L}
\tag{2.6}
\]</span> 接下来确定 <span class="math inline">\(\eta\)</span>
的取值空间. 根据式 (2.3), <span class="math inline">\(\varphi_0 \in
L\)</span>, <span class="math inline">\(\varphi(\varepsilon) \in
L\)</span>, 因此 <span class="math inline">\(\eta\)</span>
的取值函数空间对应为位移边界处恒等于 0 的函数: <span
class="math display">\[
\eta \in \overline{L} = \{ f \mid f \in C^0(B_0), \quad f = 0
~~\text{on}~~ \partial B_{0u} \}
\tag{2.7}
\]</span> 为了在记号上与微分符号进行类比, 我们将 <span
class="math inline">\(\varepsilon\eta\)</span> 重映射为 <span
class="math inline">\(\varepsilon\delta \varphi\)</span>,
表示关于独立变量 <span class="math inline">\(\varphi\)</span>
的<strong>变分</strong>. 当独立变量的变分意义明确时, 省略运算符 <span
class="math inline">\(\delta_{\eta}\)</span> 的下标, 并将 <span
class="math inline">\(\delta_{\eta}[f]\)</span> 简记作 <span
class="math inline">\(\delta f\)</span>. 根据式 (2.5), 运算符 <span
class="math inline">\(\delta\)</span> 的定义是基于单变量微积分的导数,
因此继承了关于求导数的线性性质, 所以可以将 <span
class="math inline">\(\delta\)</span> 与微分符号 <span
class="math inline">\(~\mathrm{d}\)</span> 进行类推.</p>
<blockquote>
<p>[!TIP]</p>
<h5 id="变分运算公式">变分运算公式</h5>
<p>函数的乘积: <span class="math display">\[
\begin{aligned}
\delta(fg) &amp;= \left. \frac{\mathrm{d} ~}{\mathrm{d} \varepsilon}
f(\varphi + \varepsilon \delta\varphi) g(\varphi + \varepsilon
\delta\varphi)
\right|_{\varepsilon=0} \\
&amp;= \left( \left. f(\varphi + \varepsilon \delta\varphi)
\frac{\mathrm{d} ~}{\mathrm{d} \varepsilon}
g(\varphi + \varepsilon \delta\varphi)
+ g(\varphi + \varepsilon \delta\varphi) \frac{\mathrm{d} ~}{\mathrm{d}
\varepsilon}
f(\varphi + \varepsilon \delta\varphi)
\right)\right|_{\varepsilon=0} \\
&amp;= f ~\delta g + g ~\delta f
\end{aligned}
\]</span> 微分运算: <span class="math display">\[
\delta (\varphi \circ \nabla_0) = \left. \frac{\mathrm{d} ~}{\mathrm{d}
\varepsilon}
\left(  (\varphi \circ \nabla_0) + \varepsilon (\delta \varphi \circ
\nabla_0) \right)
\right|_{\varepsilon=0}
= \delta \varphi \circ \nabla_0
\]</span> 式中, <span class="math inline">\(\circ\)</span> 表示梯度,
散度 <span class="math inline">\(\cdot\)</span>, 叉乘 <span
class="math inline">\(\times\)</span> 中的一种.</p>
<p>积分运算: <span class="math display">\[
\delta \int f(\varphi) ~\mathrm{d}X
= \left. \frac{\mathrm{d} ~}{\mathrm{d} \varepsilon}
\int f(\varphi + \varepsilon \delta \varphi) ~\mathrm{d}X
\right|_{\varepsilon=0}
= \int \left. \frac{\mathrm{d} ~}{\mathrm{d} \varepsilon}
f(\varphi + \varepsilon \delta \varphi) \right|_{\varepsilon=0}
~\mathrm{d}X
= \int \delta f ~\mathrm{d} X
\]</span> 复合函数: <span class="math display">\[
\left. \delta f \circ g = \frac{\mathrm{d} ~}{\mathrm{d} \varepsilon}
f \circ g (\varphi + \varepsilon \delta \varphi) \right|_{\varepsilon=0}
= \frac{\mathrm{d} f}{\mathrm{d} g} \delta g
\]</span> 最后, 我们说明即使选取不同的独立变量 <span
class="math inline">\(u\)</span> 或者 <span
class="math inline">\(\varphi\)</span>, 它们的变分总是相同的. 根据式
(1.2): <span class="math display">\[
\delta u = \delta (\varphi -X)
\]</span> <span class="math inline">\(X\)</span> 与 <span
class="math inline">\(\varphi\)</span> 无关, 因此有 <span
class="math display">\[
\delta u = \delta \varphi
\]</span> 因此在下文的推导中, 我们用更符合惯例的 <span
class="math inline">\(\delta u\)</span> 代替 <span
class="math inline">\(\delta \varphi\)</span>.</p>
</blockquote>
<h3 id="泛函驻值条件蕴含平衡方程">泛函驻值条件蕴含平衡方程</h3>
<p>根据式 (6), 泛函 <span class="math inline">\(\Pi\)</span>
取驻值的必要条件为 <span class="math display">\[
\delta \Pi = 0, \quad \forall \delta u \in \overline{L}
\]</span> 将式 (2.2.a) 代入上式中得到 <span class="math display">\[
\delta \Pi = \delta \int_{B_0} W(F) ~\mathrm{d} X
- \delta \int_{B_0} \rho_0 b \cdot \varphi ~\mathrm{d} X
- \delta \int_{\partial B_{0t}} \overline{T} \cdot \varphi ~\mathrm{d}
\Sigma(X)
\equiv 0, \quad \forall \delta u \in \overline{L}
\tag{2.8}
\]</span> 式中, <span class="math display">\[
\delta \int_{B_0} W(F) ~\mathrm{d} X  = \int_{B_0} \delta W(F)
~\mathrm{d} X
= \int_{B_0} \frac{ \partial W }{ \partial F} : (\delta u
\nabla_0)  ~\mathrm{d} X
\tag{2.9}
\]</span> 如果考虑材料为超弹材料, 那么 <span class="math display">\[
P = \frac{ \partial W }{ \partial F}
\]</span> 式中, <span class="math inline">\(P\)</span> 为 PK1 应力,
<span class="math inline">\(P = F \cdot S\)</span>. 应用分部积分公式得到
<span class="math display">\[
P : (\delta u \nabla_0) = (\delta u \cdot P) \cdot \nabla_0
- (P \cdot \nabla_0) \cdot \delta u
\]</span> 代入到 (2.9) 式右端, 并注意到变分 <span
class="math inline">\(\delta u \equiv 0\)</span> 在边界 <span
class="math inline">\(\partial B_{0u}\)</span>: <span
class="math display">\[
\boxed{
\int_{B_0} P : (\delta u \nabla_0)  ~\mathrm{d} X
= \int_{\partial B_{0u}} \delta u \cdot P \cdot N ~\mathrm{d} \Sigma(X)
- \int_{B_0} (P \cdot \nabla_0) \cdot \delta u ~\mathrm{d} X
}
\tag{2.10}
\]</span> 式 (2.10) 是虚功原理的特殊形式, 这里我们是从守恒系统的变分等于
0 出发, 得到式 (2.9). 之后我们将从平衡方程出发,
得到更一般形式的虚功原理.</p>
<p>将 (2.10) 代入到 (2.8) 中得到 <span class="math display">\[
- \int_{B_0} (P \cdot \nabla_0 + \rho_0 b) \cdot \delta u ~\mathrm{d} X
+ \int_{\partial B_{0t}} (P \cdot N -\overline{T}) \cdot \delta u
~\mathrm{d} \Sigma(X)
= 0, \quad  \forall \delta u \in \overline{L}
\]</span> 再根据 <span class="math inline">\(\delta u\)</span> 的任意性,
就得到平衡方程 (2.1.a) 和力边界条件 (2.1.b).</p>
<h3 id="平衡态的稳定性-最小势能原理">平衡态的稳定性, 最小势能原理</h3>
<p>在上述推导中, 我们只预设了变分的驻值性,
并由此得到平衡方程和力边界条件. 进一步地,
如果我们能确定泛函在驻值点处如果取得极小值,
那么就可以确定系统的平衡态是<strong>稳定的</strong>.
这就是最小势能原理.</p>
<h2 id="虚功原理">虚功原理</h2>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202408131701295.png"
alt="image-20240813170058133" />
<figcaption aria-hidden="true">image-20240813170058133</figcaption>
</figure>
<p>首先我们定义什么是 statically admissible forces and stresses 和
kinematically admissible displacements:</p>
<ul>
<li><strong>statically admissible stresses</strong>:
满足平衡方程和力边界条件的应力场分布 <span class="math inline">\(\tilde
P\)</span>;</li>
<li><strong>kinematically admissible displacements</strong>
满足位移边界条件的位移场分布.</li>
</ul>
<p>在假想的位移场下, 可允许位移之间的差值被定义为虚位移场 <span
class="math inline">\(\delta \tilde u\)</span>, 虚位移场在式 (2.7)
定义的函数空间当中. 当施加虚位移场 <span class="math inline">\(\delta
\tilde u\)</span> 时, 假设应力场和外力固定不变,
因此外力在虚位移场下所做的虚外力功为力边界处的面力与体积力做功之和:
<span class="math display">\[
\delta W_{E}
\triangleq \int_{\partial B_{0t}} \delta \tilde u \cdot \overline{T}
~\mathrm{d}X
+ \int_{B_0} \rho_0 b \cdot \delta \tilde u ~\mathrm{d}\Sigma(X)
\]</span> 虚应力场 <span class="math inline">\(\tilde{P}\)</span>
满足指定的力边界条件 <span class="math inline">\(\tilde{P} \cdot N =
\overline{T}\)</span>, 因此有 <span class="math display">\[
\int_{\partial B_{0t}} \delta \tilde u \cdot \overline{T} ~\mathrm{d}X
= \int_{\partial B_{0t}} \delta \tilde u \cdot \tilde{P} \cdot N
~\mathrm{d}X
\]</span> 注意到 <span class="math inline">\(\delta \tilde u\)</span>
在边界 <span class="math inline">\(\partial B_{0u}\)</span> 处恒等于 0,
因此可以将上式中边界积分项拓展到封闭边界区域的积分. 再应用散度定理得到
<span class="math display">\[
\oint_{\partial B_{0}} \delta \tilde u \cdot \tilde{P} \cdot N
~\mathrm{d}X
= \int_{B_0} (\delta \tilde u \nabla_0) : \tilde{P}
+ \delta \tilde u  \cdot (\tilde{P} \cdot \nabla_0)  ~\mathrm{d}X
\]</span> 定义上式中第二项为内力虚功: <span class="math display">\[
\delta W_{I} \triangleq \int_{B_0} (\delta \tilde u \nabla_0) :
\tilde{P}
\]</span> 同时注意到 <span class="math inline">\(\tilde{P}\)</span>
是满足平衡方程的虚应力场: <span class="math display">\[
\tilde{P} \cdot \nabla_0 + \rho_0 b = 0
\]</span> 最终我们得到 <span class="math display">\[
\delta W_{E} = \delta W_{I}
\]</span> 因此, 对于满足平衡方程和力边界条件的虚应力场, 以及虚位移场,
外力对系统的虚位移所做的外力功,
等于虚应力场在虚位移导致的虚应变场所做的内力功. 在虚功原理的陈述中,
应力场和位移场是完全独立的, 没有考虑任何附加的本构关系.</p>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>虚功原理</tag>
        <tag>最小势能原理</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/mech/fem/%E6%9C%89%E9%99%90%E5%85%83%E6%AE%8B%E5%B7%AE%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>非线性计算中的增量步与迭代方法</title>
    <url>/mech/fem/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%A2%9E%E9%87%8F%E6%AD%A5%E4%B8%8E%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>参考文献:</strong></p>
<p><strong>M.A.Crisfield, Non-linear Finite Element Analysis of Solids
and Structures.</strong></p>
<h2 id="算例简述">算例简述</h2>
<p>本算例是希望通过一个简单的一维系统，给出非线性计算过程中<strong>增量步</strong>的概念，这是线性与非线性有限元计算之间一个很大的区别。</p>
<p>我们准备分析的系统如图所示</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404160956053分析系统示意图.png" alt="分析系统示意图" style="zoom: 20%;" /></p>
<span id="more"></span>
<p>几何以及材料参数设置如下:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">L = <span class="number">2500</span>; <span class="comment">% initial truss length</span></span><br><span class="line">z =   <span class="number">25</span>; <span class="comment">% initial offset(no stress)</span></span><br><span class="line">E =  <span class="number">5e7</span>; <span class="comment">% Young&#x27;s modulus</span></span><br><span class="line">A =    <span class="number">1</span>; <span class="comment">% cross-section area</span></span><br><span class="line">d = <span class="built_in">sqrt</span>(L^<span class="number">2</span> - z^<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="系统-位移-外载-关系的解析求解">系统 位移-外载
关系的解析求解</h2>
<p>该系统外载 <span class="math inline">\(W\)</span> 与位移 <span
class="math inline">\(w\)</span>
之间的解析关系是可以得到的，接下来我们将推导这一关系，并用它来衡量之后数值算法的准确性。</p>
<p>杆原长为 <span class="math inline">\(L\)</span>，变形后杆长度 <span
class="math inline">\(l\)</span> 为： <span class="math display">\[
l=\sqrt{(z+w)^2 +d^2 }
\]</span> 杆的变形量 <span class="math inline">\(\Delta l\)</span> 为
<span class="math display">\[
\Delta l \triangleq l-L=\sqrt{(z+w)^2 +d^2 }-L
\]</span> 在我们的符号约定下，<span class="math inline">\(\Delta
l\)</span> 正值表示拉伸，负值表示压缩。根据定义，杆的应变为 <span
class="math display">\[
\varepsilon \triangleq \frac{\Delta l}{L}
=\frac{\sqrt{(z+w)^2 +d^2 }-L}{L}
=\sqrt{ {\left( \frac{w}{L} \right)}^2 +2\left( \frac{zw}{L^2 }
\right)+1 } - 1
\]</span> 若假设 <span class="math display">\[
L\gg z, L \gg w
\tag{1}
\]</span> 那么有如下近似关系： <span class="math display">\[
\varepsilon \approx \frac{z}{L^2}w+\frac{1}{2L^2}w^2
\]</span></p>
<p>根据受力示意图，系统内力 <span class="math inline">\(N\)</span> 和
<span class="math inline">\(P\)</span> 与外载 <span
class="math inline">\(W\)</span> 之间的平衡关系为： <span
class="math display">\[
W = N \sin\theta + P
\tag{2}
\]</span> 又因为假设的小量关系（1），所以 <span class="math inline">\(l
\approx L\)</span>，因此 <span class="math inline">\(\sin
\theta\)</span> 可以近似表示为 <span class="math display">\[
\sin \theta = \frac{z+w}{l} \approx \frac{z+w}{L}
\tag{3}
\]</span> 杆材料的本构关系将应变 <span
class="math inline">\(\varepsilon\)</span> 与杆的内力 <span
class="math inline">\(N\)</span> 联系起来： <span
class="math display">\[
N=EA\varepsilon =EA\left( \frac{z}{L^2}w+\frac{1}{2L^2}w^2 \right)
\tag{4}
\]</span> 根据弹簧的本构关系，弹簧力 <span
class="math inline">\(P\)</span> 为 <span class="math display">\[
P=K_{\mathrm{s}} w
\tag{5}
\]</span> 将式（3）（4）（5） 代入到式（2） 中，可以得到外载 <span
class="math inline">\(W\)</span> 与位移 <span
class="math inline">\(w\)</span> 的关系为 <span class="math display">\[
W = EA\left(
\frac{zw}{L^2}+\frac{1}{2}{ \left(\frac{w}{L}\right)}^2
\right) \frac{w+z}{L}+K_{ \mathrm{s} } w
= \frac{EA}{L^3 }\left(z^2 w+\frac{3}{2}zw^2 +\frac{1}{2}w^3 \right)+K_{
\mathrm{s} } w
\tag{6}
\]</span> 可以看到，外载与位移之间的关系是非线性的，可以用 MATLAB
作出位移-外载关系曲线的解析解：</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161017053力位移曲线-解析方法.png" alt="力位移曲线-解析方法" style="zoom: 50%;" /></p>
<h2 id="系统-位移-外载-关系的数值求解">系统 位移-外载
关系的数值求解</h2>
<p>接下来，我们将使用 增量步 + 牛顿迭代法 来求解 位移-外载 曲线。</p>
<h3 id="增量步方法">增量步方法</h3>
<p>在陈述增量步方法之前，还是需要再强调一下<strong>线性问题与非线性问题之间的区别</strong>。对于线性问题，位移-外载曲线总是一条<strong>直线</strong>。因此，求解一次系统方程得到
<span class="math inline">\((w_0 ,W_0
)\)</span>，就能够知道系统在任意外载 <span
class="math inline">\(W\)</span> 下的位移响应 <span
class="math inline">\(w\)</span>：</p>
<p><span class="math display">\[
w=\frac{w_0 }{W_0 }W
\]</span></p>
<p>但在本例中，位移-外载曲线并不是直线，因此不可能像线性问题一样，让外载「一步到位」，直接得到最终的加载结果。不过，我们可以将<strong>整个加载过程分成多个增量步</strong>，在增量步足够小的时候，系统的响应是可以近似
「线性」的。</p>
<p>我们将加载过程分成 <span class="math inline">\(N\)</span>
步，每一步的增量为 <span class="math inline">\(\Delta
W_n\)</span>。为了方便陈述系统在每一个加载点的状态，引入「加载时间」<span
class="math inline">\(t\)</span>，它与增量步之间的关系可以用下面的数轴来描述：</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161325025加载时间轴.png" alt="image-20240416132502849" style="zoom:67%;" /></p>
<div class="note info"><p>加载时间 <span class="math inline">\(t\)</span>
并不等同于真实的物理时间。</p>
</div>
<p>在该增量步下，如果使用显式方法计算（<span
class="math inline">\(t_{n+1}\)</span> 时刻的未知量可全部由 <span
class="math inline">\(t_{n}\)</span> 时刻的已知量计算得到），位移增量
<span class="math inline">\(\Delta w_{n+1}\)</span> 为 <span
class="math display">\[
\Delta w_{n+1}:={\left( \left. \frac{\mathrm{d}W}{\mathrm{d}w}
\right|_{t_{n}} \right)}^{-1} \Delta W_{n+1}=K_{n}^{-1} \Delta W_{n+1}
\tag{7}
\]</span></p>
<p>式中，<span class="math inline">\(K_{n}\)</span> 为外载 <span
class="math inline">\(W\)</span> 对位移 <span
class="math inline">\(w\)</span> 在 <span
class="math inline">\(t_{n}\)</span> 时刻的导数：</p>
<p><span class="math display">\[
K_{n} \triangleq \left. \frac{\mathrm{d} W}{\mathrm{d} w} \right|_{t_n}
=\frac{EA}{L}{\left(\frac{z}{L}\right)}^2 +\frac{EA}{L}\left(\frac{2zw_n
+ w_n^2 }{L^2 }\right)+\frac{N}{L}+K_{\mathrm{s}}
\]</span></p>
<p>式中，<span class="math inline">\(w_n = \sum_{k=1}^{n} \Delta
w_{k}\)</span>，<span class="math inline">\(n=0\)</span> 时 <span
class="math inline">\(w_n=0\)</span>。对于第一次的增量步，位移 <span
class="math inline">\(w_0 = 0\)</span>，杆中的内力 <span
class="math inline">\(N_0=0\)</span>，由此计算得到点 <span
class="math inline">\((0,0)\)</span> 处的 <span
class="math inline">\(K_{n}\)</span> 为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">K = <span class="number">3.3500</span></span><br></pre></td></tr></table></figure>
<p>下一步的位移增量 <span class="math inline">\(\Delta w_1\)</span>
为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">dw = <span class="number">-2.0896</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161048401增量步计算结果.png" alt="增量步计算结果" style="zoom:50%;" /></p>
<p>多个增量步累积计算的结果为</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161051373增量步方法结果.png" alt="增量步方法结果" style="zoom: 50%;" /></p>
<p>需要指出的是，只使用<strong>显式</strong>增量步方法得到的结果，<strong>系统内力与外载并不是平衡的</strong>。例如在第一个增量步时，外载增量
<span class="math inline">\(\Delta W_1 = -7\)</span>，对应位移增量为
<span class="math inline">\(\Delta w_1\)</span> 为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">dw = <span class="number">-2.0896</span></span><br></pre></td></tr></table></figure>
<p>代入式（4）中内力的计算公式，并在外载方向投影，得到杆内力与弹簧力之和为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">f_ext = <span class="number">-6.4908</span></span><br></pre></td></tr></table></figure>
<p>由此可见系统的内力与外载并不相等： <span class="math display">\[
-7=f^{\mathrm{ext}} \neq f^{\mathrm{int}} = -6.4908
\]</span></p>
<h3 id="迭代法求解">迭代法求解</h3>
<p>我们已经看到，如果只使用显式增量步计算，系统内外力并不是平衡的。系统内外力的差值可以定义为如下残差函数
<span class="math inline">\(g(w)\)</span> ：</p>
<p><span class="math display">\[
g(w) \triangleq \frac{EA}{L^3 }\left(z^2 w+\frac{3}{2}zw^2
+\frac{1}{2}w^3 \right)+K_{\mathrm{s}} w-W
\]</span></p>
<p>对给定的外载 <span
class="math inline">\(W\)</span>，真实位移应使得残差函数 <span
class="math inline">\(g(w) \equiv 0\)</span>。在增量步计算过程中，即使在
<span class="math inline">\(t_n\)</span>
时刻可以保证系统内外力平衡，由于对系统在 <span
class="math inline">\(\Delta W_{n+1}\)</span> 增量步的线性假设，在 <span
class="math inline">\(t_{n+1}\)</span> 时刻的系统内外力一般并不平衡：
<span class="math display">\[
g(w_{n+1}^{(0)}) \neq 0
\]</span> 式中，<span class="math inline">\(w_{n+1}^{(0)}\)</span>
表示直接通过式（7）得到的结果。我们可以将 <span
class="math inline">\(w_{n+1}^{(0)}\)</span> 作为 Newton
迭代法的初值，迭代得到更好的位移增量 <span
class="math inline">\(w_{n+1}^{(i+1)}\)</span>： <span
class="math display">\[
\Delta w_{n+1}^{(i+1)} := -\left(
\left. \frac{\mathrm{d}g}{\mathrm{d}w} \right|_{w_{n+1}^{(i)}}
\right)^{-1}  
g( w_{n+1}^{(i)}), \quad
w_{n+1}^{(i+1)} = w_{n+1}^{(i)} + \Delta w_{n+1}^{(i+1)}
\tag{8}
\]</span></p>
<div class="note info no-icon"><h5 id="一般形式的牛顿迭代法">一般形式的牛顿迭代法</h5>
<p>我们可以将式 (8) 写成更一般的形式,
系统内力与外力在每一个增量步都应保持平衡: <span class="math display">\[
f^{\mathrm{int}}(\sigma(\varepsilon)) - f^{\mathrm{ext}}_{i} \equiv 0,
\quad i = 1,2,\ldots
\]</span> 内力通过应力得到, 应力通过本构关系与应变相关联. 定义系统第
<span class="math inline">\(i\)</span> 步的残差函数为 <span
class="math display">\[
r_{i}(\varepsilon) \triangleq f^{\mathrm{int}}(\sigma(\varepsilon)) -
f^{\mathrm{ext}}_{i}, \quad i = 1,2,\ldots
\]</span> 在第 <span class="math inline">\(n\)</span>
个增量步时系统内外力达到平衡: <span class="math display">\[
f^{\mathrm{int}}(\sigma(\varepsilon_n)) - f^{\mathrm{ext}}_n =0
\]</span> 在第 <span class="math inline">\(n+1\)</span> 个增量步时,
系统外力为 <span class="math inline">\(f^{\mathrm{ext}}_{n+1}\)</span>,
为求得使内外力平衡的 <span
class="math inline">\(\varepsilon_{n+1}\)</span>, 将残差函数在 <span
class="math inline">\(\varepsilon_n\)</span> 处展开 <span
class="math display">\[
r_{n+1}(\varepsilon_n + \delta \varepsilon)
\sim r_{n+1}(\varepsilon_n)
+ \left.\frac{\partial r_{n+1}}{\partial
\varepsilon}\right|_{\varepsilon_n} \delta \varepsilon
\]</span> 并令上式等于 0, 这就得到关于 <span
class="math inline">\(\delta \varepsilon\)</span>​ 的线性方程: <span
class="math display">\[
r_{n+1}(\varepsilon_n)
+ \left.\frac{\partial r_{n+1}}{\partial
\varepsilon}\right|_{\varepsilon_n} \delta \varepsilon = 0
\tag{$\star$}
\]</span> 在 ABAQUS 中写本构时, 程序会提供应变增量 <span
class="math inline">\(\Delta \varepsilon\)</span> (对应式 (<span
class="math inline">\(\star\)</span>) 中的 <span
class="math inline">\(\varepsilon_n\)</span>), 并要求用户返回应力增量
<span class="math inline">\(\Delta \sigma\)</span> (用于计算 <span
class="math inline">\(r_{n+1}\)</span>) 和切线刚度模量 <span
class="math inline">\(\partial \Delta \sigma / \partial \Delta
\varepsilon\)</span> (用于计算 <span
class="math inline">\(\left.{\partial r_{n+1}}/{\partial
\varepsilon}\right|_{\varepsilon_n}\)</span>)
以及非线性本构要用到的状态变量. 这样 ABAQUS 内部得到 <span
class="math inline">\(\delta \varepsilon\)</span>,
并进行下一步的迭代</p>
</div>
<p>我们可以通过如下公式衡量迭代算法的收敛速度。如果方程在前后两次迭代步的残差满足
<span class="math display">\[
\frac{|g( w_{n+1}^{(i+1)})|}{|g( w_{n+1}^{(i)})|^M} \approx \text{Const}
\]</span> 那么该迭代算法收敛速度是 <span
class="math inline">\(M\)</span>
阶的。也就是说，每次迭代的残差与前一次迭代的 <span
class="math inline">\(M\)</span>
次方在量级上保持一致。例如在本问题中，收敛残差比值打印出的结果为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.009203</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.030338</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.064449</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.066711</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.099625</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">0.099167</span></span><br><span class="line">The error convergence of e_&#123;<span class="built_in">i</span>+<span class="number">1</span>&#125;/e_&#123;<span class="built_in">i</span>&#125;^<span class="number">2</span> is <span class="number">73.914835</span></span><br></pre></td></tr></table></figure>
<p>所以算法（8）是平方收敛的（最后一步是因为达到了计算机浮点数精度）。这个算法的收敛速度是很快的，例如当初值残差是
<code>E-01</code> 量级的，而计算机浮点数精度为
<code>E-16</code>。那么对于平方收敛算法，只需要迭代 <span
class="math display">\[
\left( \left( \left( \left( \square^{-1} \right)^2 \right)^2 \right)^2
\right)^2 = \square^{-16}
\]</span> <strong>4</strong>
次就可以收敛到浮点数的精度！但是，需要指出的是，算法（8）的每一次迭代过程中，都需要重新计算
<span class="math inline">\(\left( \left.
\frac{\mathrm{d}g}{\mathrm{d}w} \right|_{w_{n+1}^{(i)}}
\right)^{-1}\)</span>​，所以才能达到
平方阶的收敛速度。在本算例中可能无法体现出计算切线刚度矩阵的难度（本例切线刚度矩阵为标量），但对于更复杂的非线性系统，计算切线刚度矩阵是非常消耗时间的。</p>
<p>不过，保证收敛的迭代算法并<strong>不是唯一的</strong>。我们可以放松对收敛速度的要求，降低计算切线刚度矩阵的难度。一种方法是，在计算得到第一次迭代时计算得到的切线刚度矩阵后，将它作为后续迭代中刚度矩阵的近似：
<span class="math display">\[
\Delta w_{n+1}^{(i+1)} = -\left(
\left. \frac{\mathrm{d}g}{\mathrm{d}w} \right|_{
w_{n+1}^\textcolor{red}{(0)} }
\right)^{-1}  
g( w_{n+1}^{(i)}), \quad
w_{n+1}^{(i+1)} = w_{n+1}^{(i)} + \Delta w_{n+1}^{(i+1)}
\tag{9}
\]</span>
算法（9）的收敛速度没有算法（8）速度那么快。例如算例在使用算法（9）时的一个加载步的迭代过程为：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Current load step: <span class="number">1</span> </span><br><span class="line">Current iteration step: <span class="number">1</span>; The out of balance force is <span class="number">9.5086E-02</span></span><br><span class="line">Current iteration step: <span class="number">2</span>; The out of balance force is <span class="number">6.0843E-03</span></span><br><span class="line">Current iteration step: <span class="number">3</span>; The out of balance force is <span class="number">3.9566E-04</span></span><br><span class="line">Current iteration step: <span class="number">4</span>; The out of balance force is <span class="number">2.5756E-05</span></span><br><span class="line">Current iteration step: <span class="number">5</span>; The out of balance force is <span class="number">1.6768E-06</span></span><br><span class="line">Current iteration step: <span class="number">6</span>; The out of balance force is <span class="number">1.0916E-07</span></span><br><span class="line">Current iteration step: <span class="number">7</span>; The out of balance force is <span class="number">7.1064E-09</span></span><br><span class="line">Current iteration step: <span class="number">8</span>; The out of balance force is <span class="number">4.6264E-10</span></span><br><span class="line">Current iteration step: <span class="number">9</span>; The out of balance force is <span class="number">3.0118E-11</span></span><br><span class="line">Current iteration step: <span class="number">10</span>; The out of balance force is <span class="number">1.9611E-12</span></span><br><span class="line">Current iteration step: <span class="number">11</span>; The out of balance force is <span class="number">1.2745E-13</span></span><br></pre></td></tr></table></figure>
<p>算法（8）和（9）在每一个加载步的迭代过程可以用下图清晰地表示出来：</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161457984切线刚度矩阵.png" alt="sln_iteration" style="zoom:40%;" /></div><div class="group-picture-column"><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161456503切线刚度矩阵.png" alt="sln_same_slope" style="zoom: 20%;" /></div></div></div>
<p>切线刚度矩阵可以使用近似值，这会影响迭代收敛的速度，但一般不会影响迭代收敛到准确值的精度。但是，残差
<span class="math inline">\(g( w_{n+1}^{(i)})\)</span>
的计算结果<strong>必须是准确的</strong>。如果系统的内力与外力计算误差太大，那么无论怎样提高切线刚度矩阵的精度，或者增加迭代的次数，或者减小增量步的步长，都不会得到正确的计算结果！</p>
<p>最终，我们给出在使用增量步，并对每一个增量步的结果进行 Newton
迭代，使得内力等于外载后得到的数值计算结果：</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404161503122最终数值结果.png" alt="sln_inc_iter" style="zoom: 67%;" /></p>
<p>从上图可以看到，如果在非线性计算中</p>
<ul>
<li>减小增量步的步长；</li>
<li>在每一个增量步进行迭代，使得残差小于某一个阈值</li>
</ul>
<p>那么就能够得到相当不错的结果。</p>
]]></content>
      <categories>
        <category>有限元方法</category>
      </categories>
      <tags>
        <tag>增量步</tag>
        <tag>迭代步</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT 方法求解单胞问题</title>
    <url>/mech/multiscale/FFT-%E6%96%B9%E6%B3%95%E6%B1%82%E8%A7%A3%E5%8D%95%E8%83%9E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>参考文献：MOULINEC H, SUQUET P. A numerical method for computing the
overall response of nonlinear composites with complex
microstructure[J/OL]. Computer Methods in Applied Mechanics and
Engineering, 1998, 157(1-2): 69-94. DOI:<span class="exturl" data-url="aHR0cHM6Ly9kb2kub3JnLzEwLjEwMTYvUzAwNDUtNzgyNSg5NykwMDIxOC0x">10.1016/S0045-7825(97)00218-1<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="力学列式">力学列式</h2>
<p>对于非均质线弹性材料，其模量为 <span
class="math inline">\(\mathbb{L}:Y \mapsto
\mathbb{S}^4\)</span>，单胞上的应变与应力为 <span
class="math inline">\(\varepsilon, \sigma:Y \mapsto
\mathbb{S}^2\)</span>，在单胞上满足无体力的平衡方程： <span
class="math display">\[
\nabla \cdot \sigma = 0
\tag{1}
\]</span> 以及线弹性本构方程 <span class="math display">\[
\sigma = \mathbb{L} : \varepsilon
\tag{2}
\]</span> 引入一个参考均质模量 <span class="math inline">\(\mathbb{L}^0
\in \mathbb{S}^2\)</span>，并定义 <span class="math display">\[
\delta \mathbb{L} \triangleq \mathbb{L}- \mathbb{L}^0
\]</span> 以及极化应力 <span class="math inline">\(p:Y \mapsto
\mathbb{S}^2\)</span> <span class="math display">\[
p \triangleq \delta \mathbb{L}:\varepsilon
\]</span> <span id="more"></span>代入本构方程（2）中得到 <span
class="math display">\[
\sigma = p + \mathbb{L}^{0}:\varepsilon
\]</span> 为了定解上述方程，我们将应变 <span
class="math inline">\(\varepsilon(x)\)</span> 分解为远场处的常值应变
<span class="math inline">\(\varepsilon_0 \in \mathbb{S}^2\)</span>
和满足周期性边界条件的应变扰动 <span
class="math inline">\(\tilde{\varepsilon}:\Omega \mapsto
\mathbb{S}^2\)</span> ： <span class="math display">\[
\varepsilon \triangleq \tilde{\varepsilon} + \varepsilon^0
\]</span> 由此得到 <span class="math display">\[
\sigma = p + \mathbb{L}^{0}:\tilde{\varepsilon} +
\mathbb{L}^{0}:\varepsilon^{0}
\]</span> 再代入到平衡方程（1）中得到 <span class="math display">\[
\nabla \cdot  \left( \mathbb{L}^{0}:\tilde{\varepsilon} \right) + \nabla
\cdot p = 0
\]</span> 写成关于位移 <span class="math inline">\(u:Y \mapsto
\mathbb{R}^3\)</span> 的分量形式 <span class="math display">\[
L_{ijkl}^0 \tilde{u}_{k,lj} + p_{ij,j} = 0
\tag{3}
\]</span> 若求得偏微分方程的基本解 <span class="math display">\[
L_{ijkl}^0 G_{nk,lj}(x-x^{\prime}) + \delta_{in} \delta(x-x^{\prime}) =
0
\]</span> 那么位移场可以表示为基本解和极化应力的卷积形式。对式（3）进行
Fourier 变换得到 <span class="math display">\[
\xi_j\xi_l L_{ijkl}^{0}~ \hat{\tilde u}_{k}(\xi) = i\xi_j~
\hat{p}_{ij}(\xi)
\tag{4}
\]</span> 这里用到的 Fourier 变换定义为 <span class="math display">\[
\mathscr{F}[f(x)](\xi) = \hat{f}(\xi) \triangleq
\int_{\mathbb{R}^3} f(x) e^{-i \xi \cdot x} \mathrm{d}x
\]</span> 以及相应的 Fourier 逆变换 <span class="math display">\[
\mathscr{F}^{-1}[f(\xi)](x) = \check{f}(\xi) \triangleq
\frac{1}{(2\pi)^3}\int_{\mathbb{R}^3} f(\xi) e^{i \xi \cdot x}
\mathrm{d}\xi
\]</span> 定义关于代数方程（4）的系数矩阵以及其它相关量 <span
class="math display">\[
K_{ik} \triangleq \xi_j\xi_l L_{ijkl}, \quad
N_{ik} \triangleq \mathrm{adj}(K_{ik}), \quad
D \triangleq \det(K_{ik})
\]</span> 由此方程（4）的解可以表示为 <span class="math display">\[
\hat{\tilde u}_{k}=  i\xi_j~ D^{-1} N_{ki} \hat{p}_{ij}
\]</span></p>
<p>为了接下来可以得到具有对称性的算子，我们利用 <span
class="math inline">\(\hat{p}_{ij}\)</span> 的对称性将上式写为 <span
class="math display">\[
\hat{\tilde u}_{k} =  \frac{i}{2}~ D^{-1}
\left( \xi_j N_{ki} + \xi_i N_{kj} \right)
\hat{p}_{ij}
\]</span> 所以应变扰动 <span
class="math inline">\(\tilde{\varepsilon}\)</span> 的 Fourier 变换为
<span class="math display">\[
\hat{\tilde\varepsilon}_{ij} = \frac{i}{2} (\xi_i \hat{\tilde u}_{j} +
\xi_j \hat{\tilde u}_{i})
= - \frac{1}{4} D^{-1}
\left( \xi_l N_{ik} + \xi_k N_{il} + \xi_l N_{jk} + \xi_k N_{jl} \right)
\hat{p}_{kl}
\tag{5}
\]</span>
因此我们通过上式将极化应力与应变扰动相关联。为了写成更简洁的形式，定义
<span class="math inline">\(\hat{\Gamma}_{ijkl}\)</span> 为 <span
class="math display">\[
\hat{\Gamma}_{ijkl} \triangleq \frac{1}{4} D^{-1}
\left( \xi_l N_{ik} + \xi_k N_{il} + \xi_l N_{jk} + \xi_k N_{jl} \right)
\]</span> 所以式（5）可以写成如下更加紧凑的形式： <span
class="math display">\[
\hat{\tilde\varepsilon}_{ij}
= - \hat{\Gamma}_{ijkl} \hat{p}_{kl}
\]</span> 或者写成卷积的形式： <span class="math display">\[
\tilde\varepsilon_{ij}
= - \Gamma_{ijkl} * p_{kl}
\]</span> 最终我们得到关于应变 <span
class="math inline">\(\varepsilon\)</span> 的积分方程： <span
class="math display">\[
\varepsilon_{ij} = \varepsilon_{ij}^{0} - \Gamma_{ijkl} * (\delta
L_{klmn} \varepsilon_{mn})
\]</span></p>
<p>若参考材料为各项同性，其 Lame 系数和剪切模量分别为 <span
class="math inline">\(\lambda^0\)</span> 和 <span
class="math inline">\(\mu^0\)</span>，那么可以显式地写出相空间中 <span
class="math inline">\(\hat{\Gamma}_{ijkl}^0\)</span>： <span
class="math display">\[
\hat{\Gamma}_{ijkl}^{0}
=\frac{1}{4 \mu^0|\xi|^2}
\left(\delta_{ik} \xi_j \xi_l + \delta_{il} \xi_j \xi_k
+\delta_{jk} \xi_i \xi_l + \delta_{jl} \xi_i \xi_k \right)
-\frac{\lambda^0+\mu^0}{\mu^0\left(\lambda^0+2 \mu^0\right)}
\frac{\xi_i \xi_j \xi_k \xi_l}{|\xi|^4} .
\]</span></p>
<h2 id="算法">算法</h2>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: right;">初始化</td>
<td><span class="math inline">\(\varepsilon^{(0)}(x) = \varepsilon^0,
\quad \sigma^{(0)}(x) = \mathbb{L}(x):\varepsilon^{(0)}(x), \quad
\forall x \in Y\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">第 <span
class="math inline">\(i+1\)</span> 次迭代</td>
<td>已知 <span class="math inline">\(\varepsilon^{(i)}\)</span> 与 <span
class="math inline">\(\sigma^{(i)}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">(a)</td>
<td><span class="math inline">\(p^{(i)}(x) = \sigma^{(i)}(x) -
\mathbb{L}_0 : \varepsilon^{(i)}(x)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">(b)</td>
<td><span class="math inline">\(\hat{p}^{(i)} =
\mathscr{F}[p^{(i)}]\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">(c)</td>
<td>收敛性测试，<span class="math inline">\(e^{(i)} &lt;
\mathrm{Tol}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">(d)</td>
<td><span class="math inline">\(\hat{\varepsilon}^{(i+1)}(\xi) =
-\hat{\Gamma}^{0}(\xi):\hat{p}^{(i)}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">(e)</td>
<td><span class="math inline">\(\varepsilon^{(i+1)}(\xi) =
\mathscr{F}^{-1}[\hat{\varepsilon}^{(i+1)}(\xi)]\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">(f)</td>
<td><span class="math inline">\(\sigma^{(i+1)} =
\mathbb{L}(x):\varepsilon^{(i+1)}(x)\)</span></td>
</tr>
</tbody>
</table>
<p>当得到的应力场 <span class="math inline">\(\sigma^{(i+1)}\)</span>
满足平衡方程时算法收敛，因此检验算法收敛性的误差公式为 <span
class="math display">\[
e^{(i)} = \frac{\left( \langle \| \nabla \cdot \sigma^{(i)} \|^2 \rangle
\right)^{\frac{1}{2}}}
{\langle \| \sigma^{(i)} \| \rangle}
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Fourier 方法分析 Hashin-Shtrikman 变分原理</title>
    <url>/mech/multiscale/Fourier-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90-Hashin-Shtrikman-%E5%8F%98%E5%88%86/</url>
    <content><![CDATA[<p>Hashin-Shtrikman 变分原理中给出的泛函表达式为 <span
class="math display">\[
U^p (p_{ij}, \widetilde\varepsilon_{ij})
= \underbrace{\frac{1}{2}\int \bar\sigma_{ij}
\bar\varepsilon_{ij}\mathrm{d} y}_{\triangleq \bar U}
+ \underbrace{\frac{1}{2} \int p_{ij}(y) \widetilde\varepsilon_{ij}(y)
\mathrm{d} y}_{\triangleq \widetilde U}
- \frac{1}{2} \int \left( p_{ij}(y)~\delta L_{ijkl}^{-1}(y)~p_{kl}(y) -
2p_{ij}(y) \bar\varepsilon_{ij}\right)  \mathrm{d} y
\]</span> <span id="more"></span>对二阶张量进行 dev 分解 <span
class="math display">\[
\begin{aligned}
p_{ij} &amp;= p \delta_{ij} + f_{ij} \\
\bar\varepsilon_{ij} &amp;= \bar\varepsilon \delta_{ij} + \bar e_{ij}
\end{aligned}
\]</span> 代入到泛函表达式当中 <span class="math display">\[
U^p = \bar U + \widetilde U - \frac{1}{2} \int
\left(\frac{p^2}{K-K^0} + \frac{f_{ij} f_{ij}}{2(G-G^0)}
-6 p \bar\varepsilon-2 f_{i j} \bar e_{i j}\right) \mathrm{d} y
\]</span> 我们希望得到使用极化应力表示的 <span
class="math inline">\(\widetilde U\)</span> 项表达式, 但是 <span
class="math inline">\(\widetilde U\)</span>
项考量的是极化应力与应变扰动量之间的相互作用, 所以包含未知量 <span
class="math inline">\(\widetilde \varepsilon_{ij}\)</span>​. 幸运的是,
我们考察的 <span class="math inline">\(\widetilde U\)</span> 是能量项,
而根据 Fourier 分析中的 Parseval 公式,
在相空间中的能量内积等于物理空间中的能量内积: <span
class="math display">\[
\widetilde U = \frac{1}{2} \int p_{ij}(y) \widetilde \varepsilon_{ij}(y)
~\mathrm{d} y
\equiv \frac{1}{2} \int \widehat p_{ij}(\xi)
\widehat{\widetilde{u}}_{i,j}^{*}(\xi) ~\mathrm{d} \xi
\tag{0}
\]</span> 并且, 在 Fourier 变换下, 可以找到应变与极化应力的代数表达式.
式 (0) 中, <span class="math inline">\(\widehat{p}_{ij}\)</span>, <span
class="math inline">\(\widehat{\widetilde{u}}_{i,j}\)</span> 表示场变量
<span class="math inline">\(p_{ij}\)</span>, <span
class="math inline">\(\widetilde{u}_{i,j}\)</span> 的 Fourier 变换,
<span class="math inline">\(\square^{*}\)</span>​ 表示共轭复数, 三维的
Fourier 变换定义为</p>
<p><span class="math display">\[
\mathscr{F}[f(y)](\xi) \triangleq \left( \frac{1}{2 \pi} \right)^{3/2}
\int_{\mathbb{R}^3} f(y) e^{-i \xi \cdot y} \mathrm{d} y
\]</span></p>
<p>我们现在希望找到相空间中 <span
class="math inline">\(\widehat{p}_{ij}\)</span>, <span
class="math inline">\(\widehat{\widetilde{u}}_{i,j}\)</span> 之间的关系,
不过首先给出单胞上所满足的微分方程的 statement. 单胞上的控制方程为 <span
class="math display">\[
\left( L_{ijkl}^{0} \widetilde \varepsilon_{kl} + \widetilde p_{ij}
\right)_{,j} = 0
\tag{1}
\]</span> 以及小变形的几何方程 <span class="math display">\[
\widetilde \varepsilon_{kl} = \frac{1}{2} (\widetilde{u}_{k,l} +
\widetilde{u}_{l,k})
\tag{2}
\]</span> 和齐次位移边界条件: <span class="math display">\[
\widetilde{u}_k(\partial Y) = 0
\tag{3}
\]</span> 方程 (1) 中的 <span
class="math inline">\(\widetilde{p}_{ij}\)</span> 表征极化应力的扰动,
定义为 <span class="math display">\[
\widetilde{p}_{ij} \triangleq p_{ij} - \bar{p}_{ij}
\tag{4}
\]</span> 接下来, 对控制方程 (1) 几何方程 (2) 作 Fourier 变换得到 <span
class="math display">\[
i\xi_j \left( L_{ijkl}^{0} \widehat{ \widetilde{\varepsilon} }_{kl}   +
\widehat{ \widetilde{p} }_{ij} \right) = 0
\]</span> 和 <span class="math display">\[
\widehat{\widetilde{\varepsilon} }_{kl} = \frac{1}{2} i(\xi_l
\widehat{\widetilde{u}}_{k} + \xi_k \widehat{\widetilde{u}}_{l})
\]</span> 将各向同性材料的弹性模量 <span class="math display">\[
L_{ijkl}^{0} = \lambda^0 \delta_{ij} \delta_{kl} + \mu^{0} \delta_{ik}
\delta_{jl} + \mu^{0} \delta_{il} \delta_{jk}
\]</span> 和应变的 Fourier 表达式代入到控制方程的 Fourier 变换式中,
得到关于 <span class="math inline">\(\widehat{\widetilde{u}}_j\)</span>
的代数方程: <span class="math display">\[
(\lambda^0 + \mu^0) \xi_i \xi_k \widehat{\widetilde{u}}_k + \mu^0 \xi^2
\widehat{\widetilde{u}}_i
= i \xi_j \widehat{\widetilde{p}}_{ij}
\]</span> 式中, <span class="math inline">\(\xi^2 = \xi_{kk}\)</span>.
上述方程左端的系数矩阵为 <span class="math display">\[
A \triangleq \mu^0 \xi^{T} \xi ~\mathbf{I} + (\lambda^0 + \mu^0)\xi
\xi^{T}
= \mu^0 \xi^2 \mathbf{I}
+ (\lambda^0 + \mu^0)
\begin{pmatrix}
\xi_1 \xi_1 &amp; \xi_1 \xi_2 &amp; \xi_1 \xi_3 \\
\xi_2 \xi_1 &amp; \xi_2 \xi_2 &amp; \xi_2 \xi_3 \\
\xi_3 \xi_1 &amp; \xi_3 \xi_2 &amp; \xi_3 \xi_3
\end{pmatrix}
\]</span> 式中, <span class="math inline">\(\mathbf{I}\)</span> 为 3
阶单位矩阵. 对于形式为 <span class="math inline">\(I + \alpha
vv^T\)</span> 的矩阵, 其逆矩阵的形式为 <span class="math inline">\(I +
\beta vv^T\)</span>, 矩阵 <span class="math inline">\(A\)</span>
的逆求解得到 <span class="math display">\[
A^{-1} = \frac{1}{\mu^0} \frac{1}{\xi^2} \mathbf{I}
- \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)}
\frac{1}{(\xi^2)^2} \xi \xi^{T}
\]</span> 所以, <span
class="math inline">\(\widehat{\widetilde{u}}_{i}\)</span>
可以被显式地用 <span
class="math inline">\(\widehat{\widetilde{p}}_{ij}\)</span> 表示为 <span
class="math display">\[
\widehat{\widetilde{u}}_{i} = i \frac{1}{\mu^0} \frac{\xi_k}{\xi^2}
\widehat{\widetilde{p}}_{ik}
- i\frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{\xi_i
\xi_k \xi_l}{(\xi^2)^2} \widehat{\widetilde{p}}_{kl}
\]</span> 根据 Fourier 对导函数的变换规则, 只需要对上式两边乘 <span
class="math inline">\(i \xi_j\)</span>, 就可以得到关于 <span
class="math inline">\(\widehat{\widetilde{u}}_{i,j}\)</span> 的 Fourier
变换 <span class="math display">\[
\widehat{\widetilde{u}}_{i,j} = i \xi_j \widehat{\widetilde{u}}_{i}
= - \frac{1}{\mu^0} \frac{\xi_j\xi_k}{\xi^2}
\widehat{\widetilde{p}}_{ik}
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{\xi_i \xi_j
\xi_k \xi_l}{(\xi^2)^2} \widehat{\widetilde{p}}_{kl}
\]</span></p>
<p>代入到式 (0) 中得到 <span class="math display">\[
\widetilde U
= \frac{1}{2} \int \widehat{\widetilde{p}}_{ij}
\widehat{\widetilde{u}}_{i,j}^{*} ~\mathrm{d} \xi
= \frac{1}{2} \int \left(
- \frac{1}{\mu^0} \frac{\xi_j\xi_k}{\xi^2} \widehat{\widetilde{p}}_{ij}
\widehat{\widetilde{p}}_{ik}^{*}
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{\xi_i \xi_j
\xi_k \xi_l}{(\xi^2)^2} \widehat{\widetilde{p}}_{ij}
\widehat{\widetilde{p}}_{kl}^{*}
\right)~\mathrm{d} \xi
\tag{5}
\]</span> 如果我们假设极化应力是各向同性函数, 也就是说, 极化应力场 <span
class="math inline">\(p_{ij}(y)\)</span> 可以通过函数 <span
class="math inline">\(P_{ij}(r): \mathbb{R} \mapsto
\mathbb{S}^2\)</span> 表示: <span class="math display">\[
\widetilde p_{ij}(y) \equiv \widetilde P_{ij}(|y|)
\]</span> 如果函数在物理空间中是各向同性函数,
那么在相空间中也是各向同性函数 <span class="math display">\[
\widehat{\widetilde{p}}_{ij}(\xi) \equiv
\widehat{\widetilde{P}}_{ij}(|\xi|)
\]</span> 代入到式 (5) 中, 得到用各向同性函数 <span
class="math inline">\(P_{ij}(r)\)</span> 表示的积分 <span
class="math display">\[
2 \widetilde U
= \int \left(
- \frac{1}{\mu^0} \frac{\xi_j\xi_k}{\xi^2}
\widehat{\widetilde{P}}_{ij}(|\xi|)
\widehat{\widetilde{P}}_{ik}^{*}(|\xi|)
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{\xi_i \xi_j
\xi_k \xi_l}{(\xi^2)^2} \widehat{\widetilde{P}}_{ij}(|\xi|)
\widehat{\widetilde{P}}_{kl}^{*}(|\xi|)
\right)~\mathrm{d} \xi
\tag{6}
\]</span> 如果将式 (6) 转换到球坐标系下进行积分 <span
class="math display">\[
\xi_1 = r \sin\theta \cos\phi, \quad
\xi_2 = r \sin\theta \sin\phi, \quad
\xi_3 = r \cos\theta , \quad
\mathrm{d} \xi_1 ~\mathrm{d} \xi_2 ~\mathrm{d} \xi_3
= r^2 \sin \theta ~\mathrm{d} r ~\mathrm{d} \theta ~\mathrm{d} \phi
\]</span> 就可以在积分项中消去关于 <span
class="math inline">\(\xi_i\)</span> 的有理分式, 得到只关于径向微分
<span class="math inline">\(\mathrm{d} r\)</span> 的积分式 <span
class="math display">\[
2 \widetilde U
=  - \frac{1}{\mu^0} \frac{4\pi}{3} \int_{0}^{\infty}
\widehat{\widetilde{P}}_{ij}(r) \widehat{\widetilde{P}}_{ij}^{*}(r) r^2
\mathrm{d} r
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{4\pi}{15}
\int_{0}^{\infty} \left( \widehat{\widetilde{P}}_{mm}(r)
\widehat{\widetilde{P}}_{kk}^{*}(r)
+ 2\widehat{\widetilde{P}}_{ij}(r) \widehat{\widetilde{P}}_{ij}^{*}(r)
\right) r^2 \mathrm{d} r
\tag{7}
\]</span> 式 (7) 已经和最终的结果很接近了!
只要我们能够确定式中的径向积分, 这可以通过 Parseval
等式与物理空间中的能量积分关联为 <span class="math display">\[
\int_{0}^{\infty} \widehat{\widetilde{P}}_{ij}(r)
\widehat{\widetilde{P}}_{ij}^{*}(r) r^2 \mathrm{d} r
= \frac{1}{4\pi} \int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y)
~\mathrm{d}y, \quad
\int_{0}^{\infty} \widehat{\widetilde{P}}_{mm}(r)
\widehat{\widetilde{P}}_{kk}^{*}(r) r^2 \mathrm{d} r
= \frac{9}{4\pi} \int_{Y} \widetilde{p}(y) \widetilde{p}(y) ~\mathrm{d}y
\tag{a}
\]</span> 将式 (4) 代入上式左端项当中, 就得到使用 <span
class="math inline">\(p_{ij}\)</span> 表示的积分表达式: <span
class="math display">\[
\int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y) ~\mathrm{d}y
= \int_{Y}  p_{ij}(y) p_{ij}(y)~\mathrm{d}y
- 2 \bar{p}_{ij} \int_{Y} p_{ij}(y)  ~\mathrm{d}y
+ \bar{p}_{ij}\bar{p}_{ij}
= \int_{Y}  p_{ij}(y) p_{ij}(y)~\mathrm{d}y
- \bar{p}_{ij}\bar{p}_{ij}
\]</span></p>
<p>以及 <span class="math display">\[
\int_{Y} \widetilde{p}(y) \widetilde{p}(y) ~\mathrm{d}y
= \int_{Y}  p(y) p(y)~\mathrm{d}y - \bar{p}^2
\]</span> 将分块常值的极化应力表达式 <span class="math display">\[
p_{ij} := \sum_{\alpha}^{N} p_{ij}^{\alpha} \chi^{\alpha}
\]</span> 以及极化应力的 dev 分解代入式中得到 <span
class="math display">\[
\begin{gathered}
\int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y) ~\mathrm{d}y
= \underbrace{\left( \sum_{\alpha} c^{\alpha} f_{ij}^{\alpha}
f_{ij}^{\alpha} - \bar{f}_{ij}\bar{f}_{ij} \right)}_{\triangleq
\clubsuit}
+ 3\underbrace{\left(\sum_{\alpha} c^{\alpha} (p^{\alpha})^2 - \bar{p}^2
\right)}_{\triangleq \spadesuit}
= \clubsuit + 3\spadesuit \\
\int_{Y} \widetilde{p}(y) \widetilde{p}(y) ~\mathrm{d}y =
\left(\sum_{\alpha} c^{\alpha} (p^{\alpha})^2 - \bar{p}^2 \right) =
\spadesuit
\end{gathered}\tag{b}
\]</span> 最终, 我们代入到式 (7) 中, 得到 <span class="math display">\[
\begin{aligned}
2 \widetilde U
&amp;\stackrel{(a)}{=} - \frac{1}{3\mu^0}
\int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y) ~\mathrm{d}y
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{2}{15}
\int_{Y} \widetilde{p}_{ij}(y) \widetilde{p}_{ij}(y) ~\mathrm{d}y
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{3}{5}
\int_{Y} \widetilde{p}(y) \widetilde{p}(y) ~\mathrm{d}y \\
&amp;\stackrel{(b)}{=} - \frac{1}{3\mu^0} ( \clubsuit + 3\spadesuit )
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{2}{15} (
\clubsuit + 3\spadesuit )
+ \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 + 2\mu^0)} \frac{3}{5}
\spadesuit \\
&amp;= \left(-\frac{1}{3\mu^0} + \frac{\lambda^0 + \mu^0}{\mu^0
(\lambda^0 + 2\mu^0)} \frac{2}{15} \right)\clubsuit
+ \left(-\frac{1}{\mu^0} + \frac{\lambda^0 + \mu^0}{\mu^0 (\lambda^0 +
2\mu^0)}\right)\spadesuit \\
&amp;= \frac{-3\lambda^0 -8\mu^0}{15\mu^0 (\lambda^0 + 2\mu^0)}
\clubsuit
+ \frac{-1}{\lambda^0 + 2\mu^0}\spadesuit
\end{aligned}
\]</span> 如果将 <span class="math display">\[
\lambda^0 = K^0 - \frac{2}{3}\mu^0
\]</span> 代入, 就可以得到 <span class="math display">\[
2 \widetilde U
= \frac{-3 K^0 - 6\mu^0}{5\mu^0 (3 K^0 + 4\mu^0)} \left( \sum_{\alpha}
c^{\alpha} f_{ij}^{\alpha} f_{ij}^{\alpha} - \bar{f}_{ij}\bar{f}_{ij}
\right)
+ \frac{-3}{3 K^0 + 4\mu^0} \left(\sum_{\alpha} c^{\alpha}
(p^{\alpha})^2 - \bar{p}^2 \right)
\tag{$\bigstar$}
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>Fourier 变换</tag>
        <tag>变分原理</tag>
      </tags>
  </entry>
  <entry>
    <title>单胞问题张量 E P 的解析关系</title>
    <url>/mech/multiscale/%E5%8D%95%E8%83%9E%E9%97%AE%E9%A2%98%E5%BC%A0%E9%87%8F%20E%20P%20%E7%9A%84%E8%A7%A3%E6%9E%90%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>参考文献：Fish,Practical multiscaling, chapter 4.3.5</p>
<h2
id="示性函数在单胞分块上的积分运算">示性函数在单胞分块上的积分运算</h2>
<p>Reduced order 假设分块上的物理量是常值，为描述分块常值函数，我们定义
Partition <span class="math inline">\(Y^\alpha\)</span> 上的示性函数
<span
class="math inline">\(\chi^{(\alpha)}(y):Y\mapsto\mathbb{R}\)</span> ：
<span class="math display">\[
\chi^{(\alpha)}(y) \triangleq \begin{cases}
1, \quad y \in Y^{(\alpha)}\\
0, \quad y \notin Y^{(\alpha)}\\
\end{cases}
\]</span> <span id="more"></span>示性函数在单胞 <span
class="math inline">\(Y\)</span> 上的积分等于分块 <span
class="math inline">\(Y^{(\alpha)}\)</span> 的度量： <span
class="math display">\[
|Y^{(\alpha)}| \triangleq \int_{Y} \chi^{(\alpha)}(y) \mathrm{d} y
\equiv \int_{Y^{(\alpha)}} \mathrm{d} y
\]</span> 我们有如下结论： <span class="math display">\[
\int_{Y} \chi^{(\alpha)}(y) \chi^{(\beta)}(y) ~\mathrm{d}y
= \begin{cases}
|Y^{(\alpha)}|, \quad \alpha = \beta \\
0, \quad \quad \quad \alpha \neq \beta
\end{cases}
\]</span> 因此，对于两个分块常值的函数 <span
class="math inline">\(f(y)=\chi^{(\alpha)}(y)f^{(\alpha)}\)</span>，<span
class="math inline">\(g(y)=\chi^{(\alpha)}(y)g^{(\alpha)}\)</span>，它们的乘积在单胞上的积分为
<span class="math display">\[
\begin{aligned}
\int_{Y} f(y)g(y) ~\mathrm{d}y
&amp;= \int_{Y} \sum_{\alpha} \left( \chi^{(\alpha)}(y)f^{(\alpha)}
\right)
\sum_{\beta} \left( \chi^{(\beta)}(y)g^{(\beta)} \right) ~\mathrm{d}y \\
&amp;= \sum_{\alpha} f^{(\alpha)}g^{(\alpha)} \int_{Y}
\chi^{(\alpha)}(y) ~\mathrm{d}y
= \sum_{\alpha} |Y^{(\alpha)}| f^{(\alpha)}g^{(\alpha)}
\end{aligned}
\]</span></p>
<h2 id="张量-mathbbealpha-mathbblalpha-的关系">张量 <span
class="math inline">\(\mathbb{E}^{(\alpha)}\)</span> <span
class="math inline">\(\mathbb{L}^{(\alpha)}\)</span> 的关系</h2>
<p>单胞的弹性模量 <span class="math inline">\(L_{ijkl}(y)\)</span>
可以表示为： <span class="math display">\[
L_{ijkl}(y) = \sum_{\alpha} \chi^{(\alpha)}(y)L_{ijkl}^{(\alpha)}
\tag{1}
\]</span> 式中，<span class="math inline">\(L_{ijkl}^{(\alpha)}\)</span>
表示分块 <span class="math inline">\(Y^{(\alpha)}\)</span>
上的材料弹性模量，我们假设它总是均匀的，也即 <span
class="math inline">\(L_{ijkl}^{(\alpha)} \equiv
\mathrm{const}\)</span>。</p>
<p>宏观尺度的弹性张量 <span class="math inline">\(L_{ijkl}^c\)</span>
定义为： <span class="math display">\[
L_{ijkl}^c \triangleq \frac{1}{|Y|}\int_{Y} L_{ijmn}(y) E_{mn}^{kl}(y)
\mathrm{d} y
\]</span> 将式（1）代入得到 <span class="math display">\[
L_{ijkl}^c = \frac{1}{|Y|} \sum_{\alpha} L_{ijmn}^{(\alpha)} \int_{Y}
\chi^{(\alpha)}(y) E_{mn}^{kl}(y) ~\mathrm{d}y
\tag{2}
\]</span> 定义分块上的应变影响张量 <span
class="math inline">\(E_{mn}^{kl(\alpha)}\)</span> 为 <span
class="math display">\[
E_{mn}^{kl(\alpha)}
\triangleq \frac{1}{|Y^{(\alpha)}|}\int_{Y} \chi^{(\alpha)}(y)
E_{mn}^{kl}(y) ~\mathrm{d} y
\]</span> 以及分块 <span class="math inline">\(\alpha\)</span>
所占的体积分数 <span class="math inline">\(c^{(\alpha)}\)</span>： <span
class="math display">\[
c^{(\alpha)} \triangleq \frac{|Y^{(\alpha)}|}{|Y|}
\]</span> 那么，式（2）就可以表示为 <span class="math display">\[
L_{ijkl}^c = \sum_{\alpha}
c^{(\alpha)}L_{ijmn}^{(\alpha)}E_{mn}^{kl(\alpha)}
\tag{4.119a}
\]</span> 上式对任意的四阶张量 <span
class="math inline">\(L_{ijmn}^{(\alpha)}\)</span>
均成立，特别的，我们选取 <span class="math display">\[
L_{ijmn}^{(\alpha)} = I_{ij}^{mn},\quad 对任意分块 \alpha
\]</span> 式中，$I_{ij}^{kl} $ 为四阶单位张量。那么，式（3）有 <span
class="math display">\[
\sum_{\alpha}c^{(\alpha)}E_{ij}^{kl(\alpha)} = I_{ij}^{kl}
\tag{4.119b}
\]</span> ## 张量 <span
class="math inline">\(\mathbb{E}^{(\alpha)}\)</span> <span
class="math inline">\(\mathbb{P}^{(\alpha \beta)}\)</span>​ 的关系</p>
<p>Fish 的证明是从式（4.41）出发： <span class="math display">\[
\varepsilon_{i j}^{(\beta)}(x)
-\sum_{\alpha} P_{i j}^{k l(\beta \alpha)} \mu_{k l}^{(\alpha)}(x)
=E_{i j}^{k l(\beta)} \varepsilon_{k l}^c(x)
\tag{4.41}
\]</span> 并选取特别情景下的 <span class="math inline">\(\mu_{k
l}^{(\alpha)}(x)\)</span>，使得==分块上的应变与应力均相等（？！）==：
<span class="math display">\[
\begin{aligned}
&amp; \sigma_{i j}^{(\alpha)}:=\sigma_{i j}^c;  \alpha=1,2 \ldots N  \\
&amp; \varepsilon_{i j}^c=:\varepsilon_{i j}^{(\alpha)}=M_{i j k
l}^{(\alpha)} \sigma_{k l}^c+\mu_{i j}^{(\alpha)} ; \alpha=1,2 \ldots N
\\
&amp; \mu_{i j}^{(\alpha)}=\mu_{i j}^c-\left[M_{i j k l}^{(\alpha)}-M_{i
j k l}^c\right] \sigma_{k l}^c
\end{aligned}
\]</span> 然后将上式代入到式（4.41）中，得到 <span
class="math display">\[
\left[E_{i j}^{k l(\beta)}+\sum_{\alpha} P_{i j}^{k l(\beta
\alpha)}-I_{i j k l}\right] \varepsilon_{k l}^c
=\sum_{\alpha} P_{i j}^{k l(\beta \alpha)} M_{k l m n}^{(\alpha)}
\sigma_{m n}^c
\]</span> 再根据宏观应力应变的任意性，就得到 <span
class="math display">\[
\sum_{\beta} P_{kl}^{mn(\alpha\beta)}
+ E_{kl}^{mn(\alpha)}
- I_{kl}^{mn}
= 0, \quad \alpha=1,2,\ldots,N
\tag{4.119c}
\]</span> 和 <span class="math display">\[
\sum_{\beta} P_{ij}^{mn(\alpha\beta)} M_{mnkl}^{(\beta)}
= 0, \quad \alpha=1,2,\ldots,N
\tag{4.119d}
\]</span></p>
<hr />
<p>这里给出另一种推导 P E
张量之间关系的方法，不需要对本征应变做出奇怪的假设。张量场 <span
class="math inline">\(E_{ij}^{kl}\)</span> 与 <span
class="math inline">\(P_{ij}^{kl}\)</span> 分别满足如下微分方程:</p>
<p><span class="math display">\[
\begin{aligned}
\left\{ L_{ijkl}(y) E_{kl}^{mn} \right\}_{,y_j} &amp;= 0, \text{in}~ Y
\\
\left\{ L_{ijkl}(y) \left[ P_{kl}^{mn(\alpha)}(y) -
I_{kl}^{mn}\chi^{(\alpha)}(y) \right] \right\}_{,y_j} &amp;= 0,
\text{in}~ Y \quad \alpha=1,2, \ldots,N
\end{aligned}
\]</span> 我们将上述方程写成弱形式, 对任意满足周期性边界条件的函数 <span
class="math inline">\(v_i\)</span>, 有 <span class="math display">\[
\int_{Y} L_{ijkl}(y) E_{kl}^{mn}(y) v_{i,j}(y) ~\mathrm{d}y = 0
\tag{3}
\]</span> 以及 <span class="math display">\[
\int_{Y} L_{ijkl}(y) \left[ P_{kl}^{mn(\alpha)}(y) -
I_{kl}^{mn}\chi^{(\alpha)}(y) \right] v_{i,j}(y) ~\mathrm{d}y
= 0, \text{in}~ Y \quad \alpha=1,2, \ldots,N
\tag{4}
\]</span> 对式（4）Partition 求和, 得到 <span class="math display">\[
\int_{Y} L_{ijkl}(y) \left[
\sum_{\alpha}\left( P_{kl}^{mn(\alpha)}(y) \right) - I_{kl}^{mn}
\right] v_{i,j}(y) ~\mathrm{d}y
= 0
\tag{5}
\]</span> 式（3）与式（5）相加得到 <span class="math display">\[
\int_{Y} L_{ijkl}(y) \left[
\sum_{\alpha}\left( P_{kl}^{mn(\alpha)}(y) \right)
+ E_{kl}^{mn}(y) - I_{kl}^{mn}
\right] v_{i,j}(y) ~\mathrm{d}y
= 0
\tag{6}
\]</span> 如果选取 test function <span
class="math inline">\(v_i\)</span>​​ 使得每一个 Partition
上的应变都是均匀的, 也即 <span class="math display">\[
v_{i,j}(y) = \sum_{\alpha}\chi^{(\alpha)}(y)v_{i,j}^{(\alpha)}
\]</span> 那么应力分布也是分块均匀的： <span class="math display">\[
\sigma_{kl}(y) = L_{ijkl}(y) v_{i,j}(y) =
\sum_{\alpha}\chi^{(\alpha)}(y) L_{ijkl}^{(\alpha)} v_{i,j}^{(\alpha)} =
\sum_{\alpha}\chi^{(\alpha)}(y) \sigma_{kl}^{(\alpha)}
\]</span> 再代入式（1），那么式（6）就可以写为 <span
class="math display">\[
\sum_{\beta}\sigma_{kl}^{(\beta)}\int_{Y} \chi^{(\beta)}(y) \left[
\sum_{\alpha}\left( P_{kl}^{mn(\alpha)}(y) \right)
+ E_{kl}^{mn}(y) - I_{kl}^{mn}
\right] ~\mathrm{d}y = 0
\tag{7}
\]</span> 如果我们定义 <span class="math display">\[
P_{kl}^{mn(\beta \alpha)} \triangleq \frac{1}{|Y^{(\beta)}|}\int_{Y}
\chi^{(\beta)}(y) P_{kl}^{mn(\alpha)}(y) ~\mathrm{d}y
\]</span> 那么有 <span class="math display">\[
\begin{aligned}
\int_{Y} \chi^{(\beta)}(y)
\sum_{\alpha}\left( P_{kl}^{mn(\alpha)}(y) \right) ~\mathrm{d}y
&amp;= |Y^{(\beta)}|\sum_{\alpha} P_{kl}^{mn(\beta\alpha)}, \\
\int_{Y} \chi^{(\beta)}(y)
E_{kl}^{mn}(y) ~\mathrm{d}y
&amp;= |Y^{(\beta)}| E_{kl}^{mn(\beta)}, \\
\int_{Y} \chi^{(\beta)}(y)
I_{kl}^{mn} ~\mathrm{d}y
&amp;= |Y^{(\beta)}|I_{kl}^{mn}
\end{aligned}
\]</span> 将上式代入到式（7）当中，就会得到关于 <span
class="math inline">\(\sigma_{kl}^{(\beta)}\)</span> 的方程： <span
class="math display">\[
\sum_{\beta}\sigma_{kl}^{(\beta)} |Y^{(\beta)}| \left(
\sum_{\alpha} P_{kl}^{mn(\beta\alpha)}
+ E_{kl}^{mn(\beta)}
- I_{kl}^{mn}
\right) = 0
\]</span> 又因为 <span
class="math inline">\(\sigma_{kl}^{(\beta)}\)</span>
可以任意选取大小，所以上式关于 <span
class="math inline">\(\sigma_{kl}^{(\beta)}\)</span> 的系数都必须等于
0： <span class="math display">\[
\sum_{\alpha} P_{kl}^{mn(\beta\alpha)}
+ E_{kl}^{mn(\beta)}
- I_{kl}^{mn}
= 0, \quad \beta=1,2,\ldots,N
\tag{4.119c}
\]</span> 如果选取 test function <span
class="math inline">\(v_{i,j}\)</span>
为常应变，那么还可以得到如下结论： <span class="math display">\[
\sum_{\alpha} c^{(\alpha)}
\mathbb{L}^{(\alpha)}:(\mathbb{P}^{(\alpha\beta)} - \mathbb{I}) = 0,
\quad \beta=1,2,\ldots,N
\]</span></p>
<h2
id="层级平均应变影响张量和-transformation-influence-tensor-tif">层级平均应变影响张量和
Transformation Influence Tensor (TIF)</h2>
<p>设第 <span class="math inline">\(\alpha\)</span> 块分块分裂为 <span
class="math inline">\(\alpha_1\)</span> 和 <span
class="math inline">\(\alpha_2\)</span>. 这时根据 TIF
和平均应变影响张量的定义,我们有 <span class="math display">\[
\mathbb{E}^{(\alpha)} = \frac{c^{(\alpha_1)}}{c^{(\alpha)}}
\mathbb{E}^{(\alpha_1)}
+ \frac{c^{(\alpha_2)}}{c^{(\alpha)}} \mathbb{E}^{(\alpha_2)}
\]</span> 定义 <span class="math display">\[
c&#39;^{(\alpha_1)} \triangleq \frac{c^{(\alpha_1)}}{c^{(\alpha)}},
\quad
c&#39;^{(\alpha_2)} \triangleq \frac{c^{(\alpha_2)}}{c^{(\alpha)}}
\]</span> 有 <span class="math display">\[
\mathbb{E}^{(\alpha)} = c&#39;^{(\alpha_1)} \mathbb{E}^{(\alpha_1)} +
c&#39;^{(\alpha_2)} \mathbb{E}^{(\alpha_2)}
\]</span> 同样有 <span class="math display">\[
\mathbb{P}^{(\alpha)}(y) = \mathbb{P}^{(\alpha_1)}(y) +
\mathbb{P}^{(\alpha_2)}(y) \Rightarrow \\
\mathbb{P}^{(\beta\alpha)} = \mathbb{P}^{(\beta\alpha_1)} +
\mathbb{P}^{(\beta\alpha_2)}, \alpha \neq \beta \\
\mathbb{P}^{(\alpha\alpha)} = c&#39;^{(\alpha_1)} (
\mathbb{P}^{(\alpha_1\alpha_1)} + \mathbb{P}^{(\alpha_1\alpha_2)} )
+ c&#39;^{(\alpha_2)} ( \mathbb{P}^{(\alpha_2\alpha_1)} +
\mathbb{P}^{(\alpha_2\alpha_2)} )
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>张量运算</tag>
        <tag>解析方法</tag>
      </tags>
  </entry>
  <entry>
    <title>应变集中张量</title>
    <url>/mech/multiscale/%E5%BA%94%E5%8F%98%E9%9B%86%E4%B8%AD%E5%BC%A0%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>[!TIP]</p>
<h5 id="一些记号上的说明">一些记号上的说明</h5>
<p>记号 <span class="math inline">\(\epsilon\)</span> 表示张量应变,
<span class="math inline">\(\varepsilon\)</span> 表示工程应变,
其分量之间的关系为 <span class="math display">\[
\varepsilon_{ij} = \epsilon_{ij}, \quad i=j\\
\varepsilon_{ij} = 2\epsilon_{ij}, \quad i \neq j\\
\]</span> 如果表示成 Voigt 记法, 并定义矩阵 <span
class="math display">\[
[:] \triangleq \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2
\end{pmatrix}
\]</span> 那么, 张量应变与工程应变之间的关系为 <span
class="math display">\[
[\varepsilon] = [:] [\epsilon]
\]</span> 变量右下角的指标总是保留给分量的编号,
其它类型的编号总是放在右上角.</p>
</blockquote>
<h2 id="应变集中张量的定义"><span id="more"></span>应变集中张量的定义</h2>
<p>在给定加载模式下, 宏观应变 <span
class="math inline">\(\bar{\epsilon}\)</span> 已知, 单胞内的每一点的应变
<span class="math inline">\(\epsilon(y)\)</span> 通过应变集中张量 <span
class="math inline">\(A(y)\)</span>（四阶张量）与宏观应变 <span
class="math inline">\(\bar{\epsilon}\)</span> 相关联: <span
class="math display">\[
\epsilon(y) = A(y):\bar{\epsilon}
\tag{1}
\]</span></p>
<p>在多尺度中, 联系宏观与微观尺度应变关系的方程为（Fish, 式（2.37））
<span class="math display">\[
\epsilon_{k l}(x, y)=E_{k l}^{m n}(y) \bar{\epsilon}_{m n}(x)
\tag{2}
\]</span> 式（2）写成张量形式为 <span class="math display">\[
\epsilon(y) = \mathbb{E}(y):\bar{\epsilon}
\tag{3}
\]</span></p>
<h2 id="应变集中张量计算">应变集中张量计算</h2>
<p>宏观应变 <span class="math inline">\(\bar{\epsilon}\)</span>
可以看作是 <span class="math inline">\(\mathcal{S}(\Omega) \mapsto
\mathbb{S}(\Omega)\)</span> 的线性映射: <span class="math display">\[
\bar{\epsilon} \in \mathcal{L}(\mathcal{S}(\Omega),\mathbb{S}(\Omega))
\]</span> 或者省略空间记号 <span class="math inline">\(\bar{\epsilon}
\in \mathcal{L}(\mathcal{S},\mathbb{S})\)</span>. 其中, <span
class="math inline">\(\mathcal{S}(\Omega)\)</span>
为具有<strong>次对称性的四阶张量场空间</strong>, <span
class="math inline">\(\mathbb{S}(\Omega)\)</span>
为<strong>二阶对称张量场空间</strong>, <span
class="math inline">\(\mathcal{L}(\mathcal{S},\mathbb{S})\)</span>
表示所有从 <span class="math inline">\(\mathcal{S}(\Omega)\)</span> 到
<span class="math inline">\(\mathbb{S}(\Omega)\)</span>
的线性映射所组成的集合. 将 <span
class="math inline">\(\mathcal{L}(\mathcal{S},\mathbb{S})\)</span>
中<strong>不依赖于区域坐标 <span class="math inline">\(y \in
\Omega\)</span> 的映射</strong>所组成的子空间记为 <span
class="math inline">\(\bar{\mathcal{L}}(\mathcal{S},\mathbb{S})\)</span>,
子空间的维度等于二阶对称张量独立分量的个数: <span
class="math display">\[
\begin{align}
\dim \bar{\mathcal{L}}(\mathcal{S},\mathbb{S}) = 6,\quad
\text{三维问题}\\
\dim \bar{\mathcal{L}}(\mathcal{S},\mathbb{S}) = 3,\quad
\text{二维问题}\\
\end{align}
\]</span> 以三维空间问题为例, 任意宏观应变 <span
class="math inline">\(\bar{\epsilon}\)</span>
总可以表示为二阶对称张量空间 <span
class="math inline">\(\mathbb{S}\)</span> 中一组基底 <span
class="math inline">\(\bar{\epsilon}_1,\bar{\epsilon}_2,\ldots
,\bar{\epsilon}_6\)</span> 的线性组合. 如果给出与基底对应的应变场 <span
class="math inline">\(\widehat\epsilon^{1}(y), \widehat\epsilon^{2}(y),
\ldots \widehat\epsilon^{6}(y)\)</span>, 那么这六组数据就可以唯一确定
<span class="math inline">\(\widehat{\mathbb{E}}(y) \in
\mathcal{S}(\Omega)\)</span>, 满足 <span class="math display">\[
\widehat\epsilon^\alpha (y) =
\widehat{\mathbb{E}}(y):\bar{\epsilon}^\alpha, \quad \alpha=1,\ldots,6
\]</span> 对于任意的宏观应变 <span
class="math inline">\(\bar{\epsilon}=\sum_{\alpha=1}^{6}\mu^\alpha\bar{\epsilon}^\alpha
\in \bar{\mathcal{L}}(\mathcal{S},\mathbb{S})\)</span>, <span
class="math display">\[
{\epsilon}(y) = \widehat{\mathbb{E}}(y):\bar{\epsilon}=\mu^{\alpha}
\widehat\epsilon^{\alpha}(y)
\]</span></p>
<blockquote>
<p>[!TIP]</p>
<p>在应变集中张量加标记 <span
class="math inline">\(\widehat{\square}\)</span>, 是为了强调, 张量 <span
class="math inline">\(\widehat{\mathbb{E}}(y)\)</span> 依赖于计算 <span
class="math inline">\(\widehat\epsilon^{\alpha}(y)\)</span> 时的条件.
例如, 周期性边界条件和线性位移边界条件得到的计算结果是不一样的.</p>
</blockquote>
<p>接下来, 我们考虑上述运算的矩阵表示. 如果使用 Voigt 记法, <span
class="math inline">\(\mathcal{S} \rightarrow \mathbb{R}^{6 \times
6}\)</span>, <span class="math inline">\(\mathbb{S} \rightarrow
\mathbb{R}^6\)</span>。选取空间 <span
class="math inline">\(\bar{\mathcal{L}}(\mathbb{R}^{6 \times
6},\mathbb{R}^{6})\)</span> 中的基底为 <span class="math display">\[
[\bar{\varepsilon}^1] = (1,0,0,0,0,0)^{T},~ \dots,~
[\bar{\varepsilon}^6] = (0,0,0,0,0,1)^{T}
\]</span> 并计算在给定的宏观应变下, 对应单胞的应变场 <span
class="math inline">\(\widehat\varepsilon^{\alpha}(y),
\alpha=1,\ldots,6\)</span>, 应变场表示为
<code>NIPT</code>×<code>6</code> 的矩阵 <span
class="math inline">\([\widehat\varepsilon^\alpha]\)</span>,
<code>NIPT</code> 表示单胞积分点的总数. 那么, 对于任何用 Voigt
记法表示的宏观应变 <span
class="math inline">\([\bar{\varepsilon}]\)</span>,
单胞上的应变场可以表示为 <span class="math display">\[
[\varepsilon]_{\mathrm{NIPT} \times 6}
= \sum_{\alpha=1}^{6} \bar{\varepsilon}^{\alpha}
[\widehat\varepsilon^{\alpha}]_{\mathrm{NIPT} \times 6}
\tag{4}
\]</span> 如果将式 (3) 表示成矩阵形式, 就得到任意积分点上的应变为 <span
class="math display">\[
[\epsilon(y^{ipt})] = [\mathbb{E}(y^{ipt})][:][\bar{\epsilon}], \quad
\forall y^{ipt}
\tag{5}
\]</span></p>
<p>因为张量应变和工程应变的关系为 <span class="math display">\[
[:][\bar{\epsilon}] = [\bar{\varepsilon}]
\]</span> 式 (5) 左右两端左乘 <span class="math inline">\([:]\)</span>
得到 <span class="math display">\[
[\varepsilon(y^{ipt})]_{6\times 1}  = [:][\mathbb{E}(y^{ipt})]_{6\times
6}
[\bar{\varepsilon}]_{6\times1}, \quad \forall y^{ipt}
\tag{6}
\]</span> 式 (4) 给出的积分点上的应变是 <code>1</code>x<code>6</code>
的行向量, 为了得到类似于式 (4) 的形式, 需要将 $[:][(y^{ipt})]_{6} $
“切成” 6 个行向量, 并按照积分点顺序排列所有行, 因此,
应变影响张量的矩阵表示是一个 <span class="math inline">\({\mathrm{NIPT}
\times 36}\)</span> 的矩阵.</p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>细观力学</tag>
        <tag>应变集中张量</tag>
      </tags>
  </entry>
  <entry>
    <title>使用有限元方法求解单胞方程</title>
    <url>/mech/multiscale/%E4%BD%BF%E7%94%A8%E6%9C%89%E9%99%90%E5%85%83%E6%96%B9%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E5%BC%B9%E6%80%A7%E5%8D%95%E8%83%9E%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="单胞方程的-statement">单胞方程的 statement</h2>
<h3 id="单胞方程张量场-e_klmn-求解">单胞方程张量场 <span
class="math inline">\(E_{kl}^{(mn)}\)</span> 求解</h3>
<p>在三维情景, 线弹性条件下, 单胞方程的弱形式为: <span
class="math display">\[
\int_{\Theta} L_{ijkl} \frac{\partial H_k^{(mn)}}{\partial y_l}
\frac{\partial v_i}{\partial y_j} \mathrm{d} y
= -\int_{\Theta} L_{ij(mn)} \frac{\partial v_i}{\partial y_j} \mathrm{d}
y.
\tag{1}
\]</span></p>
<p>场变量 <span class="math inline">\(H_k^{(mn)}\)</span>
满足周期性边界条件. <span id="more"></span></p>
<blockquote>
<p>[!NOTE]</p>
<p>在单胞方程中, <span class="math inline">\((mn)\)</span>
是对称的自由指标, 使用 <span class="math inline">\(()\)</span> 标注指标
<span class="math inline">\(mn\)</span>
是因为该组指标表示单胞可能的变形模式 (对于三维问题共有 6 种模式,
每一种模式确定一组偏微分方程).</p>
</blockquote>
<p>求解出 <span class="math inline">\(H_{k}^{(mn)}\)</span> 后,
可得到均质化的弹性模量为: <span class="math display">\[
L_{ij(mn)}^{\mathrm{hom}} = \frac{1}{|\Theta|} \int_{\Theta} L_{ij(mn)}
+ L_{ijkl}H_{k,l}^{(mn)} \mathrm{d} y.
\tag{2}
\]</span></p>
<p>式中，<span class="math inline">\(H_{k,l}^{(mn)} = \frac{\partial
H_{k}^{(mn)}}{\partial y_l}\)</span>​ 。如果记 <span
class="math display">\[
E_{kl}^{(mn)} \triangleq I_{kl}^{(mn)} + H_{k,l}^{(mn)}
\]</span> 式中, <span
class="math inline">\(I_{kl}^{(mn)}=\frac{1}{2}(\delta_{km}\delta_{ln}+\delta_{kn}\delta_{lm})\)</span>,
那么式 (2) 可以表示为 <span class="math display">\[
L_{ij(mn)}^{\mathrm{hom}} = \frac{1}{|\Theta|} \int_{\Theta}
L_{ijkl}E_{kl}^{(mn)} \mathrm{d} y.
\]</span></p>
<h3 id="reduced-order-单胞方程张量场-p_klmn-求解">Reduced Order
单胞方程张量场 <span class="math inline">\(P_{kl}^{mn}\)</span>
求解</h3>
<p>降阶多尺度的单胞方程弱形式为 <span class="math display">\[
\int_{\Theta} L_{ijkl}(y)  P_{kl}^{mn(\alpha)}(y) v_{i,j}(y)
~\mathrm{d}y
= \int_{\Theta} L_{ijmn}(y) \chi^{(\alpha)}(y) v_{i,j}(y) ~\mathrm{d}y
\quad \alpha=1,2, \ldots,N
\tag{3}
\]</span></p>
<p>方程 (1) (3) 的区别在于右端项的积分区域，以及正负号。式 (3) 右端对
partition 求和，可以得到式 (1) 的右端项 (相差一个负号) 。方程 (3)
的边界条件与 (1) 相同。</p>
<h2 id="单胞方程的有限元列式">单胞方程的有限元列式</h2>
<p>将单胞方程中的张量分量表示为矩阵形式:</p>
<p><span class="math display">\[
L_{ijkl}(y) \rightarrow [\mathbf{D}](y), \quad
\frac{\partial v_i}{\partial y_j} \rightarrow [\mathbf{B}][v], \quad
\frac{\partial H_k^{(I)}}{\partial y_l} \rightarrow
[\mathbf{B}][u]^{(I)}, \quad
L_{ij(I)}(y) \rightarrow [\mathbf{D}](y) [\varepsilon]^{(mn)}.
\]</span></p>
<p>式中, <span class="math inline">\(mn =
\{11,22,33,23,13,12\}\)</span>. 为方便表示向量分量, 我们使用 Voigt 映射
<span class="math inline">\((\cdot)\)</span> 将二元组 <span
class="math inline">\((mn)\)</span> 映射为一元有序数列 <span
class="math inline">\(\{ 1,2,3,4,5,6 \}\)</span>. <span
class="math inline">\([\varepsilon]^{(mn)}\)</span> 为 <span
class="math inline">\(6\times 1\)</span> 向量, 对应 <span
class="math inline">\((mn)\)</span> 分量为 1, 其它分量为 0. 例如, 当
<span class="math inline">\(mn=11\)</span> 时,
对应的有限元矩阵方程为:</p>
<p><span class="math display">\[
\int_{Y} [B]^{T} [D](y) [B] \mathrm{d} Y [u]^{(11)} = \int_{Y}
[B]^{T}[D](y) [\varepsilon]^{(11)} \mathrm{d} Y.
\]</span></p>
<p>式中, <span class="math inline">\([\varepsilon]^{(11)} =
[1,0,0,0,0,0]^{T}\)</span>. 记</p>
<p><span class="math display">\[
\int_{Y} [B]^{T} [D](y) [B] \mathrm{d} Y = [K], \quad
\int_{Y} [B]^{T}[D](y) [\varepsilon]^{(11)} \mathrm{d} Y = [f]^{(11)},
\]</span></p>
<p>则有线性方程组</p>
<p><span class="math display">\[
[K][u]^{(11)} = [f]^{(11)},
\]</span></p>
<p>以及周期性边界条件对边界节点的约束方程</p>
<p><span class="math display">\[
[C_{\mathrm{per}}][u]^{(11)} = [0]
\]</span></p>
<p>和单位平均应变导致的位移边界条件</p>
<p><span class="math display">\[
[C_{\mathrm{disp}}]^{(11)}[u]^{(11)} = [g].
\]</span></p>
<p>注意, 约束矩阵 <span
class="math inline">\([C_{\mathrm{per}}]\)</span> 与变形模式 <span
class="math inline">\(mn\)</span> 无关.</p>
<p>如果考虑材料坐标系, 那么, 在材料坐标系下表示的材料模量 <span
class="math inline">\([\mathrm{D}&#39;]\)</span>,
需要通过四阶张量的旋转得到宏观坐标系下 <span
class="math inline">\([\mathrm{D}]\)</span>: <span
class="math display">\[
L_{ijkl} = L&#39;_{mnrs} A_{mi} A_{nj} A_{rk} A_{sl}
\]</span> 在求解有限元方程之后,
得到的是宏观坐标系下的均质化之后的材料刚度矩阵.</p>
<p>求解 6 组变形模式下的有限元方程, 得到 <span
class="math inline">\([u]^{(mn)}\)</span> 后,
再代入到均质化弹性张量方程中:</p>
<p><span class="math display">\[
[D^{\mathrm{hom}}] [\varepsilon]^{(mn)} = \frac{1}{|Y|} \int_{Y} [D](y)
[\varepsilon]^{(mn)} - [D](y)[B][u]^{(mn)} \mathrm{d} Y.
\]</span></p>
<p>若记</p>
<p><span class="math display">\[
[\overline{D}] = \frac{1}{|Y|} \int_{Y} [D](y)\mathrm{d} Y, \quad
[\sigma]^{(mn)} = \frac{1}{|Y|} \int_{Y} [D](y)[B] \mathrm{d}
Y~[u]^{(mn)},
\]</span></p>
<p>则有</p>
<p><span class="math display">\[
[D^{\mathrm{hom}}] = [\overline{D}] - [\sigma^{(11)}, \sigma^{(22)},
\sigma^{(33)}, \sigma^{(23)}, \sigma^{(13)}, \sigma^{(12)}].
\]</span></p>
<p>式中, <span class="math inline">\(\sigma^{(mn)}\)</span>
是由有限元求解的位移场 <span class="math inline">\(u^{(mn)}\)</span>
计算得到应力场, 再求体平均得到. 对于只有纤维和基体两相材料的单胞,
如果它们的体积分数分别为 <span class="math inline">\(c_{f}\)</span> 和
<span class="math inline">\(c_{m}\)</span>, 体平均材料矩阵 <span
class="math inline">\([\overline{D}]\)</span> 等于</p>
<p><span class="math display">\[
[\overline{D}] = \frac{1}{|Y|} \int_{Y} [D](y)\mathrm{d} Y = c_f [D_f] +
c_m [D_m].
\]</span></p>
<p>式中, <span class="math inline">\([D_f]\)</span> 和 <span
class="math inline">\([D_m]\)</span>
分别为纤维和基体材料的弹性模量矩阵.</p>
<p>各个分块上的 E P 张量, 分别对应求解之后的应变场在分块上的平均, 因此 E
P 张量的数值形式都是宏观坐标系下的张量. 此外对</p>
<h2 id="单胞方程的求解">单胞方程的求解</h2>
<p>使用有限元方法求解单胞方程需要解决如下问题:</p>
<ol type="1">
<li><strong>生成周期性边界的网格</strong>. 比如三维单胞问题, 左右, 前后,
上下面的网格节点要<strong>完全一致</strong>,
这样才能施加周期性边界条件</li>
<li><strong>施加周期性边界条件</strong>. 周期性边界条件包含两部分:
<ol type="1">
<li>对面主从节点之间的约束关系</li>
<li>用于施加单位平均应变和消除刚体位移的位移边界条件</li>
</ol></li>
<li><strong>有限元方程右端项的B矩阵</strong>.
单胞变分方程的线性泛函项包含 B 矩阵,
而常用有限元求解器没有与之对应的载荷边界条件</li>
</ol>
<h3 id="使用-gmsh-生成周期性网格">使用 Gmsh 生成周期性网格</h3>
<p>Gmsh 带有命令 <code>Periodic</code>,
可以将主面通过平移或旋转的方式与从面相关联,
由此划分网格时可以保证面与面的节点分布完全相同.</p>
<h3 id="施加周期性边界条件">施加周期性边界条件</h3>
<p>主从节点信息在 Gmsh 网格 <code>.msh</code> 文件中通过关键词
<code>$Periodic</code>进行标识:</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404072302633GmshPeriodic关键词解释.png"
alt="GmshPeriodic关键词解释" />
<figcaption aria-hidden="true">GmshPeriodic关键词解释</figcaption>
</figure>
<p>从 <code>.msh</code> 文件中获取关联节点以及所属 entity 的信息,
就可以构造周期性边界条件的约束方程了. 在 ABAQUS 中, 一般是通过 equation
关键词确定多个节点自由度之间的约束关系:</p>
<p><span class="math display">\[
A_1 u_i^1 + A_2 u_i^2 + \ldots + A_N u_i^N = 0.
\]</span></p>
<p>式中, <span class="math inline">\(u_i^n\)</span> 上标 <span
class="math inline">\(n\)</span> 表示节点编号, 下标 <span
class="math inline">\(i\)</span> 表示 <span
class="math inline">\(x,y,z\)</span> 三方向自由度编号.
约束方程的变量只能是节点自由度, 并且右端恒等于 0, 所以 equation
只能添加节点自由度的齐次约束. 若希望添加非齐次的约束方程,
那么就需要引入一个额外的<strong>参考节点</strong>,
并在该节点处施加一个非零的位移条件.</p>
<p>程序采用的方式可以避免设置额外的参考节点,
平均应变条件则通过单胞上特殊节点的位移边界条件来施加,
这可以通过以下推导得到. 以 <span class="math inline">\(x\)</span>
方向为法线方向的两个相对面为例, 我们有</p>
<p><span class="math display">\[
u_i^{1+} - u_i^{1-} = \overline{\varepsilon}_{i1}, \quad
\text{对任意面 1 上的主从节点对.}
\]</span></p>
<p>记单胞在 x 轴的顶点坐标 <span class="math inline">\((1,0,0)\)</span>
处的位移为 <span class="math inline">\(u_i^{x}\)</span>, 原点处位移为
<span class="math inline">\(u_i^o\)</span>, 于是有</p>
<p><span class="math display">\[
u_i^x - u_i^o = \overline{\varepsilon}_{i1}.
\]</span></p>
<p>所以,</p>
<p><span class="math display">\[
u_i^{1+} - u_i^{1-} = u_i^x - u_i^o, \quad
\text{对任意面 1 上的主从节点对}.
\]</span></p>
<p>整理得到面 1 上的周期性边界条件等价为</p>
<p><span class="math display">\[
\begin{aligned}
  u_i^{1+} - u_i^{1-} - u_i^x + u_i^o &amp;= 0, \quad \text{对任意面 1
上的主从节点对}; \\
  u_i^x - u_i^o &amp;= \overline{\varepsilon}_{i1}.
\end{aligned}
\]</span></p>
<p>综合其它面的边界条件, 我们得到最终的约束方程</p>
<p><span class="math display">\[
\begin{aligned}
  u_i^{k+} - u_i^{k-} - u_i^x + u_i^o &amp;= 0, \quad \text{对任意面 k
上的主从节点对}; \\
  u_i^x - u_i^o &amp;= \overline{\varepsilon}_{i1}; \\
  u_i^y - u_i^o &amp;= \overline{\varepsilon}_{i2}; \\
  u_i^z - u_i^o &amp;= \overline{\varepsilon}_{i3}.
\end{aligned}
\]</span></p>
<p>第一组方程是关于节点自由度的齐次方程,
且与施加在单胞的单位平均应变无关,
所以在程序实现时可以不用特别考虑边界条件的具体形式;
其它三组方程则通过在节点 <span class="math inline">\((0,0,0)\)</span>,
<span class="math inline">\((1,0,0)\)</span>, <span
class="math inline">\((0,1,0)\)</span>, <span
class="math inline">\((0,0,1)\)</span> 处施加位移边界条件实现.</p>
<p>在实现第一组约束方程时, 还需要注意剔除冗余的约束方程,
这是因为我们使用 Lagrange 乘子法求解含约束的有限元方程,
如果出现冗余的约束, 则会导致有限元最终得到的刚度矩阵奇异.
我们将用一个二维平面上的四边形单元说明这一点. 如图所示,
单元节点处的位移分别为 <span class="math inline">\(u_1\)</span>, <span
class="math inline">\(u_2\)</span>, <span
class="math inline">\(u_3\)</span>, <span
class="math inline">\(u_4\)</span></p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404072344350冗余方程示意图.png" alt="image-20240407234453219" style="zoom:33%;" /></p>
<p>沿 <span class="math inline">\(x\)</span> 方向的约束方程有</p>
<p><span class="math display">\[
u_4 - u_2 = u_3 - u_1,
\]</span></p>
<p>沿 <span class="math inline">\(y\)</span> 方向的约束方程为</p>
<p><span class="math display">\[
u_4 - u_3 = u_2 - u_1.
\]</span></p>
<p>但是, 这两个方程是等价的,
因此如果遍历每组对面上每一个顶点,每一条边的节点, 就会出现过约束的问题.
一种避免过约束的方式如图所示, 按顺序读取节点, 并设置约束方程,
跳过图中虚线表示边线上的节点和空心圆圈表示的顶点处的节点,
就可以保证按照周期性边界条件约束所有的节点,
并且不存在冗余的约束方程.</p>
<figure>
<img
src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202404072348418顺序读取主从节点避免冗余约束.png"
alt="顺序读取主从节点避免冗余约束" />
<figcaption aria-hidden="true">顺序读取主从节点避免冗余约束</figcaption>
</figure>
<h2 id="有限元求解结果分析">有限元求解结果分析</h2>
<p>程序使用三种方式计算均质化材料矩阵:</p>
<ol type="1">
<li>求解线性位移边界条件下的单胞方程, 对计算结果进行体平均</li>
<li>求解周期性边界条件约束下的单胞方程, 对计算结果进行体平均</li>
<li>求解渐进展开得到的偏微分方程</li>
</ol>
<div class="note info"><ol type="1">
<li><p>方式 1,2 又称为 RVE 方法, 即计算单胞在平均应变下的应力场,
对体积积分得到平均应力, 再根据定义得到均质化的材料矩阵.</p></li>
<li><p>方式 2 使用周期性边界条件, 是对相对面上的主从节点施加约束关系,
再在角点处施加位移边界条件, 实现所谓的平均应变.</p></li>
<li><p>线性位移条件得到的结果应该略大于周期性边界条件的结果.</p></li>
<li><p>方式 3 求解新的偏微分方程, 固定单胞的角点等于去除宏观应变 <span
class="math inline">\(\varepsilon^c\)</span> 引入的位移量, 求解得到的
<span class="math inline">\(\chi\)</span>
可以看作是对体积积分得到的材料矩阵进行<strong>修正</strong>:</p></li>
</ol>
<p><span class="math display">\[
[D^{\mathrm{hom}}] = [\overline{D}] - [\sigma^{(11)}, \sigma^{(22)},
\sigma^{(33)}, \sigma^{(23)}, \sigma^{(13)}, \sigma^{(12)}]
\]</span></p>
</div>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>周期性边界条件</tag>
        <tag>有限元离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>双相单胞问题 E P 张量的封闭解</title>
    <url>/mech/multiscale/%E5%8F%8C%E7%9B%B8%E5%8D%95%E8%83%9E%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<p>参考文献：Fish,Practical multiscaling, chapter 4.3.5</p>
<p>给定单胞各个相的弹性模量 <span
class="math inline">\(\mathbb{L}^{(\alpha)},
\alpha=1,2,\ldots,N\)</span>，以及均质化之后的模量 <span
class="math inline">\(\mathbb{L}^c\)</span>，式（4.119a）和式（4.119b）给出关于
<span class="math inline">\(N\)</span> 个未知量 <span
class="math inline">\(E_{mn}^{kl(\alpha)}\)</span> 的 2
个方程，式（4.119c）和式（4.119d）给出关于 <span
class="math inline">\(N^2\)</span> 个未知量 <span
class="math inline">\(P_{mn}^{kl(\alpha\beta)}\)</span> 的 <span
class="math inline">\(2N\)</span> 个方程，<span
class="math inline">\(N\)</span> 为 Partition 的个数。当 <span
class="math inline">\(N=2\)</span>
时，也即单胞只分成两个分块，从方程的未知量个数来看，是可以得到封闭解的。<span id="more"></span></p>
<h2 id="e-张量的封闭解">E 张量的封闭解</h2>
<p>式（4.119a）和式（4.119b）展开后得到 <span class="math display">\[
\begin{aligned}
c^{(1)}\mathbb{L}^{(1)}:&amp;\mathbb{E}^{(1)} +
c^{(2)}\mathbb{L}^{(2)}:\mathbb{E}^{(2)} = \mathbb{L}^c\\
c^{(1)}&amp;\mathbb{E}^{(1)} + c^{(2)}\mathbb{E}^{(2)} = \mathbb{I}
\end{aligned}
\]</span> 第 2 式乘 <span
class="math inline">\(\mathbb{L}^{(2)}\)</span> 再与 1 式相减得到 <span
class="math display">\[
c^{(1)}(\mathbb{L}^{(1)}-\mathbb{L}^{(2)}):\mathbb{E}^{(1)}  =
\mathbb{L}^c - \mathbb{L}^{(2)}
\]</span> 所以 <span class="math inline">\(\mathbb{E}^{(1)}\)</span>
可以通过分块的弹性模量以及体积分数表示为 <span class="math display">\[
\mathbb{E}^{(1)} =
\frac{1}{c^{(1)}}(\mathbb{L}^{(1)}-\mathbb{L}^{(2)})^{-1} :
(\mathbb{L}^c - \mathbb{L}^{(2)})
\]</span> 由于指标是对称的，所以有 <span class="math display">\[
\mathbb{E}^{(2)} =
\frac{1}{c^{(2)}}(\mathbb{L}^{(2)}-\mathbb{L}^{(1)})^{-1} (\mathbb{L}^c
- \mathbb{L}^{(1)})
\]</span> 至此，我们解析得到了 <span
class="math inline">\(\mathbb{E}^{(1)}\)</span>，<span
class="math inline">\(\mathbb{E}^{(2)}\)</span> 的表达式： <span
class="math display">\[
\left\{
\begin{aligned}
\mathbb{E}^{(1)} =
\frac{1}{c^{(1)}}(\mathbb{L}^{(1)}-\mathbb{L}^{(2)})^{-1} (\mathbb{L}^c
- \mathbb{L}^{(2)})\\
\mathbb{E}^{(2)} =
\frac{1}{c^{(2)}}(\mathbb{L}^{(2)}-\mathbb{L}^{(1)})^{-1} (\mathbb{L}^c
- \mathbb{L}^{(1)})
\end{aligned}
\right.
\tag{1}
\]</span></p>
<h2 id="p-张量的封闭解">P 张量的封闭解</h2>
<p>展开式（4.119c）和式（4.119d）的自由指标得到如下 4 个方程： <span
class="math display">\[
\begin{aligned}
\mathbb{P}^{(11)} + \mathbb{P}^{(12)} = \mathbb{I} - \mathbb{E}^{(1)}\\
\mathbb{P}^{(11)}:\mathbb{M}^{(1)} + \mathbb{P}^{(12)}:\mathbb{M}^{(2)}
= 0\\
\\
\mathbb{P}^{(21)} + \mathbb{P}^{(22)} = \mathbb{I} - \mathbb{E}^{(2)}\\
\mathbb{P}^{(21)}:\mathbb{M}^{(1)} + \mathbb{P}^{(22)}:\mathbb{M}^{(2)}
= 0
\end{aligned}
\]</span> 1 式左右两端乘 <span
class="math inline">\(\mathbb{M}^{(2)}\)</span>，再与 2 式相减得到 <span
class="math display">\[
\mathbb{P}^{(11)}:(\mathbb{M}^{(2)} - \mathbb{M}^{(1)})
= (\mathbb{I} - \mathbb{E}^{(1)}):\mathbb{M}^{(2)}
\]</span> 所以 <span class="math display">\[
\mathbb{P}^{(11)}
= (\mathbb{I} - \mathbb{E}^{(1)}):\mathbb{M}^{(2)}:(\mathbb{M}^{(2)} -
\mathbb{M}^{(1)})^{-1}
\]</span> 又因为 <span class="math display">\[
\mathbb{M}^{(2)}:(\mathbb{M}^{(2)} - \mathbb{M}^{(1)})^{-1}
= (\mathbb{L}^{(1)} - \mathbb{L}^{(2)})^{-1}:\mathbb{L}^{(1)}
\]</span> 所以有 <span class="math display">\[
\mathbb{P}^{(11)}
= (\mathbb{I} - \mathbb{E}^{(1)}):(\mathbb{L}^{(1)} -
\mathbb{L}^{(2)})^{-1}:\mathbb{L}^{(1)}
\]</span> 类似的，我们可以求解出 <span
class="math inline">\(\mathbb{P}^{(12)}\)</span>： <span
class="math display">\[
\mathbb{P}^{(12)}
= (\mathbb{I} - \mathbb{E}^{(1)}):(\mathbb{L}^{(2)} -
\mathbb{L}^{(1)})^{-1}:\mathbb{L}^{(2)}
\]</span> 交换对称指标之后，我们同样也可以得到 <span
class="math inline">\(\mathbb{P}^{(21)}\)</span>，<span
class="math inline">\(\mathbb{P}^{(22)}\)</span> 的封闭表达式： <span
class="math display">\[
\left\{
\begin{aligned}
\mathbb{P}^{(11)}
= (\mathbb{I} - \mathbb{E}^{(1)}):(\mathbb{L}^{(1)} -
\mathbb{L}^{(2)})^{-1}:\mathbb{L}^{(1)}\\
\mathbb{P}^{(12)}
= (\mathbb{I} - \mathbb{E}^{(1)}):(\mathbb{L}^{(2)} -
\mathbb{L}^{(1)})^{-1}:\mathbb{L}^{(2)}\\
\mathbb{P}^{(22)}
= (\mathbb{I} - \mathbb{E}^{(2)}):(\mathbb{L}^{(2)} -
\mathbb{L}^{(1)})^{-1}:\mathbb{L}^{(2)}\\
\mathbb{P}^{(21)}
= (\mathbb{I} - \mathbb{E}^{(2)}):(\mathbb{L}^{(1)} -
\mathbb{L}^{(2)})^{-1}:\mathbb{L}^{(1)}
\end{aligned}
\right.
\tag{2}
\]</span></p>
<h2 id="数值实现">数值实现</h2>
<p>这里我们将把张量形式的方程组转换为可用于数值计算的 Voigt
形式。我们以求解（2）为例。将 1 式左右两端进行 Voigt 变换得到： <span
class="math display">\[
[:][\mathbb{P}^{(11)}]
= [:]([\mathbb{I}] - [\mathbb{E}^{(1)}])~
[:][(\mathbb{L}^{(1)} - \mathbb{L}^{(2)})^{-1}]~
[:][\mathbb{L}^{(1)}]
\]</span> 而中间四阶张量逆的矩阵表示为 <span class="math display">\[
[(\mathbb{L}^{(1)} - \mathbb{L}^{(2)})^{-1}]
= [:]^{-1} [\mathbb{L}^{(1)} - \mathbb{L}^{(2)}]^{-1} [:]^{-1}
\]</span> 代入得到 <span class="math display">\[
[:][\mathbb{P}^{(11)}]
= ([:][\mathbb{I}] - [:][\mathbb{E}^{(1)}])~
[\mathbb{L}^{(1)} - \mathbb{L}^{(2)}]^{-1}~
[\mathbb{L}^{(1)}]
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>张量运算</tag>
        <tag>解析方法</tag>
      </tags>
  </entry>
  <entry>
    <title>均质化理论中的 Hashin-Shtrikman 上下界</title>
    <url>/mech/multiscale/%E5%9D%87%E8%B4%A8%E5%8C%96%E7%90%86%E8%AE%BA%E4%B8%AD%E7%9A%84-Hashin-Shtrikman-%E4%B8%8A%E4%B8%8B%E7%95%8C/</url>
    <content><![CDATA[<p>参考文献: HASHIN Z, SHTRIKMAN S. A variational approach to the theory
of the elastic behaviour of multiphase materials[J/OL]. Journal of the
Mechanics and Physics of Solids, 1963, 11(2): 127-140. DOI:<span class="exturl" data-url="aHR0cHM6Ly9kb2kub3JnLzEwLjEwMTYvMDAyMi01MDk2KDYzKTkwMDYwLTc=">10.1016/0022-5096(63)90060-7<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="hashin-shtrikman-变分原理">Hashin-Shtrikman 变分原理</h2>
<p>Hashin-Shtrikman 变分原理考虑两个单胞 <span
class="math inline">\(Y\)</span> 和 <span
class="math inline">\(\widetilde Y\)</span>,
两个单胞选用同样的位移边界条件. 单胞 <span
class="math inline">\(Y\)</span> 材料为各向同性, 模量为 <span
class="math inline">\(L_{ijkl}^{0}\)</span>,
在位移边界条件下单胞内的应变 <span
class="math inline">\(\varepsilon_{ij}^{0}\)</span> 为常数. 单胞 <span
class="math inline">\(Y\)</span> 上的应力为: <span
class="math display">\[
\sigma_{ij}^0 = L_{ijkl}^0 \varepsilon_{kl}^0
\]</span> 单胞 <span class="math inline">\(\widetilde Y\)</span>
由非均质材料构成, 其模量为 <span
class="math inline">\(L_{ijkl}(y):\tilde Y \mapsto
\mathbb{S}^4\)</span>. 在与单胞 <span class="math inline">\(Y\)</span>
相同的位移边界条件作用下, 单胞 <span class="math inline">\(\widetilde
Y\)</span> 上的应变与应力是空间坐标的函数, 记为 <span
class="math inline">\(\varepsilon_{ij}(y):\tilde Y \mapsto
\mathbb{S}^2\)</span> 和 <span
class="math inline">\(\sigma_{ij}(y):\tilde Y \mapsto
\mathbb{S}^2\)</span>. 定义单胞 <span class="math inline">\(Y\)</span>
与 <span class="math inline">\(\widetilde Y\)</span> 之间模量的差值
<span class="math inline">\(\delta L_{ijkl}\)</span> 为 <span
class="math display">\[
\delta L_{ijkl} \triangleq L_{ijkl} - L_{ijkl}^{0}
\]</span> 以及极化应力 <span class="math inline">\(p_{ij}\)</span>​ <span
class="math display">\[
p_{ij}(y) \triangleq \sigma_{ij} - L_{ijkl}^0\varepsilon_{kl} = \delta
L_{ijkl}~\varepsilon_{kl}
\]</span> 将两种单胞应变场的差值记为 <span
class="math inline">\(\widetilde \varepsilon\)</span>: <span
class="math display">\[
\varepsilon_{ij} \triangleq \varepsilon_{ij}^0 +
\widetilde\varepsilon_{ij}
\]</span> &gt; Hashin-Shtrikman 给出的关于 <span
class="math inline">\(p_{ij}\)</span> 与 <span
class="math inline">\(\widetilde\varepsilon_{ij}\)</span>​
的能量泛函表达式为 &gt; <span class="math display">\[
&gt; U^p(p,\widetilde \varepsilon) = U^0 - \frac{1}{2} \int \left(
p_{ij}~\delta L_{ijkl}^{-1}~p_{kl} - p_{ij} \widetilde\varepsilon_{ij} -
2p_{ij}\varepsilon_{ij}^0 \right)  \mathrm{d} y
&gt; \tag{2.6}
&gt; \]</span> &gt; 以及辅助方程 &gt; <span class="math display">\[
&gt; \left( L_{ijkl}^0 \widetilde\varepsilon_{kl} + p_{ij} \right)_{,
~j} = 0
&gt; \]</span> &gt; 和边界条件 &gt; <span class="math display">\[
&gt; \widetilde u_{i}(\partial Y) = 0
&gt; \]</span> &gt; 式中, <span class="math inline">\(U^0 =
\frac{1}{2}\int \sigma_{ij}^{0} \varepsilon_{ij}^{0} \mathrm{d}
V\)</span>. 使得该泛函取驻值的极化应力满足 &gt; <span
class="math display">\[
&gt; p_{ij} := (L_{ijkl} - L_{ijkl}^0) \varepsilon_{kl} = \delta
L_{ijkl} \varepsilon_{kl}
&gt; \]</span></p>
<p>如果考虑单胞 <span class="math inline">\(\widetilde Y\)</span>
是由各向同性材料组成的, 那么在泛函表达式 (2.6) 中, <span
class="math inline">\(p_{ij}\delta L_{ijkl}^{-1}~p_{kl}\)</span>
可以显式地用材料常数 <span class="math inline">\(\lambda, K,
\mu\)</span> 表示为 <span class="math display">\[
p_{ij}~\delta L_{ijkl}^{-1}~p_{kl}
= -\frac{\lambda-\lambda^0}{6(\mu-\mu^0)(K-K^0)} p^2_{k k} +
\frac{1}{2(\mu-\mu^0)} p_{ij} p_{ij}
\tag{2.13}
\]</span> 式中, <span class="math inline">\(\lambda^0, K^0,
\mu^0\)</span> 是单胞 <span class="math inline">\(Y\)</span> 的弹性常数,
<span class="math inline">\(\lambda, K, \mu:\tilde Y \mapsto
\mathbb{R}^{+}\)</span> 是单胞 <span class="math inline">\(\widetilde
Y\)</span> 的弹性常数. 驻点为极大或者极小值与材料系数 <span
class="math inline">\(\lambda, \mu\)</span> 相关:</p>
<p>驻点取极大值, 当 <span class="math display">\[
\lambda&gt;\lambda^0, \quad \mu &gt; \mu^0,
\tag{2.15}
\]</span> 驻点取极小值, 当 <span class="math display">\[
\lambda &lt; \lambda^0, \quad \mu &lt; \mu^0,
\tag{2.16}
\]</span></p>
<h2 id="非均质材料的模量上下限">非均质材料的模量上下限</h2>
<p>首先, 定义算符 <span
class="math inline">\(\langle\cdot\rangle\)</span>
表示场变量在单胞区域的体积平均: <span class="math display">\[
\langle \cdot \rangle \triangleq \frac{1}{|Y|} \int_Y \cdot ~ \mathrm{d}
y
\]</span> 在非均质单胞 <span class="math inline">\(\widetilde Y\)</span>
表面施加位移条件为 <span class="math display">\[
u_i(\partial Y) = \varepsilon_{ij}^{0} x_j
\tag{3.1}
\]</span> 单胞内部的应变场响应为 <span
class="math inline">\(\varepsilon_{ij}:\tilde Y \mapsto
\mathbb{S}^2\)</span>, 定义单胞上的平均应变 <span
class="math inline">\(\bar \varepsilon_{ij} \in \mathbb{S}^2\)</span>
为应变场在单胞上的体积平均: <span class="math display">\[
\bar \varepsilon_{ij} \triangleq \langle \varepsilon_{ij} \rangle
\]</span> 可以证明, <span class="math inline">\(\bar \varepsilon_{ij}
\equiv \varepsilon_{ij}^{0}\)</span>, 之后这两者之间的记号不加区分,
均使用 <span class="math inline">\(\bar \varepsilon_{ij}\)</span>. 因此,
单胞 <span class="math inline">\(\widetilde Y\)</span>
上的应变场可以分解为 <span class="math display">\[
\varepsilon_{ij}(y) = \bar \varepsilon_{ij} + \widetilde
\varepsilon_{ij}(y)
\]</span> 并且应变扰动项 <span class="math inline">\(\widetilde
\varepsilon_{ij}\)</span> 的体积平均等于 0 <span class="math display">\[
\langle \widetilde \varepsilon_{ij} \rangle = 0
\]</span> 单胞 <span class="math inline">\(\widetilde Y\)</span>
上的应变能可以表示为如下形式: <span class="math display">\[
U = \frac{9}{2} K^{\star} \bar\varepsilon^2 + \mu^{\star} \bar e_{ij}
\bar e_{ij}
\tag{3.2}
\]</span> 式中, 应变 <span class="math inline">\(\bar
\varepsilon_{ij}\)</span> 被分解为 <span class="math display">\[
\bar \varepsilon_{ij} = \bar \varepsilon ~\delta_{ij} + \bar e_{ij},
\quad \bar \varepsilon = \frac{1}{3} \bar \varepsilon_{ii}
\]</span> 接下来, 我们将应用 Hashin-Shtrikman 变分原理. 设置均质参考单胞
<span class="math inline">\(Y\)</span>, 其弹性常数为 <span
class="math inline">\(K_0, G_0\)</span>, 并在边界处施加式 (3.1)
所表示的边界条件. 非均质单胞 <span class="math inline">\(\widetilde
Y\)</span> 由 <span class="math inline">\(N\)</span> 相各向同性材料组成.
定义 <span class="math inline">\(Y^\alpha\)</span> 上的示性函数 <span
class="math inline">\(\chi^{\alpha}(y):Y\mapsto\mathbb{R}\)</span> ：
<span class="math display">\[
\chi^{\alpha}(y) \triangleq \begin{cases}
1, \quad y \in Y^{\alpha}\\
0, \quad y \notin Y^{\alpha}\\
\end{cases}
\]</span> 在泛函 (2.16) 中, 我们选取这样的极化应力, 使得在每一个分块
<span class="math inline">\(\widetilde Y^{\alpha}\)</span>
上的极化应力为常值: <span class="math display">\[
p_{ij} := \sum_{\alpha}^{N} p_{ij}^{\alpha} \chi^{\alpha}
\tag{3.6}
\]</span> 在进行下一阶段的讨论之前, 我们先给出张量的 deviatoric 分解.
我们可以将张量分解为各向同性部分与 dev 部分: <span
class="math display">\[
\begin{aligned}
p_{ij} &amp;= p \delta_{ij} + f_{ij}, \quad p = \frac{1}{3}p_{ii} \\
\widetilde\varepsilon_{ij} &amp;= \widetilde\varepsilon \delta_{ij} +
\widetilde e_{ij}, \quad \widetilde\varepsilon =
\frac{1}{3}\widetilde\varepsilon_{ii} \\
\bar\varepsilon_{ij} &amp;= \bar\varepsilon \delta_{ij} + \bar e_{ij},
\quad \bar\varepsilon = \frac{1}{3} \bar\varepsilon_{ii}
\end{aligned}
\]</span> 这样分解的好处直接体现在两个二阶张量进行双点积的运算过程中,
iso 与 dev 的交叉项直接等于0, 这是由于 <span class="math display">\[
f_{ij} \delta_{ij} = (p_{ij} - p \delta_{ij}) \delta_{ij} = p_{ii} - 3p
= 0
\]</span></p>
<p>将分解后的极化应力代入到泛函表达式 (2.6) 当中得到 <span
class="math display">\[
U^p=U^0 + \widetilde U - \frac{1}{2} \int
\left(\frac{p^2}{K-K^0} + \frac{f_{ij} f_{ij}}{2(\mu - \mu^0)}
-6 p \bar\varepsilon-2 f_{i j} \bar e_{i j}
\right) \mathrm{d} y
\tag{3.9}
\]</span> 式中 <span class="math display">\[
\begin{aligned}
U^0 &amp;= \frac{9}{2} K^0 \bar\varepsilon^2 + \mu^0 \bar e_{ij} \bar
e_{ij} \\
\widetilde U &amp;= \frac{1}{2} \int (3p \widetilde\varepsilon + f_{ij}
\widetilde e_{ij}) ~\mathrm{d} y
\end{aligned}
\]</span></p>
<p>再将极化应力的表达式 (3.6) 代入 (3.9) 的积分项中, 就能够得到 <span
class="math display">\[
U^p = U^0 + \widetilde U - \frac{1}{2} \sum_{\alpha} c^{\alpha}
\left( \frac{(p^{\alpha})^2}{K^{\alpha} - K^0}
+ \frac{f_{ij}^{\alpha} f_{ij}^{\alpha}}{2( \mu^{\alpha} - \mu^0 )}
\right)
+ 3\bar{p} \bar\varepsilon + \bar{f}_{ij} \bar e_{i j}
\tag{3.12}
\]</span> <div class="note info no-icon"><p>在上述计算中出现了对分段常值函数一次项 <span
class="math inline">\(p\)</span> <span
class="math inline">\(f_{ij}\)</span> 和二次项 <span
class="math inline">\(p^2\)</span> <span
class="math inline">\(f_{ij}f_{ij}\)</span> 的体积分, 下面将分别讨论</p>
<p>分段常值物理场 <span class="math inline">\(p=\sum_{\alpha} p^\alpha
\chi^\alpha\)</span> 的体积平均为 <span class="math display">\[
\bar p \triangleq \left\langle \sum_{\alpha} p^\alpha \chi^\alpha
\right\rangle
= \frac{1}{|Y|}\int_{Y} \sum_{\alpha} p^\alpha \chi^\alpha(y) \mathrm{d}
y
= \frac{1}{|Y|}\sum_{\alpha} p^{\alpha} \int_{Y} \chi^\alpha(y)
\mathrm{d} y
= \sum_{\alpha} \frac{|Y^{\alpha}|}{|Y|} p^{\alpha}
\]</span> 定义分块 <span class="math inline">\(\alpha\)</span>
所占的体积分数 <span class="math inline">\(c^{\alpha}\)</span> 为: <span
class="math display">\[
c^{(\alpha)} \triangleq \frac{|Y^{\alpha}|}{|Y|}
\]</span> 所以 <span class="math display">\[
\bar p = \sum_{\alpha} c^{\alpha} p^{\alpha}
\]</span> 分段常值物理场二次项的体积分为 <span class="math display">\[
\frac{1}{|Y|}\int_{Y} \left( \sum_{\alpha} p^{\alpha} \chi^{\alpha}(y)
\right)
\left( \sum_{\beta} p^{\beta} \chi^{\beta}(y) \right) \mathrm{d} y
= \sum_{\alpha} \sum_{\beta} p^{\alpha} p^{\beta} \frac{1}{|Y|}\int_{Y}
\chi^{\alpha}(y) \chi^{\beta}(y) \mathrm{d} y
= \sum_{\alpha} \sum_{\beta} p^{\alpha} p^{\beta} \delta_{\alpha\beta}
c^{\alpha} \mathrm{d} y
= \sum_{\alpha} c^{\alpha} (p^{\alpha})^2
\]</span></p>
</div></p>
<p>式 (3.12) 中还差 <span class="math inline">\(\tilde U\)</span>
没有给出, 我们可以通过<a
href="https://qiuxiaohuo.github.io/mechanics/Fourier-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90-Hashin-Shtrikman-%E5%8F%98%E5%88%86/">Fourier
分析得到</a> <span class="math display">\[
2 \widetilde U
= \underbrace{\frac{-3 K^0 - 6\mu^0}{5\mu^0 (3 K^0 + 4\mu^0)}
}_{\triangleq b_0}
\left( \sum_{\alpha} c^{\alpha} f_{ij}^{\alpha} f_{ij}^{\alpha} -
\bar{f}_{ij}\bar{f}_{ij} \right)
+ \underbrace{\frac{-3}{3 K^0 + 4\mu^0} }_{\triangleq a_0}
\left(\sum_{\alpha} c^{\alpha} (p^{\alpha})^2 - \bar{p}^2 \right)
\tag{3.15}
\]</span></p>
<p>这样, 我们得到 <span class="math inline">\(U^p\)</span>​
关于极化应力的代数方程: <span class="math display">\[
\begin{aligned}
U^p &amp;= \bar U
- \frac{1}{2} \sum_{\alpha}c^{\alpha}
\left( \left(\frac{1}{K^{\alpha}-K^0} - a_0\right) (p^{\alpha})^2
+ \left( \frac{1}{2(\mu^{\alpha} - \mu^0)} - b_0 \right)
f_{ij}^{\alpha}f_{ij}^{\alpha}
\right) \\
&amp;+ 3\bar{p} \bar\varepsilon + \bar{f}_{ij} \bar e_{i j}
- \frac{1}{2}b_0 \bar{f}_{ij}\bar{f}_{ij}
- \frac{1}{2}a_0 \bar{p}^2
\end{aligned}
\tag{3.18}
\]</span> 由极值条件 (2.15), 当所有分区上材料常数 <span
class="math inline">\(K^{\alpha}\)</span>, <span
class="math inline">\(\mu^{\alpha}\)</span> 满足 <span
class="math display">\[
K^{\alpha} &gt; K^0, \quad \mu^{\alpha} &gt; \mu^0, \quad \forall \alpha
\tag{3.19}
\]</span> 此时, 由式 (3.18) 得到的 <span
class="math inline">\(U^p\)</span> 就是式 (3.2) 的一个下界: <span
class="math display">\[
U^p &lt; U
\tag{3.20}
\]</span> 类似的, 我们可以得到, 当所有分区上材料常数 <span
class="math inline">\(K^{\alpha}\)</span>, <span
class="math inline">\(\mu^{\alpha}\)</span> 满足 <span
class="math display">\[
K^{\alpha} &lt; K^0, \quad \mu^{\alpha} &lt; \mu^0, \quad \forall \alpha
\tag{3.21}
\]</span> 就可以得到式 (3.2) 的一个上界: <span class="math display">\[
U^p &gt; U
\tag{3.22}
\]</span> 为了得到最紧的上下界, 我们可以对式 (3.18) 中 <span
class="math inline">\(p^{\alpha}\)</span>, <span
class="math inline">\(f_{ij}^{\alpha}\)</span> 求偏导, 得到使得 <span
class="math inline">\(U^p\)</span> 取极值的条件: <span
class="math display">\[
\begin{aligned}
\frac{\partial U^p}{\partial p^{\alpha}}
&amp;= -\left(\frac{1}{K^{\alpha}-K^0} - a_0\right) c^{\alpha}
p^{\alpha}
+ 3 c^{\alpha} \bar\varepsilon
- c^{\alpha} a_0 \bar p = 0 \\
\frac{\partial U^p}{\partial f_{ij}^{\alpha}}
&amp;= -\left( \frac{1}{2(\mu^{\alpha} - \mu^0)} - b_0 \right)
c^{\alpha} f_{ij}^{\alpha}
+ c^{\alpha} \bar e_{i j} - c^{\alpha} b_0 \bar{f}_{ij} = 0
\end{aligned}
\]</span> 消去体积分数 <span class="math inline">\(c^{\alpha}\)</span>
得到 <span class="math display">\[
\begin{aligned}
\left(\frac{1}{K^{\alpha}-K^0} - a_0\right) p^{\alpha} +  a_0
\sum_{\alpha} c^{\alpha} p^{\alpha}
&amp;= 3 \bar\varepsilon  \\
\left( \frac{1}{2(\mu^{\alpha} - \mu^0)} - b_0 \right) f_{ij}^{\alpha} +
b_0 \sum_{\alpha} c^{\alpha} f_{ij}^{\alpha}
&amp;= \bar e_{i j}
\end{aligned}
\]</span> 该方程的解, 如果我们引入修正刚度 <span
class="math inline">\(K_{*}^{\alpha}\)</span> 和 <span
class="math inline">\(\mu_{*}^{\alpha}\)</span>: <span
class="math display">\[
K_{*}^{\alpha}   \triangleq \frac{1}{\frac{1}{K^{\alpha}-K^0} - a_0},
\quad
2\mu_{*}^{\alpha} \triangleq \frac{1}{\frac{1}{2(\mu^{\alpha} - \mu^0)}
- b_0}
\]</span> 以及 <span class="math display">\[
\bar K_{*} = \sum_{\alpha}\left( c^{\alpha} K_{*}^{\alpha} \right),
\quad
\bar \mu_{*} = \sum_{\alpha}\left( c^{\alpha} \mu_{*}^{\alpha} \right)
\]</span></p>
<p>就可以表示为 <span class="math display">\[
\begin{align}
p^{\alpha} &amp;= \frac{3 K_{*}^{\alpha}}{1 + a_0 \bar K_{*}}
\bar\varepsilon \tag{3.27}\\
f_{ij}^{\alpha} &amp;= \frac{2\mu_{*}^{\alpha}}{1 + 2 b_0 \bar \mu_{*}}
\bar e_{ij} \tag{3.28}
\end{align}
\]</span> 将极值点代入到二项式 (3.18) 中, 取值等于二项式中一次项的一半:
<span class="math display">\[
U^p = \bar U + \frac{1}{2} \left( 3\bar{p} \bar\varepsilon +
\bar{f}_{ij} \bar e_{i j} \right)
= \frac{9}{2} \left( K^0 + \frac{\bar K_{*}}{1 + a_0 \bar K_{*}}
\right)\bar\varepsilon^2
+ \left( \mu^0 + \frac{ \bar\mu_{*}}{1 + 2 b_0 \bar \mu_{*}}
\right) \bar e_{ij} \bar e_{ij}
\]</span> 选取单胞的宏观应变 <span
class="math inline">\(\bar\varepsilon_{ij} := \bar\varepsilon
\delta_{ij}\)</span>, 代入上式当中, 再根据式 (3.20) (3.22), 可以得到
<span class="math display">\[
U^p \lessgtr U \Rightarrow
\frac{9}{2} \left( K^0 + \frac{\bar K_{*}}{1 + a_0 \bar K_{*}}
\right)\bar\varepsilon^2
\lessgtr \frac{9}{2} K^{\star} \bar\varepsilon^2, \quad \forall
\bar\varepsilon
\]</span> 所以 <span class="math display">\[
K^{*} \triangleq K^0 + \frac{\bar K_{*}}{1 + a_0 \bar K_{*}} \lessgtr
K^{\star}
\tag{3.32}
\]</span> 类似的, 我们也可以得到关于剪切模量 <span
class="math inline">\(\mu^{\star}\)</span> 的上下界估计: <span
class="math display">\[
\mu^{*} \triangleq \mu^0 + \frac{ \bar\mu_{*}}{1 + 2 b_0 \bar \mu_{*}}
\lessgtr \mu^{\star}
\tag{3.34}
\]</span></p>
<p>在得到的模量上下界公式 (3.32) 和 (3.34) 中, 还包含参数 <span
class="math inline">\(K^0\)</span> 和 <span
class="math inline">\(\mu^0\)</span>, 现在我们希望能够在保证满足 (3.19)
(3.21) 极值条件下, 选取参数 <span class="math inline">\(K^0\)</span> 和
<span class="math inline">\(\mu^0\)</span>, 得到最紧的上下界.
可以证明(但是我没证明), 式 (3.32) (3.34) 的上下界关于 <span
class="math inline">\(K^0\)</span> 和 <span
class="math inline">\(\mu^0\)</span> 是单调的. 为保证 (3.32) 得到的
<span class="math inline">\(K^{*}\)</span> 是下界, 需要满足 <span
class="math display">\[
K^0 &lt; K^{\alpha}, \quad \mu^0 &lt; \mu^{\alpha}, \quad \forall \alpha
\]</span> 又因为 <span class="math inline">\(K^{*}\)</span>, <span
class="math inline">\(\mu^{*}\)</span> 关于 <span
class="math inline">\(K^0\)</span>, <span
class="math inline">\(\mu^0\)</span> 单调,
所以最紧的下界(所有下界中的最大值) 在 <span class="math display">\[
K^0 = \min_{\alpha} K^{\alpha}, \quad \mu^0 = \min_{\alpha} \mu^{\alpha}
\]</span> 取到. 类似的最紧的上界(所有上界的最小值)取值点为 <span
class="math display">\[
K^0 = \max_{\alpha} K^{\alpha}, \quad \mu^0 = \max_{\alpha} \mu^{\alpha}
\]</span> 综上, 通过 Hashin-Shtrikman 变分原理, 得到的单胞模量上下界
<span class="math inline">\(K^{*}(K^0, \mu^0)\)</span>, <span
class="math inline">\(\mu^{*}(K^0, \mu^0)\)</span>为 <span
class="math display">\[
\begin{aligned}
K^{*}(\min_{\alpha} K^{\alpha},\min_{\alpha} \mu^{\alpha}) &amp;&lt;
K^{\star} &lt; K^{*}(\max_{\alpha} K^{\alpha},\max_{\alpha}
\mu^{\alpha}) \\
\mu^{*}(\min_{\alpha} K^{\alpha},\min_{\alpha} \mu^{\alpha}) &amp;&lt;
\mu^{\star} &lt; \mu^{*}(\max_{\alpha} K^{\alpha},\max_{\alpha}
\mu^{\alpha})
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>变分原理</tag>
        <tag>细观力学</tag>
      </tags>
  </entry>
  <entry>
    <title>弹性力学方程的 Green 函数</title>
    <url>/mech/multiscale/%E5%BC%B9%E6%80%A7%E5%8A%9B%E5%AD%A6%E6%96%B9%E7%A8%8B%E7%9A%84%20Green%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<h5 id="基本解和-green-函数的区别">基本解和 Green 函数的区别</h5>
<p>如果将微分方程写成抽象的算子形式: <span class="math display">\[
L[u] = f \text{ on } \Omega
\]</span></p>
<p>特别的, 当函数 <span class="math inline">\(f\)</span> 为 Dirac 函数
<span class="math inline">\(\delta\)</span> 时, 微分方程的解称为算子
<span class="math inline">\(L\)</span> 的<strong>基本解</strong>: <span
class="math display">\[
L [G] = \delta
\]</span></p>
<p>注意到上述过程中, 并没有提到方程需要满足什么边界条件, 这也是基本解和
Green 函数之间的区别. <strong>Green 函数需要考虑边界的影响,
基本解只需要考虑函数在区域内满足什么微分方程.</strong> 在下文中,
我还是按照 Mura 书中的表述, 将以求解基本解方式得到的函数称为 Green 函数.
当微分方程右端项为一般的函数 <span class="math inline">\(f\)</span> 时,
此时微分方程的解 <span class="math inline">\(u\)</span> 可以表示为Green
<span class="math inline">\(G\)</span> 与 <span
class="math inline">\(f\)</span> 的卷积:</p>
<p><span class="math display">\[
u = G*f = \int_{-\infty}^{\infty} G(x-x^{\prime}) f(x^{\prime})
\mathrm{d} x^{\prime}
\]</span></p>
<h5 id="张量值函数的卷积定义">张量值函数的卷积定义</h5>
<p>对于张量值方程 <span class="math display">\[
\boldsymbol{L}[\boldsymbol{u}] = \boldsymbol{f}
\]</span> 应用 Fourier 变换, 方程组转化为关于 <span
class="math inline">\(\hat u\)</span> 的代数方程: <span
class="math display">\[
\hat L_{ij}(\xi) \hat u_{j} = \hat f_i
\]</span> 对方程系数矩阵 <span class="math inline">\(\hat
L_{ij}\)</span> 求逆, 再作 Fourier 逆变换, 就得到解 <span
class="math inline">\(u\)</span> 表示为 <span class="math display">\[
u_i = \mathscr{F}^{-1} [\hat{L}_{ij}^{-1} \hat{f}_j]
\]</span> 定义张量值函数之间的卷积为 <span class="math display">\[
A * f:  L(\Omega,\mathbb{R}^{n\times n}) \times L(\Omega,\mathbb{R}^{
n}) \mapsto L(\Omega,\mathbb{R}^{n}) \\
A * f \triangleq A_{ij} * f_{j}
\]</span> 上式默认了指标求和约定. 这也就是说,
张量的代数运算保存在卷积的积分号内.</p>
<p>张量值方程的基本解定义为 <span class="math display">\[
G_{ij} = \mathscr{F}^{-1} [\hat{L}_{ij}^{-1}]
\]</span> 因此, 方程解可以表示为 <span class="math display">\[
\boldsymbol{u} = \boldsymbol{G} * \boldsymbol{f}
\]</span></p>
</blockquote>
<h2 id="含本征应变弹性方程的基本解">含本征应变弹性方程的基本解</h2>
<p>对于含本征应变的控制方程: <span class="math display">\[
L_{ijkl}~u_{k,lj} - L_{ijkl}~\mu_{kl,j} = 0
\]</span></p>
<p>我们希望能够找到该方程的 Green 函数 <span
class="math inline">\(G\)</span>, 使得方程的解可以表示为 Green
函数与本征应变的卷积. 这需要借助于 Fourier 分析方法. 对方程进行 Fourier
变换, 得到</p>
<p><span class="math display">\[
L_{ijkl}\xi_{l}\xi_{j}~\hat{u}_{k} + i \xi_{j}L_{ijkl}~\hat{\mu}_{kl} =
0
\]</span></p>
<p>记 <span class="math inline">\(K_{ik}(\xi) \triangleq
L_{ijkl}\xi_{l}\xi_{j}\)</span>, <span class="math inline">\(X_i
\triangleq -i \xi_{j}L_{ijkl}~\hat{\mu}_{kl}\)</span>, 就得到关于 <span
class="math inline">\(\hat{u}_k\)</span> 的线性方程:</p>
<p><span class="math display">\[
K_{ik} \hat{u}_k = X_i
\]</span></p>
<p>如果 <span class="math inline">\(L_{ijkl}\)</span> 具有主对称性,
也就是说, <span class="math inline">\(L_{(ij)[kl]} =
L_{[kl](ij)}\)</span>, 那么矩阵 <span
class="math inline">\(K_{ik}(\xi)\)</span> 是对称矩阵. 再应用 Fourier
逆变换, 就可以得到解 <span class="math inline">\(u(x)\)</span>:</p>
<p><span class="math display">\[
u_{i}(x) = \mathscr{F}^{-1} [\hat{u}_{i}(\xi)]
= \mathscr{F}^{-1}[ -i\xi_{j}~ L_{kjmn}~K_{ik}^{-1}(\xi)\hat{\mu}_{mn}]
\]</span></p>
<p>将三维 Fourier 逆变换的公式代入得到</p>
<p><span class="math display">\[
\begin{aligned}
u_{i}(x)
&amp;= - \frac{1}{(2\pi)^3}
\int i\xi_{j} L_{kjmn} K_{ik}^{-1}(\xi) e^{i\xi \cdot x} \mathrm{d} \xi
\int \mu_{mn}(x^{\prime}) e^{-i\xi \cdot x^{\prime}} \mathrm{d}
x^{\prime}\\
&amp;= - \int L_{kjmn}
\frac{\partial}{\partial x_j} \left( \frac{1}{(2\pi)^3}
\int K_{ik}^{-1}(\xi) e^{i\xi \cdot (x-x^{\prime})}
\mathrm{d} \xi \right)  
\mu_{mn}(x^{\prime}) \mathrm{d} x^{\prime}
\end{aligned}
\]</span></p>
<p>定义 Green 函数为弹性方程逆矩阵的 Fourier 逆变换:</p>
<p><span class="math display">\[
G_{ik}(x) \triangleq \mathscr{F}^{-1}[K_{ik}^{-1}](x)
=\frac{1}{(2\pi)^3} \int K_{ik}^{-1}(\xi) e^{i\xi \cdot x} \mathrm{d}
\xi
\]</span></p>
<p>那么位移 <span class="math inline">\(u_i\)</span> 可以表示为 Green
函数与本征应变的卷积</p>
<p><span class="math display">\[
u_{i}(x) = -\int L_{jkmn} G_{ik,j}(x-x^{\prime}) \mu_{mn}(x^{\prime})
\mathrm{d} x^{\prime}
\]</span></p>
<p>式中, Green 函数下标 <span
class="math inline">\(\square_{,j}\)</span> 表示对变量 <span
class="math inline">\(x_j\)</span> 求偏导 (注意区别变量 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(x^{\prime}\)</span>). 或者将上式记为卷积的形式:
<span class="math display">\[
u_i = G_{ik,j} * \left( -L_{jkmn} \mu_{mn} \right)
\]</span> ## 验证 Green 函数所满足的微分方程</p>
<p>对 Green 函数求二阶导数, 得到 <span class="math display">\[
G_{ij,kl}(x) = \frac{1}{(2\pi)^3}
\int -K_{ij}^{-1}(\xi) \xi_k \xi_l e^{i\xi \cdot x} \mathrm{d} \xi
\]</span></p>
<p>方程两端乘 <span class="math inline">\(L_{jknl}\)</span>,
等式依旧成立, 得到</p>
<p><span class="math display">\[
\begin{align}
L_{jknl}G_{ij,kl}(x)
&amp;= -\frac{1}{(2\pi)^3}
\int K_{ij}^{-1}(\xi) L_{jknl} \xi_k \xi_l e^{i\xi \cdot (x-x^{\prime})}
\mathrm{d} \xi
\end{align}
\]</span></p>
<p>注意到 <span class="math inline">\(K_{jn}(\xi) :=
L_{jknl}\xi_{k}\xi_{l}\)</span>, 所以有 <span class="math display">\[
L_{jknl}G_{ij,kl}(x)
= -\delta_{in} \frac{1}{(2\pi)^3}\int e^{i\xi \cdot x} \mathrm{d} \xi
= -\delta_{in} \delta(x)
\]</span> 整理一下指标, 得到 <span class="math display">\[
L_{ijkl}G_{nk,lj}(x) + \delta_{in} \delta(x) = 0
\]</span></p>
<p>展开指标 <span class="math inline">\(i\)</span>, <span
class="math inline">\(n\)</span>, 就得到 9 个方程: <span
class="math display">\[
\begin{pmatrix}
L_{1jkl}G_{1k,lj} + \delta(x) &amp; L_{1jkl}G_{2k,lj} &amp;
L_{1jkl}G_{3k,lj} \\
L_{2jkl}G_{1k,lj} &amp; L_{2jkl}G_{2k,lj} + \delta(x) &amp;
L_{2jkl}G_{3k,lj} \\
L_{3jkl}G_{1k,lj} &amp; L_{3jkl}G_{2k,lj} &amp; L_{3jkl}G_{3k,lj} +
\delta(x)
\end{pmatrix}
= \mathbf{0}_{3\times 3}
\]</span> 方程的每一列代表了空间中三个方向上作用在 <span
class="math inline">\(x=0\)</span>​ 处的单位力, Green 函数 <span
class="math inline">\(G_{nk}(x)\)</span> 表示在 <span
class="math inline">\(n\)</span> 方向的单位集中力作用下, 弹性方程 <span
class="math inline">\(k\)</span> 方向的位移响应. 如果 <span
class="math inline">\(L_{ijkl}\)</span> 具有主对称性, 那么矩阵 <span
class="math inline">\(K\)</span> <span class="math inline">\(N\)</span>
是对称矩阵, 所以 <span class="math display">\[
G_{nk} = G_{kn}
\]</span> 所以, <span class="math inline">\(G_{nk}(x)\)</span>
同样也可以解释为: 在 <span class="math inline">\(k\)</span>
方向的单位集中力作用下, 弹性方程 <span class="math inline">\(n\)</span>
方向的位移响应. 这恰好与互易原理的结论相同.</p>
<h2 id="各项同性材料的-green-函数表示">各项同性材料的 Green
函数表示</h2>
<p>对于各向同性材料, 方程左端的系数矩阵为 <span class="math display">\[
\hat K \triangleq \mu \xi^{T} \xi ~\mathbf{I} + (\lambda + \mu)\xi
\xi^{T}
= \mu |\xi|^2 \mathbf{I}
+ (\lambda + \mu)
\begin{pmatrix}
\xi_1 \xi_1 &amp; \xi_1 \xi_2 &amp; \xi_1 \xi_3 \\
\xi_2 \xi_1 &amp; \xi_2 \xi_2 &amp; \xi_2 \xi_3 \\
\xi_3 \xi_1 &amp; \xi_3 \xi_2 &amp; \xi_3 \xi_3
\end{pmatrix}
\]</span> 式中, <span class="math inline">\(\mathbf{I}\)</span> 为 3
阶单位矩阵, <span class="math inline">\(\xi = (\xi_1, \xi_2,
\xi_3)^{\top}\)</span>, <span class="math inline">\(|\xi|^2 = \xi_1^2 +
\xi_2^2 + \xi_3^2\)</span>. 对于形式为 <span class="math inline">\(I +
\alpha vv^T\)</span> 的矩阵, 其逆矩阵的形式依旧为 <span
class="math inline">\(I + \beta vv^T\)</span>, 因此矩阵 <span
class="math inline">\(\hat{K}\)</span> 的逆为 <span
class="math display">\[
\hat{K}^{-1}  = \frac{1}{\mu} \frac{1}{|\xi|^2} \mathbf{I}
- \frac{\lambda + \mu}{\mu (\lambda + 2\mu)} \frac{1}{|\xi|^4} \xi
\xi^{\top}, \quad
\det(\hat{K}) = (\lambda + 2\mu)\mu^2 |\xi|^6
\]</span> 各项同性材料的 Green 函数为 <span class="math display">\[
G(x) = \frac{1}{(2\pi)^3} \frac{1}{\mu} \int_{\mathbb{R}^3}
\frac{1}{|\xi|^2} \mathbf{I} ~\mathrm{d} \xi
- \frac{1}{(2\pi)^3} \frac{\lambda + \mu}{\mu (\lambda + 2\mu)}
\int_{\mathbb{R}^3} \frac{1}{|\xi|^4} \xi \xi^{\top} \mathrm{d} \xi
\]</span> 将积分分成两部分进行计算 <span class="math display">\[
I_0(x) = \int_{\mathbb{R}^3} \frac{1}{|\xi|^2} e^{i\xi \cdot x}
~\mathrm{d} \xi, \quad
I_{ij}(x) = - \frac{\partial^2}{\partial x_i \partial x_j}
\int_{\mathbb{R}^3} \frac{1}{|\xi|^4} e^{i\xi \cdot x} \mathrm{d} \xi
\]</span> 一波操作得到 <span class="math display">\[
I_0(x) = 2\pi^2 \frac{1}{|x|}, \quad
I_{ij} = \pi^2 \frac{\partial^2 |x|}{\partial x_i \partial x_j}
\]</span> 代入方程中得到 <span class="math display">\[
G_{ij}(x) = \frac{1}{4\pi \mu} \frac{1}{|x|} \delta_{ij}
- \frac{\lambda + \mu}{8\pi \mu (\lambda + 2\mu)}
\frac{\partial^2}{\partial x_i \partial x_j}  |x|
\]</span> &gt; 对于径向对称幂函数 <span
class="math inline">\(1/|\xi|^a\)</span>, Fourier
逆变换依旧得到径向对称幂函数 <span
class="math inline">\(C_a/|x|^{d-a}\)</span>, 这时需要确定常数 <span
class="math inline">\(C_a\)</span>, 当 <span class="math inline">\(a
&lt; d\)</span> 时, 有 &gt; <span class="math display">\[
&gt; C_a=(2 \pi)^{\frac{n}{2}} \frac{2^{\frac{n-a}{2}}
\Gamma\left(\frac{n-a}{2}\right)}{2^{\frac{a}{2}}
\Gamma\left(\frac{a}{2}\right)} .
&gt; \]</span> &gt; <span class="exturl" data-url="aHR0cHM6Ly9tYXRoLmFyaXpvbmEuZWR1L35mYXJpcy9tZXRob2Rzd2ViL2hhbmtlbC5wZGY=">Radial
functions and the Fourier transform<i class="fa fa-external-link-alt"></i></span> &gt; &gt; 对于 <span
class="math inline">\(a &gt; d\)</span> 的情况, 积分是不收敛的, 但注意到
<span class="math inline">\(I_{ij}\)</span> 还是关于 <span
class="math inline">\(x_i\)</span> 的二阶导数, 这就抵消了 2 幂次,
积分是收敛的. 尝试计算 <span class="math inline">\(I_{11}(x)\)</span>,
并令 <span class="math inline">\(x=(0,0,1)\)</span>, 最终得到 &gt; <span
class="math display">\[
&gt; C_{4} = 4\pi \int_{0}^{\infty} \frac{1}{r^3} \sin r - \frac{1}{r^2}
\cos r ~\mathrm{d}r
&gt; \]</span> &gt; 有意思的是, 如果直接通过计算积分 <span
class="math inline">\(\int_{\mathbb{R}^3} \frac{1}{|\xi|^4} e^{i\xi
\cdot x} \mathrm{d} \xi\)</span> 求解常数 <span
class="math inline">\(C_4\)</span>, 最终会得到上式积分项中关于 <span
class="math inline">\(\sin r\)</span> 部分 &gt; <span
class="math display">\[
&gt; C_4 = 4\pi \int_{0}^{\infty} \frac{1}{r^3} \sin r ~\mathrm{d}r
&gt; \]</span> &gt; 而这个积分是不收敛的</p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>弹性力学</tag>
        <tag>Fourier 变换</tag>
        <tag>Green 函数</tag>
      </tags>
  </entry>
  <entry>
    <title>多尺度 Reduced Order 推导</title>
    <url>/mech/multiscale/%E5%A4%9A%E5%B0%BA%E5%BA%A6-Reduced-Order-%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h3 id="reduced-order-中函数-h_ikl-与细观力学-green-函数的关联">1.
Reduced Order 中函数 <span class="math inline">\(h_{i}^{kl}\)</span>
与细观力学 Green 函数的关联</h3>
<p>在多尺度的单胞问题中, 如果使用本征应变 <span
class="math inline">\(\mu^{\xi}(x)\)</span> 表征材料非弹性的影响,
那么本构方程为:</p>
<p><span class="math display">\[
\sigma^{\xi}(x) = L^{\xi}(x):\left(\varepsilon^{\xi}(x) -
\mu^{\xi}(x)\right)
\]</span></p>
<p>对位移变量进行双尺度渐近展开, 得到</p>
<p><span class="math display">\[
\text{ANSATZ}:u^{\xi}(x) \sim u^{c}(x) + \xi u^{(1)}(x,y) + O(\xi^2)
\]</span></p>
<span id="more"></span>
<p>依照上述 ANSATZ, 同样也可以得到应变,应力,本征应变的渐进展开式: <span
class="math display">\[
\begin{aligned}
\varepsilon^{\xi}(x) &amp;\sim \varepsilon^f(x,y) + \xi
\varepsilon^{(1)}(x,y) + O(\xi^2)\\
\sigma^{\xi}(x) &amp;\sim \sigma^{f}(x,y) + \xi \sigma^{(1)}(x,y) +
O(\xi^2)\\
\mu^{\xi}(x) &amp;\sim \mu^f(x,y) + \xi \mu^{(1)}(x,y) + O(\xi^2)
\end{aligned}
\]</span></p>
<p>通过应力平衡方程, 以及解的存在唯一条件,
可以得到渐进展开式中不同阶次项之间的关系. 其中, fine scale
上的变量之间的关系式为:</p>
<p><span class="math display">\[
\begin{aligned}
\varepsilon^f(x,y) &amp;\triangleq \underbrace{\nabla_x
u^c(x)}_{\triangleq \varepsilon^c} + \nabla_y u^{(1)}(x,y)\\
\sigma^f(x,y) &amp;\triangleq \mathbb{L}(y) : \left( \varepsilon^f(x,y)
- \mu^f(x,y) \right)
\end{aligned}
\tag{1.1}
\]</span></p>
<p>在多尺度中, 单胞内精细的位移场 <span
class="math inline">\(u^{(1)}\)</span> 是通过如下方式进行构造的:</p>
<p><span class="math display">\[
u_i^{(1)}(x,y) = \underbrace{\varepsilon_{kl}^c(x) H_i^{kl}(y) }_{(1)}
+ \underbrace{\int_{Y} \mu_{kl}^f(x,y^{\prime}) h_{i}^{kl}(y,y^{\prime})
\mathrm{d} y^{\prime}}_{(2)}
\tag{1.2}
\]</span></p>
<p>式中, 第 (1) 项只考虑线弹性材料非均质在单胞内部产生的位移场
fluctuation; 第 (2) 项考虑单胞内非弹性的本征应变造成的位移场的扰动. (2)
的构造来源于细观力学 (Mura1987), 由本征应变产生的位移可以写作本征应变与
Green 函数的卷积形式</p>
<p><span class="math display">\[
u_{i}(x) = -\int L_{mnkl} G_{in,m}(x-x^{\prime}) \mu_{kl}(x^{\prime})
\mathrm{d} x^{\prime}
\tag{1.3}
\]</span></p>
<p>观察 (2) 与式 (1.3) 相同的部分, 可以得到</p>
<p><span class="math display">\[
h_{i}^{kl}(y,y^{\prime}) = -L_{mnkl} G_{in,m}(y-y^{\prime})
\tag{1.4}
\]</span></p>
<blockquote>
<p>在细观力学推导 Green 函数过程中, 弹性模量 <span
class="math inline">\(L_{mnkl}\)</span> 看作是常数, 并没有出现作为
Fourier 变换后的函数 <span
class="math inline">\(\hat{L}_{mnkl}\)</span>, 但是单胞问题中, <span
class="math inline">\(L_{mnkl}\)</span> 是分段常数. 我不确定式 (1.4) 中
<span class="math inline">\(L_{mnkl}\)</span> 是不是关于坐标 <span
class="math inline">\(y\)</span> 或 <span
class="math inline">\(y^{\prime}\)</span> 的函数.</p>
</blockquote>
<h3 id="reduced-order-green-函数在-partition-上的积分">2. Reduced Order:
Green 函数在 Partition 上的积分</h3>
<p>在对非均质线弹性单胞问题渐进展开的推导中, 我们得到表征单胞上应变
fluctuation 的张量场 <span class="math inline">\(E_{ij}^{kl}: Y \mapsto
\mathcal{S}\)</span>, 现在我们将要推导表征分块 Partition
上的本征应变的影响张量 <span class="math inline">\(P_{ij}^{kl}:
Y^{(\alpha)} \mapsto \mathcal{S}\)</span>.</p>
<p>多尺度在单胞上 fine-scale 应力满足平衡方程以及边界条件: <span
class="math display">\[
\nabla_{y} \cdot \sigma^{f} = 0, \quad \sigma^{f} \cdot n \in -\#
\]</span></p>
<p>将渐进展开式, 本构方程, 以及关于 <span
class="math inline">\(u_{i}^{(1)}\)</span> 的表达式 (1), (2)
代入到平衡方程中得到</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) \left[ E_{kl}^{mn}(y) \varepsilon_{mn}^c(x) +
\int_{Y} \mu_{mn}^f(x,y^{\prime}) h_{(k,y_l)}^{mn}(y,y^{\prime})
\mathrm{d} y^{\prime} - \mu_{kl}^f(x,y) \right] \right\}_{,y_j} = 0
\]</span></p>
<p>线弹性部分的单胞方程为:</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) E_{kl}^{mn}(y) \right\}_{,y_j} = 0
\tag{2.1}
\]</span></p>
<p>本征应变的单胞方程为</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) \left[ \int_{Y} \mu_{mn}^f(x,y^{\prime})
h_{(k,y_l)}^{mn}(y,y^{\prime}) \mathrm{d} y^{\prime} - \mu_{kl}^f(x,y)
\right] \right\}_{,y_j} = 0
\tag{2.2}
\]</span></p>
<blockquote>
<p>在确定的加载方式下,
分块上的本征应变当然和宏观应变是有着一一对应的关系,
但这并不是说这两个应变就存在着必然的函数关系. 这两个宏观尺度的变量,
在这里我们将视之为相互独立的变量.
至于怎么从这些给定的宏观变量想象单胞具体的加载路径是怎么样的,
不是所有场景都可以想象得到.</p>
</blockquote>
<h5 id="降阶多尺度的分段常值假设">降阶多尺度的分段常值假设:</h5>
<p>将单胞分成若干个 partition: <span class="math inline">\(Y^{(1)},
Y^{(2)}, \ldots, Y^{(N)}\)</span>,并假设每一个 partition 上的本征应变
(以及其它的物理量) 是相同的, 每个 partition 上的本征应变为 <span
class="math inline">\(\mu_{mn}^{(1)}(x), \mu_{mn}^{(1)}(x), \ldots,
\mu_{mn}^{(N)}(x)\)</span>, 由此得到本征应变场是在单胞上的分段常值分布:
<span class="math display">\[
\mu_{mn}^{f}(x,y) := \sum_{\alpha=1}^{N} \mu_{mn}^{(\alpha)}(x)
\chi^{(\alpha)}(y)
\]</span></p>
<p>将分段常值的本征应变场代入到单胞方程 (2.2) 中, 得到 <span
class="math display">\[
\sum_{\alpha=1}^{N} \mu_{mn}^{(\alpha)}(x)\left\{ L_{ijkl}(y) \left[
\int_{Y} h_{(k,y_l)}^{mn}(y,y^{\prime}) \chi^{(\alpha)}(y^{\prime})
\mathrm{d} y^{\prime} - I_{kl}^{mn}\chi^{(\alpha)}(y) \right]
\right\}_{,y_j} = 0
\]</span></p>
<p>上式是关于 <span
class="math inline">\(\mu_{mn}^{(\alpha)}(x)\)</span> 的方程组,
且方程组系数独立于方程变量. 这样, 如果方程组的解空间为 <span
class="math inline">\(\mathbb{R}_N\)</span>, 也就是对任意 <span
class="math inline">\(\mu_{mn}^{(\alpha)}(x) \in \mathbb{R}_N\)</span>,
上述方程恒成立, 则必须要求方程组系数恒等于 0:</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) \left[ \int_{Y} h_{(k,y_l)}^{mn}(y,y^{\prime})
\chi^{(\alpha)}(y^{\prime}) \mathrm{d} y^{\prime} -
I_{kl}^{mn}\chi^{(\alpha)}(y) \right] \right\}_{,y_j} = 0, \quad  \alpha
= 1,2,\ldots,N
\]</span></p>
<p>将 Green 函数在 partition 上的积分定义为</p>
<p><span class="math display">\[
P_{kl}^{mn(\alpha)}(y) \triangleq \int_{Y}
h_{(k,y_l)}^{mn}(y,y^{\prime}) \chi^{(\alpha)}(y^{\prime}) \mathrm{d}
y^{\prime}
\]</span></p>
<p>这样就得到关于张量 <span
class="math inline">\(P_{kl}^{mn(\alpha)}\)</span> 的 <span
class="math inline">\(N\)</span> 个方程:</p>
<p><span class="math display">\[
\left\{ L_{ijkl}(y) \left[ P_{kl}^{mn(\alpha)}(y) -
I_{kl}^{mn}\chi^{(\alpha)}(y) \right] \right\}_{,y_j} = 0, \text{in}~ Y
\quad \alpha=1,2, \ldots,N
\]</span></p>
<h3 id="多尺度得到的单胞分块应变方程">3.
多尺度得到的单胞分块应变方程</h3>
<p><span class="math display">\[
u_i^{(1)}(x,y) = \underbrace{\varepsilon_{kl}^c(x) H_i^{kl}(y) }_{(1)}
+ \underbrace{\int_{Y} \mu_{kl}^f(x,y^{\prime}) h_{i}^{kl}(y,y^{\prime})
\mathrm{d} y^{\prime}}_{(2)}
\]</span></p>
<p>只考虑上式中第 (2) 部分, 也即本征应变对 fine-scale 应变的影响,
那么单胞上的微尺度应变为</p>
<p><span class="math display">\[
\varepsilon_{ij}^{(2)}(x,y) = \int_{Y} h_{(i,y_j)}^{kl}(y,y^{\prime})
\mu_{kl}^{f}(x,y^{\prime}) \mathrm{d} y^{\prime}
\]</span></p>
<p>将 reduced order 分块均匀假设代入上式, 就得到</p>
<p><span class="math display">\[
\varepsilon_{ij}^{(2)}(x,y) = \sum_{\alpha=1}^{N} P_{ij}^{kl(\alpha)}(y)
\mu_{kl}^{(\alpha)}(x)
\]</span></p>
<p>在每一个分块 <span class="math inline">\(Y^{(\alpha)}\)</span> 上对
<span class="math inline">\(\varepsilon^f\)</span> 进行积分平均, 得到
<span class="math display">\[
\varepsilon_{ij}^{(\beta)}(x) = \sum_{\alpha=1}^{N} \langle
P_{ij}^{kl(\alpha)}(y) \rangle_{Y^{(\beta)}} \mu_{kl}^{(\alpha)}(x)
= \sum_{\alpha=1}^{N} P_{ij}^{kl(\beta \alpha)} \mu_{kl}^{(\alpha)}(x)
\tag{3.1}
\]</span> 式中, <span class="math inline">\(P_{ij}^{kl(\beta \alpha)}
\triangleq \langle P_{ij}^{kl(\alpha)}(y)
\rangle_{Y^{(\beta)}}\)</span>.
如果再考虑线弹性材料的非均质性对应变场造成的扰动,
那么该项造成的单胞上的微尺度应变为</p>
<p><span class="math display">\[
\varepsilon_{ij}^{(1)}(x,y) = \varepsilon_{kl}^c(x) H_{(i,y_j)}^{kl}(y)
\]</span> 对上式在分块上进行体平均, 就得到 <span class="math display">\[
\varepsilon_{ij}^{(\beta)}(x) = \varepsilon_{kl}^c(x) \left(
E_{ij}^{kl(\beta)} - I_{ij}^{kl(\beta)} \right)
\tag{3.2}
\]</span> 因此, 分块上的应变, 就等于 ①.宏观尺度的应变 ②.式 (3.1)
本征应变造成的应变扰动场平均 ③.式 (3.2)
线弹性材料不均匀性造成的应变扰动场平均, 所以 <span
class="math display">\[
\begin{aligned}
\varepsilon_{ij}^{(\beta)}(x)
&amp;= \varepsilon_{ij}^{c}(x)
+ \sum_{\alpha=1}^{N} P_{ij}^{kl(\beta \alpha)} \mu_{kl}^{(\alpha)}(x)
+ \varepsilon_{kl}^c(x) \left( E_{ij}^{kl(\beta)} - I_{ij}^{kl(\beta)}
\right) \\
&amp;=  \sum_{\alpha=1}^{N} P_{ij}^{kl(\beta \alpha)}
\mu_{kl}^{(\alpha)}(x)
+ E_{ij}^{kl(\beta)}\varepsilon_{kl}^c(x)
\end{aligned}
\]</span></p>
<h3 id="多尺度得到的宏观物理量">4. 多尺度得到的宏观物理量</h3>
<p>将多尺度得到的结果代入到式 (1.1) 当中 <span class="math display">\[
\sigma^{f}(x,y) = L(y):\left( E(y):\varepsilon^{c}(x)
+ \sum_{\alpha=1}^{N} P^{(\alpha)}(y):\mu^{(\alpha)}(x)
- \sum_{\alpha=1}^{N} I^{(\alpha)}(y):\mu^{(\alpha)}(x)
\right)
\]</span> 式中, <span class="math inline">\(I^{(\alpha)}(y) \triangleq
\chi^{(\alpha)}(y) \mathbb{I}\)</span>. 对上式在单胞上作体积平均, 得到
<span class="math display">\[
\sigma^{c} \triangleq \langle \sigma(x,y) \rangle
= \left\langle L(y):E(y) \right\rangle :\varepsilon^{c}(x)  
+ \sum_{\alpha=1}^{N} \left\langle L(y):
\left(P^{(\alpha)}(y)-I^{(\alpha)}(y)\right) \right\rangle :
\mu^{(\alpha)}(x)
\]</span> 引入记号 <span class="math display">\[
L^{c} \triangleq \left\langle L(y):E(y) \right\rangle , \quad
A^{(\alpha)} \triangleq \left\langle L(y):
\left(P^{(\alpha)}(y)-I^{(\alpha)}(y)\right) \right\rangle
\]</span> 这样宏观应力就可以表示为 <span class="math display">\[
\sigma^{c} = L^{c} : \varepsilon^{c} + \sum_{\alpha=1}^{N}
A^{(\alpha)}:\mu^{(\alpha)}
\]</span> 如果考虑单胞模量是分段常值的, 也即 <span
class="math inline">\(L(y) = \sum_{\alpha} \chi^{(\alpha)}(y)
L^{(\alpha)}\)</span>, 那么 <span
class="math inline">\(A^{(\alpha)}\)</span> 就可以表示为 <span
class="math display">\[
A^{(\alpha)} = \left\langle \sum_{\beta=1}^{N} \chi^{(\beta)}(y)
L^{(\beta)}: \left(P^{(\alpha)}(y)-I^{(\alpha)}(y)\right) \right\rangle
= \sum_{\beta=1}^{N} c^{(\beta)}L^{(\beta)}:P^{(\beta\alpha)} -
c^{(\alpha)} L^{(\alpha)}
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>降阶均匀化</tag>
        <tag>Green 函数</tag>
      </tags>
  </entry>
  <entry>
    <title>应用相容本征应变的降阶均质化方法</title>
    <url>/mech/multiscale/%E5%BA%94%E7%94%A8%E7%9B%B8%E5%AE%B9%E6%9C%AC%E5%BE%81%E5%BA%94%E5%8F%98%E7%9A%84%E9%99%8D%E9%98%B6%E5%9D%87%E8%B4%A8%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="控制方程的渐进展开">控制方程的渐进展开</h2>
<p>位移的渐进展开式为 <span class="math display">\[
u_{i}^{\zeta} = u_{i}^{(0)}(x) + \zeta u_{i}^{(1)}(x,y) +
\mathcal{O}(\zeta^2)
\]</span> 这里已经应用应变渐进展开式 <span
class="math inline">\(\mathcal{O}({\zeta^{-1}})\)</span> 项等于 0,
所以零阶项 <span class="math inline">\(u_{i}^{(0)}\)</span> 只是关于变量
<span class="math inline">\(x\)</span> 的函数. 应变,
本征应变和应力的渐进展开式分别为 <span class="math display">\[
\varepsilon_{ij}^{\zeta} = \varepsilon_{ij}^{(0)} + \zeta
\varepsilon_{ij}^{(1)} + \mathcal{O}(\zeta^2)\\
\mu_{ij}^{\zeta} = \mu_{ij}^{(0)} + \zeta \mu_{ij}^{(1)}
+  \mathcal{O}(\zeta^2) \\
\sigma_{ij}^{\zeta} = \sigma_{ij}^{(0)} + \zeta \sigma_{ij}^{(1)}
+  \mathcal{O}(\zeta^2)
\]</span> 位移,
应变和应力渐进展开式的每一项分别通过几何方程和本构方程联系在一起: <span
class="math display">\[
\varepsilon_{ij}^{\zeta} = u_{(i,j)}^{\zeta}, \quad
\sigma_{ij}^{\zeta} = L_{ijkl} \left( \varepsilon_{kl}^{\zeta} -
\mu_{kl}^{\zeta} \right)
\]</span> 对应得到渐进展开式每一阶的方程为 <span class="math display">\[
\mathcal{O}(1):\varepsilon_{ij}^{(0)} = u_{(i,x_j)}^{(0)} +
u_{(i,y_j)}^{(1)}, \quad
\sigma_{ij}^{(0)} = L_{ijkl} \left( \varepsilon_{kl}^{(0)} -
\mu_{kl}^{(0)} \right)
\]</span> 以下用上标 <span class="math inline">\(\square^{f}\)</span>
表示应变, 本征应变和应力场渐进展开式的零阶项. 将渐进展开项代入到控制方程
<span class="math display">\[
\sigma_{ij,j}^{\zeta} + b_{i}^{\zeta} = 0
\]</span> 得到 <span class="math display">\[
\begin{aligned}
&amp;\mathcal{O}(\zeta^{-1}): \sigma_{ij,y_j}^{f} = 0 \\
&amp;\mathcal{O}(1): \quad \sigma_{ij,x_j}^{f} + \sigma_{ij,y_j}^{(1)} +
b_{i}^{(0)} = 0
\end{aligned}
\]</span></p>
<h2 id="位移的一阶项表示">位移的一阶项表示</h2>
<p>使用影响函数方法, 可以将宏观应变 <span
class="math inline">\(\varepsilon_{ij}^{c} \triangleq
u_{(i,x_j)}^{(0)}\)</span> 与本征应变 <span
class="math inline">\(\mu_{ij}^{f}\)</span> 对位移一阶项 <span
class="math inline">\(u_{i}^{(1)}\)</span> 的影响表示为 <span
class="math display">\[
u_{i}^{(1)} = H_{i}^{mn} \varepsilon_{mn}^{c}
+ \int_{\Theta} h_{i}^{mn}(y,y&#39;) \mu_{mn}^{f}(y&#39;)
\mathrm{d}y&#39;
\]</span> 式中, <span class="math inline">\(H_i^{mn}: \Theta \mapsto
\mathbb{T}^3\)</span> 为位移影响函数 (displacement influence function),
<span class="math inline">\(h_{i}^{mn}: \Theta \mapsto
\mathbb{T}^3\)</span> 为本征应变影响函数 (transformation influence
function for eigenstrain). 函数 <span
class="math inline">\(h_{i}^{mn}\)</span>
也称考虑本征应变的无体力项弹性方程的 Green 函数.</p>
<p>将上式代入到精细尺度下的应变场 <span
class="math inline">\(\varepsilon_{ij}^{f}\)</span>, 得到 <span
class="math display">\[
\varepsilon_{ij}^{f} = E_{ij}^{mn} \varepsilon_{mn}^{c}
+ \int_{\Theta} h_{(i,y_j)}^{mn}(y,y&#39;) \mu_{mn}^{f}(x,y&#39;)
\mathrm{d}y&#39;
\]</span> 式中, <span class="math inline">\(E_{ij}^{mn}: \Theta \mapsto
\mathbb{T}^4\)</span> 为弹性应变影响函数 (elastic strain influence
tensor), 定义为 <span class="math display">\[
E_{ij}^{mn} \triangleq H_{(i,y_j)}^{mn} + I_{ij}^{mn}
\]</span></p>
<h2 id="双相材料">双相材料</h2>
<p>考虑纤维相为弹性材料, 基体相为理想塑性材料并处于理想塑性阶段.
在纤维相上的平均应变 <span class="math inline">\(\Delta
\boldsymbol{\varepsilon}^{(f)} =0\)</span>.
若基体相上施加任意一个本征应变增量 <span class="math inline">\(\Delta
\boldsymbol{\mu}^{(m)}\)</span>, 那么, 根据理想塑性本构关系有: <span
class="math display">\[
\Delta \boldsymbol{\varepsilon}^{(m)} = \Delta \boldsymbol{\mu}^{(m)}
\]</span> 此时宏观应变增量等于 <span class="math display">\[
\Delta \boldsymbol{\varepsilon}^{c}
= c^{(m)} \Delta \boldsymbol{\varepsilon}^{(m)}
+ c^{(f)} \Delta \boldsymbol{\varepsilon}^{(f)}
= c^{(m)} \Delta \boldsymbol{\mu}^{(m)}
\]</span> 单胞上的应力增量应恒等于 0: <span class="math display">\[
\Delta \boldsymbol{\sigma}^{f}
= \mathbb{L}:(\Delta \boldsymbol{\varepsilon}^{f} - \Delta
\boldsymbol{\mu}^{f})
= \mathbb{L}:\mathbb{E}:\Delta \boldsymbol{\varepsilon}^{c}
+ \mathbb{L} : ( \mathbb{P}^{(m)} - \mathbb{I}^{(m)} ) : \Delta
\boldsymbol{\mu}^{(m)} \\
= \mathbb{L} : ( \mathbb{P}^{(m)} + c^{(m)} \mathbb{E} -
\mathbb{I}^{(m)} ) : \Delta \boldsymbol{\mu}^{(m)}
\equiv 0, \quad
\forall \Delta \boldsymbol{\mu}^{(m)}
\]</span> 注意到在各个分块上, 根据先前的假设, 有 <span
class="math display">\[
\Delta \boldsymbol{\sigma}^{(f)} = \Delta \boldsymbol{\sigma}^{(m)} = 0
\]</span> 这要求 <span class="math display">\[
\mathbb{P}^{(fm)} + c^{(m)} \mathbb{E}^{(f)} = 0, \\
\mathbb{P}^{(mm)} + c^{(m)} \mathbb{E}^{(m)} - \mathbb{I} = 0
\]</span></p>
<blockquote>
<p>论文中是得到影响函数的恒等式 <span class="math display">\[
\mathbb{P}^{(m)} + c^{(m)} \mathbb{E} - \mathbb{I}^{(m)} \equiv 0
\]</span> 但是我确实构造不出令应力场增量恒等于 0 的加载过程,
因此很难排除掉纤维相上平均应变等于 0 但应变场不等于的情景.
不过对上式在分块上进行平均后得到的影响张量的代数关系是准确的</p>
</blockquote>
<h2 id="相容的本征应变场">相容的本征应变场</h2>
<p>若本征应变是相容的(compatible or impotent eigenstrain),
那么它可以考虑为某个位移场 <span class="math inline">\(\left(
u_{i}^{\mu} \right)^{\zeta}\)</span> 的梯度,
由此精细尺度下的本征应变场可表示为 <span class="math display">\[
\mu_{ij}^{f}(x,y) = u_{(i,x_j)}^{\mu(0)}(x) + u_{(i,y_j)}^{\mu(1)}(x,y)
\]</span> 类似于宏观应变 <span
class="math inline">\(\varepsilon^{c}\)</span>, 定义宏观本征应变 <span
class="math inline">\(\mu_{ij}^{c}\)</span> <span
class="math display">\[
\mu_{ij}^{c} \triangleq u_{(i,x_j)}^{\mu(0)}
\]</span> 将精细尺度下的本征应变表达式代入到位移的一阶项当中 <span
class="math display">\[
u_{i}^{(1)} = H_{i}^{mn} \varepsilon_{mn}^{c}
+ \int_{\Theta} h_{i}^{mn}(y,y&#39;)\mathrm{d}y&#39; \ \mu_{mn}^{c}
+ \int_{\Theta} h_{i}^{mn}(y,y&#39;) u_{(m,y_n)}^{\mu(1)}(x,y&#39;)
\mathrm{d}y&#39;
\]</span> 再代入到 <span
class="math inline">\(\mathcal{O}(\zeta^{-1})\)</span>
阶的控制方程中得到 <span class="math display">\[
\left\{  
L_{ijkl} E_{kl}^{mn} \varepsilon_{mn}^{c}
+ L_{ijkl} \left( \int_{\Theta}
h_{(k,y_l)}^{mn}(y,y&#39;)\mathrm{d}y&#39; - I_{kl}^{mn} \right)
\mu_{mn}^{c} \\
+ L_{ijkl} \left( \int_{\Theta} h_{(k,y_l)}^{mn}(y,y&#39;)
u_{(m,y_n)}^{\mu(1)} \mathrm{d}y&#39; -u_{(k,y_l)}^{\mu(1)} \right)
\right\}_{,y_j} = 0
\]</span> 方程对任意的宏观应变 <span
class="math inline">\(\varepsilon_{mn}^{c}\)</span> 和宏观本征应变 <span
class="math inline">\(\mu_{mn}^{c}\)</span> 恒成立, 这就得到单胞 <span
class="math inline">\(\Theta\)</span> 上的微分方程 <span
class="math display">\[
\left\{  
L_{ijkl} E_{kl}^{mn}
\right\}_{,y_j} = 0, \\
\left\{  
L_{ijkl} \left( R_{kl}^{mn} - I_{kl}^{mn} \right)
\right\}_{,y_j} = 0, \\
\left\{  
L_{ijkl} \left( \int_{\Theta} h_{(k,y_l)}^{mn}(y,y&#39;)
u_{(m,y_n)}^{\mu(1)} \mathrm{d}y&#39; -u_{(k,y_l)}^{\mu(1)} \right)
\right\}_{,y_j} = 0
\]</span> 式中, $R_{kl}^{mn}: ^4 $, <span
class="math inline">\(R_{kl}^{mn}(y)= \int_{\Theta}
h_{(k,y_l)}^{mn}(y,y&#39;)\mathrm{d}y&#39;\)</span>.
根域位移影响函数的定义和它满足的方程, 可以确定 <span
class="math display">\[
R^{mn}_{kl} \equiv - H_{(k,y_l)}^{mn}
\]</span> 再通过一些数学上的操作可以得到 <span class="math display">\[
\int_{\Theta} h_{(k,y_l)}^{mn}(y,y&#39;) u_{(m,y_n)}^{\mu(1)}
\mathrm{d}y&#39; \equiv u_{(k,y_l)}^{\mu(1)}
\]</span> 这意味着 <span
class="math inline">\(u_{(k,y_l)}^{\mu(1)}\)</span> 对应力场影响为零.
最后得到用相容的本征应变表示的精细尺度下的应变场: <span
class="math display">\[
\varepsilon_{ij}^{f} = E_{ij}^{mn} \varepsilon_{mn}^{c}
- H_{(i,y_j)}^{mn} \mu_{mn}^{c}
+ u_{(i,y_j)}^{\mu(1)}
\]</span></p>
<h3
id="相容本征应变得到的解析本征应变影响张量">相容本征应变得到的解析本征应变影响张量</h3>
<p>类似于降阶均质化方法, 同样设本征应变在单胞 <span
class="math inline">\(\Theta\)</span> 上的分布为分片常值函数: <span
class="math display">\[
\mu_{ij}^{f}(x,y) \approx \sum_{\alpha} \chi^{(\alpha)}(y)
\mu_{ij}^{(\alpha)}(x)
\]</span> 并且考虑精细尺度下的应变场可以通过影响函数表示为 <span
class="math display">\[
\varepsilon_{ij}^{f} = E_{ij}^{mn} \varepsilon_{mn}^{c}
+ \sum_{\alpha}\widetilde{P}_{ij}^{mn, (\alpha)} \mu_{mn}^{(\alpha)}
\]</span> 这就得到本征应变的一阶项与本征应变的影响函数关系为 <span
class="math display">\[
u_{(i,y_j)}^{\mu(1)}
= \sum_{\alpha}\widetilde{P}_{ij}^{mn, (\alpha)} \mu_{mn}^{(\alpha)}
+ H_{(i,y_j)}^{mn} \mu_{mn}^{c}
\]</span> 注意到 <span class="math inline">\(\mu_{ij}^{f} = \mu_{ij}^{c}
+ u_{(i,y_j)}^{\mu(1)}\)</span>, 将上式代入得到 <span
class="math display">\[
\sum_{\alpha} \chi^{(\alpha)}\mu_{ij}^{(\alpha)}
= \sum_{\alpha}\widetilde{P}_{ij}^{mn, (\alpha)} \mu_{mn}^{(\alpha)}
+ E_{ij}^{mn} \mu_{mn}^{c}
\]</span> 并且宏观本征应变等于各个分块上的本征应变的体积平均: <span
class="math display">\[
\mu_{mn}^{c} = \sum_{\alpha} c^{(\alpha)} \mu_{mn}^{(\alpha)}
\]</span> 得到 <span class="math display">\[
\sum_{\alpha} \left(
\widetilde{P}_{ij}^{mn, (\alpha)}
+ c^{(\alpha)} E_{ij}^{mn}
- I_{ij}^{mn,(\alpha)}\right)
\mu_{mn}^{(\alpha)} \equiv 0
\]</span> 对分块上的任意本征应变 <span class="math inline">\(\{
\mu_{mn}^{(\alpha)} \}\)</span>, 上式应恒成立,
最终得到关于本征应变影响函数的<strong>解析形式:</strong> <span
class="math display">\[
\widetilde{P}_{ij}^{mn, (\alpha)} \triangleq I_{ij}^{mn,(\alpha)} -
c^{(\alpha)} E_{ij}^{mn}, \quad
\forall \alpha
\]</span> 以及求取分块平均之后的代数形式: <span class="math display">\[
\widetilde{P}_{ij}^{mn(\beta\alpha)}
\triangleq \delta_{\alpha \beta} I_{ij}^{mn} - c^{(\alpha)}
E_{ij}^{mn(\beta)}, \quad
\forall \alpha
\]</span> 需要指出的是,
只有在<strong>基体主导下</strong>的变形模式才会使用如上形式的本征应变影响函数,
这是为了解决使用不相容本征应变推导得到的基体相单分块影响函数,
在基体变形主导的模式下锁定夹杂项的变形,
导致宏观表征出的应力应变关系刚度太大.
这在数值上意味着针对于基体主导的变形模式,
对求解偏微分方程得到的本征应变影响张量 <span
class="math inline">\([P_{ij}^{mn}]\)</span> 的<strong>列向量</strong>
按照上式进行修正. ==在代码实现时, 要保证修正前后张量 <span
class="math inline">\(A_{ij}^{mn}\)</span> 列向量中的最小值相等==</p>
<blockquote>
<p>为判断主导的变形模式(对于三维情景,
变形模式分为三个方向上的拉伸和剪切),
可以固定基体项和夹杂项为<strong>各向同性线弹性</strong>材料,
基体相和夹杂相的模量分别设置为 <span class="math inline">\(1.0\)</span>
和 <span class="math inline">\(10^{-8}\)</span>, 泊松比等于 <span
class="math inline">\(0.0\)</span>, 根据均质化之后的宏观弹性模量计算得到
<span class="math inline">\(E_1\)</span>, <span
class="math inline">\(E_2\)</span>, <span
class="math inline">\(E_3\)</span>, <span
class="math inline">\(G_{23}\)</span>, <span
class="math inline">\(G_{13}\)</span>, <span
class="math inline">\(G_{12}\)</span>, 然后对比模量的阶次,
确定主导的变形模式.</p>
</blockquote>
<p>根据定义,
可以知道本征应变影响张量和弹性应变影响张量之间有如下解析关系: <span
class="math display">\[
\sum_{\beta} {P}_{kl}^{mn(\alpha\beta)}
+ E_{kl}^{mn(\alpha)}
- I_{kl}^{mn}
= 0, \quad \alpha=1,2,\ldots,N
\]</span> 修正得到的本征应变影响张量同样满足与上式相同的恒等式:</p>
<p><span class="math display">\[
\sum_{\beta} \widetilde{P}_{kl}^{mn(\alpha\beta)}
+ E_{kl}^{mn(\alpha)}
- I_{kl}^{mn}
= 0, \quad \alpha=1,2,\ldots,N
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>降阶均质化</tag>
        <tag>本征应变</tag>
        <tag>影响函数</tag>
      </tags>
  </entry>
  <entry>
    <title>降阶均质化方法层级分块计算</title>
    <url>/mech/multiscale/%E9%99%8D%E9%98%B6%E5%9D%87%E8%B4%A8%E5%8C%96%E6%96%B9%E6%B3%95%E5%B1%82%E7%BA%A7%E5%88%86%E5%9D%97%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2
id="在有限元求解框架下的增量步与迭代步">在有限元求解框架下的增量步与迭代步</h2>
<p>降阶均质化方法是在 ABAQUS UMAT 层面实现的. ABAQUS
在每个增量步的迭代步时调用 UMAT, 考虑有限元计算框架中第 <span
class="math inline">\(n\)</span> 个增量步, 第 <span
class="math inline">\(i+1\)</span> 个迭代步. 在进入 UMAT 时, 已知前
<span class="math inline">\(n-1\)</span> 个增量步的历史信息,
和当前迭代步 <span class="math inline">\(i+1\)</span> 的位移.
为了使接下来方程的增量表达式更加清晰, 首先引入以下增量记号,
它们写在力学变量之前, 表示不同的含义:</p>
<ul>
<li>记号 <span class="math inline">\(\delta\)</span>
表示变量该迭代步的<strong>校正量</strong>;</li>
<li>记号 <span class="math inline">\(\Delta_{n}^{i+1}\)</span> 表示在第
<span class="math inline">\(i+1\)</span> 个迭代步时确定的第 <span
class="math inline">\(n\)</span> 个增量步的增量. 若在第 <span
class="math inline">\(i+1\)</span> 个迭代步收敛, 那么 <span
class="math inline">\(\Delta_{n} :=\Delta_{n}^{i+1}\)</span>.</li>
</ul>
<p>我们再引入花括号 <span class="math inline">\(\{\cdot\}\)</span>
表示分块物理量的集合. 例如 <span class="math inline">\(\{ \Delta
\varepsilon \}\)</span> 表示分块上的应变 <span
class="math inline">\(\Delta \varepsilon^{(\alpha)}\)</span>, <span
class="math inline">\(\alpha=1,2,\ldots,N\)</span>.</p>
<h2 id="降阶多尺度计算">降阶多尺度计算</h2>
<p>在接下来的记号中, 使用 <span class="math inline">\([\cdot]\)</span>
表示应用 Voigt 记法矩阵化的张量; <span
class="math inline">\([:]=\mathrm{diag}(1,1,1,2,2,2)\)</span>, <span
class="math inline">\([\boldsymbol{\epsilon}]\)</span> 和 <span
class="math inline">\([\boldsymbol{\varepsilon}]\)</span>
分别表示张量应变和工程应变, <span
class="math inline">\([:][\boldsymbol{\epsilon}]=[\boldsymbol{\varepsilon}]\)</span>.
计算在第 <span class="math inline">\(n+1\)</span>
步时各分块上的平均应变分量. 待求解的方程为 <span class="math display">\[
\boldsymbol{\epsilon}_{n+1}^{(\beta)} = \mathbb{E}^{(\beta)} :
\boldsymbol{\epsilon}_{n+1}^{c}
+ \sum_{\alpha} \mathbb{P}^{(\beta\alpha)} :
\boldsymbol{\mu}_{n+1}^{(\alpha)}
\tag{1}
\]</span> 写成增量形式, 并定义残差函数为 <span class="math display">\[
\boldsymbol{r}^{(\beta)}(\{ \Delta \boldsymbol{\epsilon}^{(\alpha)}  \})
\triangleq
\Delta \boldsymbol{\epsilon}^{(\beta)}
- \mathbb{E}^{(\beta)} : \Delta \boldsymbol{\epsilon}^{c}
- \sum_{\alpha} \mathbb{P}^{(\beta\alpha)} : \Delta
\boldsymbol{\mu}^{(\alpha)}
\]</span> 应用 Voigt 记法, 将上述张量方程写成矩阵形式为 <span
class="math display">\[
\left[ \boldsymbol{r}^{(\beta)} \right]
= \left[ \Delta \boldsymbol{\epsilon}^{(\beta)}  \right]
- \left[ \mathbb{E}^{(\beta)} \right] \left[ \Delta
\boldsymbol{\varepsilon}^{c} \right]
- \sum_{\alpha} \left[ \mathbb{P}^{(\beta\alpha)} \right] \left[ \Delta
\boldsymbol{\varkappa}^{(\alpha)} \right]
\]</span> 式中, <span class="math inline">\(\left[ \Delta
\boldsymbol{\varkappa}^{(\alpha)} \right]_{i} = [:]\left[ \Delta
\boldsymbol{\mu}^{(\alpha)} \right]_{i}\)</span> 上式对平均应变求偏导数,
就得到 Newton 迭代法中 Jacobian 矩阵的表达式: <span
class="math display">\[
\frac{ \partial \left[ \boldsymbol{r}^{(\beta)} \right]}{ \partial
\left[ \Delta \boldsymbol{\varepsilon}^{(\gamma)}  \right]}
= \delta^{\beta\gamma} [:]^{-1}
- \sum_{\alpha} \left[ \mathbb{P}^{(\beta\alpha)} \right]
\frac{ \partial \left[ \Delta \boldsymbol{\varkappa}^{(\alpha)}
\right]}{ \partial \left[ \Delta
\boldsymbol{\varepsilon}^{(\gamma)}  \right]}
\]</span> 由于假设分块上的本征应变只与该分块上的平均应变相关, 所以 <span
class="math display">\[
\frac{ \partial \left[ \boldsymbol{r}^{(\beta)} \right]}{ \partial
\left[ \Delta \boldsymbol{\varepsilon}^{(\gamma)}  \right]}
= \delta^{\beta\gamma} [:]^{-1}
- \left[ \mathbb{P}^{(\beta\gamma)} \right]
\frac{ \partial \left[ \Delta \boldsymbol{\varkappa}^{(\gamma)}
\right]}{ \partial \left[ \Delta
\boldsymbol{\varepsilon}^{(\gamma)}  \right]}
\]</span></p>
<h2 id="多层级分块状态变量">多层级分块状态变量</h2>
<p>应用 ROH 作为材料本构进行计算时, 状态变量可分为两类:</p>
<ul>
<li>各分块非弹性材料演化时的历史状态变量,
称为<strong>材料状态变量</strong>;</li>
<li>多尺度方程引入的状态变量, 比如分块上的平均应变和平均应力等,
称为<strong>多尺度状态变量</strong>.</li>
</ul>
<p>新引入分块层级状态变量 <code>MESFE_P5001226_NSV_NCLUSTER</code>,
并在结构体 <code>ROH_ptn6</code> 中加入新的数据 <code>cidx</code>,
标识分块所属分块组序号. 分块组所对应的分块编号通过外部文件读取.
根据概念大小, 有如下包含关系: <span class="math display">\[
\text{Partition} \subseteq \text{PTNGroup} \subset \text{Phase}
\]</span></p>
<h2 id="ptngrp-状态变量更新">PTNGRP 状态变量更新</h2>
<p>设在当前增量步时, PTNGRP 的数量为为 <code>NPTNGRP(int)</code>.
首先更新分块所属分块组的序号, 然后组装分块组, 分块组的数据类型也是是
<code>ROH_ptn6</code>, 接下来降阶多尺度方程的求解在分块组层级上执行.
分块组状态变量应等于分块组所包含的任意单胞分块上的状态变量:</p>
<p><span class="math display">\[
\left[ \boldsymbol{\sigma}^{\langle \alpha \rangle} \right]^{n}
:= \left[ \boldsymbol{\sigma}^{(\alpha_{i})} \right]^{n}, \quad
\left[ \boldsymbol{\varepsilon}^{\langle \alpha \rangle} \right]^{n}
:= \left[ \boldsymbol{\varepsilon}^{(\alpha_{i})} \right]^{n}, \quad
\left[ \mathbb{E}_{\mathrm{tan}}^{\langle \alpha \rangle} \right]^{n}
\triangleq \frac{ \partial \left[ \Delta
\boldsymbol{\varepsilon}^{\langle \alpha \rangle} \right]^{n} }
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{c} \right]^{n} }
:= \frac{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{(\alpha_{i})}
\right]^{n} }
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{c} \right]^{n} }
\]</span> 注意, 对于某一 分块组所拥有的<strong>所有子分块</strong>,
它们的材料和多尺度状态变量应该是<strong>完全相同</strong>的: <span
class="math display">\[
\left[ \boldsymbol{\sigma}^{(\alpha_{i})} \right]^{n}
= \left[ \boldsymbol{\sigma}^{(\alpha_{j})} \right]^{n}, \quad
\left[ \boldsymbol{\varepsilon}^{(\alpha_{i})} \right]^{n}
= \left[ \boldsymbol{\varepsilon}^{(\alpha_{j})} \right]^{n}, \quad
\left[ \mathbb{E}_{\mathrm{tan}}^{(\alpha_{i})} \right]^{n}
= \left[ \mathbb{E}_{\mathrm{tan}}^{(\alpha_{j})} \right]^{n} \\
\alpha_{i},\alpha_{j} \in \{ i \mid \text{Partition}(i) \subseteq
\text{PTNGRP} \langle \alpha \rangle \}
\]</span> 式中, <span class="math inline">\(\langle \alpha
\rangle\)</span> 表示分块组的编号, <span
class="math inline">\((\alpha_{i})\)</span> 表示分块的编号.
分块组的材料状态变量初始化为上一次增量步最终收敛得到的值: <span
class="math display">\[
\left[ \mathrm{statv}^{\langle \alpha \rangle} \right]_{0} := \left[
\mathrm{statv}^{(\alpha_{i})} \right]^{n}
\]</span> 应用上一增量步计算得到的瞬时应变影响张量, 根据当前宏观应变增量
<span class="math inline">\(\left[ \Delta \boldsymbol{\varepsilon}^{c}
\right]\)</span>, 更新各个分块组的初始平均应变增量: <span
class="math display">\[
\left[ \Delta \boldsymbol{\varepsilon}^{\langle \alpha \rangle}
\right]_{1}
:= \left[ \mathbb{E}_{\mathrm{tan}}^{\langle \alpha \rangle} \right]^{n}
\left[ \Delta \boldsymbol{\varepsilon}^{c} \right]
\]</span> 接下来应用 Newton 迭代法迭代求解各个分块组的平均应变. 设在第
<span class="math inline">\(i\)</span> 次迭代步时分块组的平均应变增量为
<span class="math inline">\(\left[ \Delta \varepsilon^{\langle \alpha
\rangle} \right]_{i}\)</span>,代入到各相材料的 UMAT 中进行计算,
得到相应的应力, 一致切线模量和状态变量:</p>
<ul>
<li><p>输入: <span class="math inline">\(\left[ \Delta
\boldsymbol{\varepsilon}^{\langle \alpha \rangle} \right]_{i}\)</span>
<span class="math inline">\(\left[ \mathrm{statv}^{\langle \alpha
\rangle} \right]^{n}\)</span></p></li>
<li><p>输出: <span
class="math inline">\(\left[\boldsymbol{\sigma}^{\langle \alpha \rangle}
\right]_{i} := \left[\boldsymbol{\sigma}^{\langle \alpha \rangle}
\right]^{n} + \left[ \Delta \boldsymbol{\sigma}^{\langle \alpha \rangle}
\right]_{i}\)</span> <span class="math inline">\(\frac{ \partial \left[
\Delta \boldsymbol{\sigma}^{\langle \alpha \rangle} \right]_{i} } {
\partial \left[ \Delta \boldsymbol{\varepsilon}^{\langle \alpha \rangle}
\right]_{i} }\)</span> <span class="math inline">\(\left[
\mathrm{statv}^{\langle \alpha \rangle} \right]_{i}\)</span></p></li>
</ul>
<p>更新本征应变: <span class="math display">\[
\left[ \boldsymbol{\varkappa}^{\langle \alpha \rangle} \right]_{i}
:= \left[ \boldsymbol{\varepsilon}^{\langle \alpha \rangle} \right]^{n}
+ \left[ \Delta \boldsymbol{\varepsilon}^{\langle \alpha \rangle}
\right]_{i}
- [\mathbb{L}^{\langle \alpha \rangle}]^{-1}  : \left[
\boldsymbol{\sigma}^{\langle \alpha \rangle} \right]_{i}
\]</span> 以及本征应变关于分块应变的偏导数 <span class="math display">\[
\frac{ \partial \left[ \Delta \boldsymbol{\varkappa}^{\langle \alpha
\rangle} \right]_{i} }
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{\langle \alpha
\rangle} \right]_{i} }
= [\boldsymbol{I}] - [\mathbb{L}^{\langle \alpha \rangle}]^{-1}
\frac{ \partial \left[ \Delta \boldsymbol{\sigma}^{\langle \alpha
\rangle} \right]_{i} }
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{\langle \alpha
\rangle} \right]_{i} }
\]</span></p>
<p>由此得到残差和 Jacobian 子矩阵分别为 $$ <em>{i} = </em>{i} - - <em>{}
</em>{i}, \</p>
<p>[]<em>{i}^{} { </em>{i}} = ^{} [:]^{-1} - { _{i}} $$</p>
<p>组装多尺度系统的 Jacobian 矩阵 <span
class="math inline">\([\mathbf{A}]_{i}\)</span>,
得到分块组的平均应变迭代增量为 <span class="math display">\[
\left[ \delta \boldsymbol{\varepsilon} \right]_{i+1}
= -[\mathbf{A}]_{i}^{-1}
\left[ \boldsymbol{r} \right]_{i}
\]</span> 并更新 <span class="math inline">\(i+1\)</span>
步的分块组平均应变:</p>
<p><span class="math display">\[
\left[ \Delta \boldsymbol{\varepsilon}^{\langle \alpha \rangle}
\right]_{i+1}
= \left[ \Delta \boldsymbol{\varepsilon}^{\langle \alpha \rangle}
\right]_{i}
+ \left[ \delta \boldsymbol{\varepsilon}^{\langle \alpha \rangle}
\right]_{i+1}
\]</span></p>
<p>判断迭代收敛之后, 跳出 Newton 迭代过程, 继续判断是否需要分裂分块组.
如果需要分裂分块组, 那么更新分块组的数量 <span class="math display">\[
\mathrm{NCLUSTER} := \mathrm{NCLUSTER} + 1
\]</span> 继续重复这一步的过程. 如果不需要分裂分块组的数量,
那么确定最后一次迭代量为当前增量步的增量 <span
class="math inline">\(\left[ \boldsymbol{\sigma}^{\langle \alpha
\rangle} \right]^{n+1}\)</span> <span class="math inline">\(\frac{
\partial \left[ \Delta \boldsymbol{\sigma}^{\langle \alpha \rangle}
\right]^{n+1} } { \partial \left[ \Delta
\boldsymbol{\varepsilon}^{\langle \alpha \rangle} \right]^{n+1}
}\)</span> <span class="math inline">\(\left[ \mathrm{statv}^{\langle
\alpha \rangle} \right]^{n+1}\)</span>
并以此计算宏观应力和宏观一致切线模量: <span class="math display">\[
\left[ \boldsymbol{\sigma}^{c} \right]^{n+1}
= \sum_{\alpha} c^{\langle \alpha \rangle} \left[
\boldsymbol{\sigma}^{\langle \alpha \rangle} \right]^{n+1}, \\
\frac{ \partial \left[ \Delta \boldsymbol{\sigma}^{c} \right]^{n+1} }
{ \partial \left[ \Delta  \boldsymbol{\varepsilon}^{c} \right]^{n+1} }
= \sum_{\alpha} c^{\langle \alpha \rangle}
\frac{ \partial \left[ \Delta \boldsymbol{\sigma}^{\langle \alpha
\rangle} \right]^{n+1} }
{ \partial \left[ \Delta  \boldsymbol{\varepsilon}^{\langle \alpha
\rangle} \right]^{n+1} }
\frac{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{\langle \alpha
\rangle} \right]^{n+1} }
{ \partial \left[ \Delta  \boldsymbol{\varepsilon}^{c} \right]^{n+1} }
= \sum_{\alpha} c^{\langle \alpha \rangle}
\frac{ \partial \left[ \Delta \boldsymbol{\sigma}^{\langle \alpha
\rangle} \right]^{n+1} }
{ \partial \left[ \Delta  \boldsymbol{\varepsilon}^{\langle \alpha
\rangle} \right]^{n+1} }
\left[ \mathbb{E}_{\mathrm{tan}}^{\langle \alpha \rangle} \right]^{n+1}
\]</span> 式中, <span class="math inline">\(\left[
\mathbb{E}_{\mathrm{tan}}^{\langle \alpha \rangle}
\right]^{n+1}\)</span> 为瞬时应变影响张量, 对式 (1)
关于宏观应变增量求偏导数得到 <span class="math display">\[
[:]^{-1}\frac{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{\langle
\beta \rangle} \right]^{n+1} }
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{c} \right]^{n+1} }
= \left[ \mathbb{E}^{\langle \beta \rangle} \right]
+ \sum_{\gamma} \left[  \mathbb{P}^{\langle \beta\gamma \rangle} \right]
\frac{ \partial \left[ \Delta \boldsymbol{\varkappa}^{\langle
\gamma\rangle} \right]^{n+1}}
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{\langle
\gamma\rangle}  \right]^{n+1}}
\frac{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{\langle
\gamma\rangle} \right]^{n+1}}
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{c}  \right]^{n+1}}
\]</span> 移项之后, 得到 <span class="math display">\[
\sum_{\gamma}  [\mathbf{A}]_{i}^{\langle \beta \gamma \rangle}
\frac{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{\langle
\gamma\rangle} \right]^{n+1}}
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{c}  \right]^{n+1}}
= \left[ \mathbb{E}^{\langle \beta \rangle} \right]
\]</span> 所以 <span class="math display">\[
\frac{ \partial \left[ \Delta \boldsymbol{\varepsilon} \right]^{n+1}}
{ \partial \left[ \Delta \boldsymbol{\varepsilon}^{c}  \right]^{n+1}}
= [\mathbf{A}]_{i}^{-1} \left[ \mathbb{E} \right]
\]</span> 最后再根据分块组更新后的状态变量, 更新所属分块的状态变量:
<span class="math display">\[
\left[ \boldsymbol{\sigma}^{(\alpha_{i})} \right]^{n+1}
:= \left[ \boldsymbol{\sigma}^{\langle \alpha \rangle} \right]^{n+1},
\quad
\left[ \boldsymbol{\varepsilon}^{(\alpha_{i})} \right]^{n+1}
:= \left[ \boldsymbol{\varepsilon}^{\langle \alpha \rangle}
\right]^{n+1}, \quad
\left[ \mathbb{E}_{\mathrm{tan}}^{(\alpha_{i})} \right]^{n+1}
:= \left[ \mathbb{E}_{\mathrm{tan}}^{\langle \alpha \rangle}
\right]^{n+1}
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>降阶均匀化</tag>
        <tag>Newton-Raphson 迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>本征应变是不协调的应变</title>
    <url>/mech/multiscale/%E6%9C%AC%E5%BE%81%E5%BA%94%E5%8F%98%E6%98%AF%E4%B8%8D%E5%8D%8F%E8%B0%83%E7%9A%84%E5%BA%94%E5%8F%98/</url>
    <content><![CDATA[<p>这里的公式编号与 Mura 保持一致.</p>
<p>考虑如图所示的弹性体, 想象其中有一根细长杆,
在周围弹性介质的作用下发生变形, 其构型为 <span
class="math inline">\(AP\)</span>. 将周围的弹性介质 <span
class="math inline">\(D\)</span> 移除之后, 细长杆恢复原来的形貌, 构型为
<span class="math inline">\(AP&#39;\)</span>. 点 <span
class="math inline">\(P\)</span> 处不仅发生了位移, 并且如果考虑固连在点
<span class="math inline">\(P\)</span> 处的坐标系, 在变形前后,
该坐标系会产生旋转. 接下来我们将通过公式推导得到刻画点 <span
class="math inline">\(P\)</span>​ 的位移与旋转.</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202405311043584.png" alt="image-20240531104312495" style="zoom: 50%;" /></p>
<p>在进行推导之前, 我们需要再强调一下变形与自由构型的符号</p>
<ul>
<li>变形体: <span class="math inline">\(AP\)</span></li>
<li>自由体: <span class="math inline">\(AP&#39;\)</span></li>
</ul>
<p>首先刻画的是细长杆中任意微元 <span class="math inline">\(\mathrm{d}
s\)</span> 的应变 <span class="math inline">\(e_{ij}\)</span> 与端点位移
<span class="math inline">\(u_i\)</span>​ 之间的关系. 因为是弹性应变,
所以有 <span class="math display">\[
e_{ij} = -\frac{1}{2} \left( \frac{\delta u_i}{\delta x_j} +
\frac{\delta u_j}{\delta x_i} \right)
\tag{10.1}
\]</span> 需要强调的是, 上述应变公式是定义在曲线 <span
class="math inline">\(AP\)</span> 上的, 负号是因为我们考虑的是从变形体
<span class="math inline">\(AP\)</span> 到自由体 <span
class="math inline">\(AP&#39;\)</span> 的位移. <span
class="math inline">\(\delta u_i\)</span> 是沿着弧长微元 <span
class="math inline">\(\mathrm{d} s = (\delta x_i \delta
x_i)^{1/2}\)</span> 位移的变化量. 类似的, 可以得到坐标系的旋转矩阵 <span
class="math inline">\(\omega_{ij}\)</span> 为 <span
class="math display">\[
\omega_{ij} = -\frac{1}{2} \left( \frac{\delta u_j}{\delta x_i} -
\frac{\delta u_i}{\delta x_j} \right)
\tag{10.1}
\]</span> 由此得到微元 <span class="math inline">\(\delta u_i\)</span>
与 <span class="math inline">\(\delta x_i\)</span> 之间的关系: <span
class="math display">\[
\delta u_i = -(e_{ij} - \omega_{ij}) \delta x_j
\tag{10.2}
\]</span> 接下来推导旋度矩阵的微元 <span class="math inline">\(\delta
\omega_{ij}\)</span> 与 <span class="math inline">\(\delta x_i\)</span>
之间的关系. 对应变 <span class="math inline">\(e_{ij}\)</span> 求偏导数,
就得到 <span class="math display">\[
\begin{aligned}
e_{kj,i} = -\frac{1}{2} \left( \frac{\partial ~}{\partial x_i}
\frac{\delta u_k}{\delta x_j}
+ \frac{\partial ~}{\partial x_i} \frac{\delta u_j}{\delta x_k}
\right)\\
e_{ki,j} = -\frac{1}{2} \left( \frac{\partial ~}{\partial x_j}
\frac{\delta u_k}{\delta x_i}
+ \frac{\partial ~}{\partial x_j} \frac{\delta u_i}{\delta x_k} \right)
\end{aligned}
\]</span> <em>这怎么看都有点不太合理, 因为使用记号 <span
class="math inline">\(\delta\)</span> 是为了和偏导数进行区别,
但是为什么在这里又可以直接作用偏导数呢? 这不是我熟悉的语言</em></p>
<p>两式相减, 就得到 <span class="math display">\[
e_{kj,i} - e_{ki,j}
= -\frac{1}{2} \left( \frac{\partial ~}{\partial x_i} \frac{\delta
u_j}{\delta x_k}
- \frac{\partial ~}{\partial x_j} \frac{\delta u_i}{\delta x_k}
\right)
\]</span> 这里用到了 (????) <span class="math display">\[
\frac{\partial ~}{\partial x_i} \frac{\delta u_k}{\delta x_j}
= \frac{\partial ~}{\partial x_j} \frac{\delta u_k}{\delta x_i}
\]</span> 两边乘 <span class="math inline">\(\delta x_k\)</span>,
再根据式 (2), 就得到 <span class="math display">\[
\delta \omega_{ij} = (e_{kj,i} - e_{ki,j}) \delta x_k
\tag{10.7$&#39;$}
\]</span> 上式也可以用置换张量写作 <span class="math display">\[
\delta \omega_{ij} = \epsilon_{hij} \epsilon_{hlm} e_{km,l} \delta x_k
\tag{10.7}
\]</span> <em>(<span class="math inline">\(\epsilon_{hij} \epsilon_{hlm}
= \delta_{il}\delta_{jm} - \delta_{im}\delta_{jl}\)</span>)</em></p>
<p>对式 (1) (2) 沿 <span class="math inline">\(AP\)</span> 进行路径积分,
就得到 <span class="math inline">\(P\)</span>​ 点处的位移和旋转矩阵:
<span class="math display">\[
\begin{aligned}
    u_i &amp;= -\int_{A}^{P}(e_{ij} - \omega_{ij}) ~\mathrm{d} x_j \\
    \omega_{ij} &amp;= \int_{A}^{P} \epsilon_{hij} \epsilon_{hlm}
e_{km,l} ~\mathrm{d} x_k
\end{aligned}
\]</span> 以及初始条件 <span class="math display">\[
u_i = 0, \quad \omega_{ij} = 0, \quad at ~~ A
\]</span> 如果考虑一个封闭的积分路径, 也即 <span
class="math inline">\(A\)</span> 与 <span
class="math inline">\(P\)</span> 重合, 并将环路末端点 <span
class="math inline">\(P\)</span>​ 的位移与旋转称为 dislocation 和
disclination, 那么, 根据上面的推导过程有 <span class="math display">\[
\begin{aligned}
    u_i &amp;= -\oint_{C}(e_{ij} - \omega_{ij}) ~\mathrm{d} x_j \\
    \omega_{ij} &amp;= \oint_{C} \epsilon_{hij} \epsilon_{hlm} e_{km,l}
~\mathrm{d} x_k
\end{aligned}
\]</span> 环路曲线 <span class="math inline">\(C\)</span> 又称为 Burgers
环路. (应该在第七章有过讨论)</p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202405311348119.png" alt="image-20240531134851992" style="zoom: 40%;" /></p>
<p><img src="https://raw.githubusercontent.com/qiuxiaohuo/picgo-bed/main/figs/202405311355932.png" alt="image-20240531135522807" style="zoom: 50%;" /></p>
<p>应用 Stokes 定理: <span class="math display">\[
\nabla \times v =
\begin{vmatrix}
e_1 &amp; e_2 &amp; e_3 \\
_{,1} &amp; _{,2} &amp; _{,3} \\
v_1 &amp; v_2 &amp; v_3
\end{vmatrix}
= \epsilon_{ijk} e_k v_{j,i}
\]</span></p>
<p><span class="math display">\[
\oint_{C} f \cdot \mathrm{d}x = \iint_S \nabla \times f \cdot n
~\mathrm{d}S
\]</span></p>
<p>写成指标形式 <span class="math display">\[
\oint_{C} f_i ~\mathrm{d}x_i = \iint_S \epsilon_{ijk} n_k
f_{j,i}  ~\mathrm{d}S
\]</span></p>
<p><span class="math display">\[
\omega_{ij} = \iint_{S} \epsilon_{hij} \epsilon_{qpk} \epsilon_{hlm}
e_{km,lp}
n_q~\mathrm{d} S
= \iint_{S} \epsilon_{hij} R_{hq} n_q ~\mathrm{d} S
\tag{10.12}
\]</span></p>
<p><span class="math display">\[
R_{qh} \triangleq \epsilon_{qpk} \epsilon_{hlm} e_{km,lp}
\tag{10.13}
\]</span></p>
<p>张量 <span class="math inline">\(R_{qh}\)</span> 的对称性来自于 <span
class="math inline">\(e_{km}\)</span> 的指标 <span
class="math inline">\(k \leftrightarrow m\)</span> 对称, 以及求导次序
<span class="math inline">\(l \leftrightarrow p\)</span> 可以交换. <span
class="math display">\[
u_i = -\oint_{C} (e_{ij} - \omega_{ij}) ~\mathrm{d} x_j
\]</span> 没办法直接应用 Stokes 公式转换到面 <span
class="math inline">\(S\)</span> 上的积分, 因为 <span
class="math inline">\(\omega_{ij}\)</span>
没办法直接求偏导数????对上式分部积分得到 <span class="math display">\[
u_i = -\oint_{C} e_{ij} ~\mathrm{d} x_j + \oint_{C} \omega_{ij}
~\mathrm{d}x_j
= -\oint_{C} e_{ij} ~\mathrm{d} x_j - \oint_{C} \delta\omega_{ij}x_j
+ \left.\omega_{ij}x_j\right|_{C}
\]</span> 以下得到的结果我没有办法理解, 这里只是将下一步的公式抄下来
<span class="math display">\[
u_i = \underbrace{-\oint_{C} e_{ij} ~\mathrm{d} x_j}_{\equiv 0}
- \oint_{C} x_j \epsilon_{hij} \epsilon_{hlm} e_{km,l} \mathrm{d} x_k
+ \underbrace{\left.\omega_{ij}x_j\right|_{C}}_{\equiv \omega_{ij}x_j^0}
\]</span> 整理一下得到 <span class="math display">\[
u_i = \omega_{ij}x_j^0
- \iint_{S} x_j \epsilon_{hij} R_{hq} n_q ~\mathrm{d} S
\tag{10.15}
\]</span></p>
<p>式中的 <span class="math inline">\(\omega_{ij}x_j^0\)</span>
还可以写作 <span class="math display">\[
\omega_{ij}x_j^0 = x_i^{\prime}-O_i^{\prime} - (x_i - O_i)
\triangleq (ox)_i^{\prime} - (ox)_i
\]</span> 这样就相对更容易理解式 (10.15), 移项得到 <span
class="math display">\[
(ox)_i + u_i - (ox)_i^{\prime} = - \iint_{S} x_j \epsilon_{hij} R_{hq}
n_q ~\mathrm{d} S
\]</span> 上式左端项就等于固连在点 <span
class="math inline">\(A\)</span> 处的坐标系变形前后, 坐标系端点 <span
class="math inline">\(oo&#39;\)</span> 之间的距离, 定义为 <span
class="math display">\[
\boxed{
\xi_i \triangleq - \iint_{S} x_j \epsilon_{hij} R_{hq} n_q ~\mathrm{d} S
}
\tag{10.17}
\]</span> 应变协调条件为 <span class="math display">\[
\epsilon_{pki} \epsilon_{qlj} \varepsilon_{ij,kl} = 0 \\
\]</span> 注意到张量 <span class="math inline">\(R_{hq}\)</span>
的定义式 (10.13). 如果应变 <span class="math inline">\(e_{ij}\)</span>​
是协调的, 那么 <span class="math display">\[
R_{hq} \equiv 0
\]</span> 如果考虑应变 <span
class="math inline">\(\varepsilon_{ij}\)</span> 中还包含本征应变 <span
class="math inline">\(\mu_{ij}\)</span> <span class="math display">\[
\varepsilon_{ij} = e_{ij} - \mu_{ij}
\]</span> 代入到式 (10.13) 中, 就得到由本征应变导致的不协调性 <span
class="math display">\[
R_{qh} = -\epsilon_{qpk} \epsilon_{hlm} \mu_{km,lp}
\]</span></p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>细观力学</tag>
        <tag>本征应变</tag>
      </tags>
  </entry>
  <entry>
    <title>等效夹杂方法</title>
    <url>/mech/multiscale/%E7%AD%89%E6%95%88%E5%A4%B9%E6%9D%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>考虑如下场景: 一个无穷大的弹性体 D 中嵌入一个椭球形状的夹杂 <span
class="math inline">\(\Omega\)</span>, 如果夹杂的弹性模量 <span
class="math inline">\(C^*_{ijkl}\)</span><strong>与周围弹性体的弹性模量</strong><span
class="math inline">\(C_{ijkl}\)</span> 不同,
则称该夹杂为<strong>非均质夹杂</strong>. 因为非均质夹杂的存在,
其附近的应力场会发生改变. 考虑无穷远处的应变场强度为 <span
class="math inline">\(\varepsilon^0\)</span>, 对应的应力场为 <span
class="math inline">\(\sigma^0 = C : \varepsilon^0\)</span>,
应变与应力场扰动量分别为 <span
class="math inline">\(\varepsilon\)</span> 和 <span
class="math inline">\(\sigma\)</span>, 因此真实的位移和应力为 <span
class="math inline">\(u_i^0 + u_i\)</span> 和 <span
class="math inline">\(\sigma^0 + \sigma\)</span>.<span id="more"></span></p>
<p>应力扰动项 <span class="math inline">\(\sigma\)</span>
满足应力平衡方程(不考虑外力),
以及在无穷远处等于0(或者在有限区域表面等于0)</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
\nabla \cdot \sigma = 0\\
\sigma \cdot n = 0
\end{aligned}
\right.
\]</span></p>
<p>在夹杂内外满足本构方程:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
&amp; \sigma^0+\sigma=\textcolor{red}{L^* :
\left(\varepsilon^0+\varepsilon-\mu\right)} \quad \text { in } \Omega,
\\
&amp; \sigma^0+\sigma=L : \left(\varepsilon^0+\varepsilon\right) \quad
\text { in } D-\Omega .
\end{aligned}
\right.
\tag{1}
\]</span></p>
<p>而 Eshelby 方法所解决的原始问题是: 考虑无穷大的弹性体,
其中嵌入一个椭球夹杂, 该夹杂弹性模量与弹性体<strong>一致</strong>,
然而夹杂内给定常数值的本征应变 <span class="math inline">\(\mu\)</span>,
由此, Eshelby 问题所满足的本构方程为</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
&amp; \sigma^0+\sigma=\textcolor{red}{L :
\left(\varepsilon^0+\varepsilon-\tilde{\mu}\right)} \text { in } \Omega,
\\
&amp; \sigma^0+\sigma=L : \left(\varepsilon^0+\varepsilon\right) \text {
in } D-\Omega .
\end{aligned}
\right.
\tag{2}
\]</span></p>
<p>若令这两类问题等价, 则充要条件是方程组 (1) (2) <span
class="math inline">\(\Omega\)</span> 内的方程右端项相等</p>
<p><span class="math display">\[
L^* : \left(\varepsilon^0+\varepsilon-\mu\right) = L :
\left(\varepsilon^0+\varepsilon-\tilde{\mu}\right) \text { in } \Omega
\tag{3}
\]</span></p>
<p>求解 Eshelby 本征应变问题可以得到等效本征应变 <span
class="math inline">\(\tilde{\mu}\)</span> 与夹杂内外由夹杂引起的应变场
<span class="math inline">\(\varepsilon\)</span> 之间的关系:</p>
<p><span class="math display">\[
\begin{align}
  \varepsilon &amp;= S:\tilde{\mu} \quad x \text{ in } \Omega,\\
  \varepsilon(x) &amp;= D(x):\tilde{\mu} \quad x \text{ in } D-\Omega,
\end{align}
\]</span></p>
<p>将这一关系代入到式 (3) 中, 给定远端应力 <span
class="math inline">\(\varepsilon^0\)</span>, 以及夹杂上的本征应变 <span
class="math inline">\(\mu\)</span>, 就可以得到关于等效本征应变 <span
class="math inline">\(\tilde{\mu}\)</span> 所满足的方程:</p>
<p><span class="math display">\[
L^* : \left(\varepsilon^0+\varepsilon(\tilde{\mu})-\mu\right) = L :
\left(\varepsilon^0+\varepsilon(\tilde{\mu})-\tilde{\mu}\right) \text {
in } \Omega
\]</span></p>
<p>或者写成</p>
<p><span class="math display">\[
\delta L : \varepsilon(\tilde{\mu}) + L:\tilde{\mu} = -\delta L :
\varepsilon^0 + L^{*} : \mu, \quad \delta L = L^{*} - L
\]</span></p>
<p>如果 Eshelby 问题已经解出, 那么就可以得到整个区域上的应变场 <span
class="math inline">\(\varepsilon\)</span>.</p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>细观力学</tag>
        <tag>Eshelby 问题</tag>
      </tags>
  </entry>
  <entry>
    <title>高阶多尺度方法理论推导</title>
    <url>/mech/multiscale/%E9%AB%98%E9%98%B6%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%96%B9%E6%B3%95%E5%BD%B1%E5%93%8D%E5%BC%A0%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="符号约定">符号约定</h2>
<p><span class="math inline">\(n\)</span> 维欧几里得空间定义为 <span
class="math inline">\(\mathbb{E}^{n}\)</span>, 如无特别说明,
方程或函数的定义域 <span class="math inline">\(\Omega \subset
\mathbb{E}^{3}\)</span>.</p>
<p>欧式空间中的元素使用粗体小写字母 <span
class="math inline">\(\boldsymbol{x}\)</span> 或者 <span
class="math inline">\(\boldsymbol{y}\)</span> 表示.</p>
<p>一般的 <span class="math inline">\(n\)</span> 阶张量空间表示为 <span
class="math inline">\(\mathbb{T}^{n}\)</span>, 特别的,
二阶对称张量空间记作 <span class="math inline">\(\mathbb{S}\)</span>.
二阶张量一般使用斜粗体 <span
class="math inline">\(\boldsymbol{T}\)</span> 表示, 四阶张量使用黑板粗体
<span class="math inline">\(\mathbb{T}\)</span> 表示,
其它阶次的张量使用无衬线字体 <span
class="math inline">\(\mathsf{T}\)</span> 表示.</p>
<p>对于高阶张量, 点积的意义会与缩并指标的顺序相关, 点积 <span
class="math inline">\(\cdot\)</span> 定义为 <span
class="math display">\[
\boldsymbol{A} \cdot \boldsymbol{B} \triangleq A_{...i} B_{i...}
\]</span> 点积 <span class="math inline">\(:\)</span> 定义为 <span
class="math display">\[
\boldsymbol{A} : \boldsymbol{B} \triangleq A_{...ij} B_{ij...}
\]</span> 点积 <span class="math inline">\(\therefore\)</span> 定义为
<span class="math display">\[
\boldsymbol{A} \therefore \boldsymbol{B} \triangleq A_{...ijk}
B_{ijk...}
\]</span></p>
<p>函数空间 <span class="math inline">\(L(\Omega)\)</span> 中的元素
<span class="math inline">\(f: \Omega \mapsto \mathbb{T}^{n}\)</span>
是定义在 <span class="math inline">\(\Omega\)</span> 上的函数, 其值域是
<span class="math inline">\(n\)</span> 阶张量.</p>
<p>周期性函数空间 <span class="math inline">\(L(\mathbb{E}^{3})\)</span>
可以看作是定义在单胞区域 <span class="math inline">\(\Theta\)</span>
的函数到全空间 <span class="math inline">\(\mathbb{E}^{3}\)</span>
的延拓.</p>
<p>对于张量场 <span class="math inline">\(\boldsymbol{T}: \Omega \mapsto
\mathbb{T}^{n}\)</span>, 它的梯度定义为 <span class="math display">\[
\mathrm{grad}\ \boldsymbol{T}
\triangleq T_{...,i} \ \underbrace{\boldsymbol{e}_{i_1} \otimes \cdots
\otimes \boldsymbol{e}_{i_n}
\otimes \boldsymbol{e}_{i}}_{n+1}
\]</span> 散度定义为 <span class="math display">\[
\mathrm{div}\ \boldsymbol{T}
\triangleq T_{..i_{n},i_{n}} \ \underbrace{\boldsymbol{e}_{i_1} \otimes
\cdots \otimes \boldsymbol{e}_{n-1}}_{n-1}
\]</span> 方程算子 <span class="math inline">\(\mathcal{A}: L \mapsto
L\)</span> 使用花体表示. 特别的, 使用 <span
class="math inline">\(\nabla\)</span> 表示偏导数算子,
由此可将张量场的梯度和散度重写为 <span class="math display">\[
\mathrm{grad}\ \boldsymbol{T} \leftrightarrow \boldsymbol{T} \nabla,
\quad
\mathrm{div}\  \boldsymbol{T} \leftrightarrow \boldsymbol{T} \cdot
\nabla
\]</span> 定义 <span class="math display">\[
\nabla^{s} \boldsymbol{T} \triangleq \frac{1}{2} ( T_{i \ldots,j} + T_{j
\ldots,i} )
\]</span> 特别的, 对于一阶张量有 <span class="math display">\[
\nabla^{s} \boldsymbol{u} \triangleq \frac{1}{2} ( \boldsymbol{u} \nabla
+ \nabla \boldsymbol{u} )
\]</span></p>
<h2 id="预备定理">预备定理</h2>
<p>对于定义在单胞区域 <span class="math inline">\(\Theta\)</span> 的方程
<span class="math display">\[
- \nabla \cdot [A(\nabla u)] = f
\]</span> 方程的弱形式可以描述为 <span class="math display">\[
\mathrm{find} \ u \in \mathcal{W}_{\mathrm{per}}(\Theta) \ \mathrm{s.t.}
\\
\int_{\Theta} \nabla v \cdot (A \nabla u) \ \mathrm{d} y = \int_{\Theta}
f v \ \mathrm{d} y, \quad
\forall v \in \mathcal{W}_{\mathrm{per}}(\Theta)
\]</span> 其中, 函数空间 <span
class="math inline">\(\mathcal{W}_{\mathrm{per}}(\Theta)\)</span> 定义为
<span class="math display">\[
\mathcal{W}_{\mathrm{per}}(\Theta) \triangleq \{ u \in
{H}_{\mathrm{per}}^{1}(\Theta) \mid
\int_{\Theta} u \ \mathrm{d}y = 0 \}
\]</span> 上述弱形式有唯一解 (在等价类意义下)
的<strong>充分必要条件</strong>是方程右端项在单胞上的积分等于 0: <span
class="math display">\[
\boxed{\int_{\Theta} f \ \mathrm{d}y = 0}
\tag{1}
\]</span> 若函数 <span class="math inline">\(g\)</span> 是 <span
class="math inline">\(\Theta\)</span>-周期性函数,
那么该函数的偏导数在单胞域内的积分总是等于 0: <span
class="math display">\[
\boxed{\int_{\Theta} \frac{ \partial g }{ \partial y_{i} } \ \mathrm{d}
y = 0}
\tag{2}
\]</span></p>
<h2 id="控制方程">控制方程</h2>
<p>控制方程的指标形式为 <span class="math display">\[
\begin{aligned}
&amp;\begin{array}{ll}
\sigma_{i j, j}^\zeta(\boldsymbol{x})+f_i^\zeta(\boldsymbol{x})=0, &amp;
\boldsymbol{x} \in \Omega \\
\sigma_{i j}^\zeta(\boldsymbol{x})=L_{i j k l}^\zeta(\boldsymbol{x} /
\zeta)\left(\varepsilon_{k l}^\zeta(\boldsymbol{x})-\mu_{k
l}^\zeta(\boldsymbol{x})\right), &amp; \boldsymbol{x} \in \Omega \\
\varepsilon_{k l}^\zeta(\boldsymbol{x})=u_{\left(k,
l\right)}^\zeta(\boldsymbol{x}) \equiv \frac{1}{2}\left(u_{k,
l}^\zeta(\boldsymbol{x})+u_{l, k}^\zeta(\boldsymbol{x})\right), &amp;
\boldsymbol{x} \in \Omega
\end{array}\\
&amp;\begin{array}{ll}
u_i^\zeta=\bar{u}_i(\boldsymbol{x}), &amp; \boldsymbol{x} \in \Gamma_u
\\
n_i \sigma_{i j}^\zeta(\boldsymbol{x})=\bar{t}_i(\boldsymbol{x}), &amp;
\boldsymbol{x} \in \Gamma_t
\end{array}
\end{aligned}
\]</span> 将其中的微分方程写成张量形式 <span class="math display">\[
- (\mathbb{L}^{\zeta} : \nabla^{s} \boldsymbol{u}^{\zeta} ) \cdot \nabla
= \boldsymbol{f}^{\zeta}
- (\mathbb{L}^{\zeta} : \boldsymbol{\mu}^{\zeta}) \cdot \nabla
\]</span> 定义如下算子: <span class="math display">\[
\mathcal{A}^{\zeta} \square \triangleq - (\mathbb{L}^{\zeta} :
\nabla^{s} \square) \cdot \nabla, \quad
\mathcal{B}^{\zeta} \square \triangleq - (\mathbb{L}^{\zeta} : \square)
\cdot \nabla
\]</span> 因此微分方程写成算子的形式为 <span class="math display">\[
\mathcal{A}^{\zeta} \boldsymbol{u}^{\zeta}
= \boldsymbol{f}^{\zeta} + \mathcal{B}^{\zeta} \boldsymbol{\mu}^{\zeta}
\]</span> 方程系数 <span class="math inline">\(\mathbb{L}\)</span> 满足
<span class="math display">\[
\boxed{\mathbb{L}^{\zeta}(\boldsymbol{x}) =
\mathbb{L}(\frac{\boldsymbol{x}}{\zeta}), \quad
\boldsymbol{x} \in \Omega}
\]</span> 式中, <span class="math inline">\(\mathbb{L}\)</span> 是 <span
class="math inline">\(\Theta\)</span>-周期性函数.</p>
<h2 id="渐进展开式">渐进展开式</h2>
<p>假设有如下独立的渐进展开式: <span class="math display">\[
\boldsymbol{u}^{\zeta}(\boldsymbol{x})
= \boldsymbol{u}^{(0)}(\boldsymbol{x},\frac{\boldsymbol{x}}{\zeta})
+ \zeta
\boldsymbol{u}^{(1)}(\boldsymbol{x},\frac{\boldsymbol{x}}{\zeta})
+ \zeta^2
\boldsymbol{u}^{(2)}(\boldsymbol{x},\frac{\boldsymbol{x}}{\zeta})
+ \cdots \\
\boldsymbol{\mu}^{\zeta}(\boldsymbol{x})
= \boldsymbol{\mu}^{(0)}(\boldsymbol{x},\frac{\boldsymbol{x}}{\zeta})
+ \zeta
\boldsymbol{\mu}^{(1)}(\boldsymbol{x},\frac{\boldsymbol{x}}{\zeta})
+ \zeta^2
\boldsymbol{\mu}^{(2)}(\boldsymbol{x},\frac{\boldsymbol{x}}{\zeta})
+ \cdots
\]</span> <span class="math inline">\(\boldsymbol{u}^{(i)}:\Omega \times
\Theta \mapsto \mathbb{T}^1\)</span>, <span
class="math inline">\(\boldsymbol{\mu}^{(i)}:\Omega \times \Theta
\mapsto \mathbb{S}\)</span>, 并对坐标 <span
class="math inline">\(y\in\Theta\)</span> 满足 <span
class="math inline">\(\Theta\)</span>-周期性. 若函数 <span
class="math inline">\(\hat{f}(\boldsymbol{x}): \Omega \mapsto
\mathbb{R}\)</span> 定义为 <span class="math display">\[
\hat{f}(\boldsymbol{x}) \triangleq f(\boldsymbol{x},
\frac{\boldsymbol{x}}{\zeta}), \quad
f: \Omega \times \Theta \mapsto \mathbb{R}
\]</span> 那么根据链式法则, 函数 <span
class="math inline">\(\hat{f}\)</span> 对 <span
class="math inline">\(\boldsymbol{x}\)</span> 的偏导数为 <span
class="math display">\[
\frac{ \partial \hat{f} }{ \partial x_{i} }
= \frac{ \partial f }{ \partial x_{i} } + \frac{1}{\zeta} \frac{
\partial f }{ \partial y_{i} }
\]</span> 记成算子形式为 <span class="math display">\[
\nabla = \nabla_{x} + \frac{1}{\zeta} \nabla_{y}
\]</span> 所以, 将渐进展开式代入之后, 算子 <span
class="math inline">\(\mathcal{A}^{\zeta}\)</span> 可以重新表示为 <span
class="math display">\[
\boxed{\mathcal{A}^{\zeta}
= \frac{1}{\zeta^2} \mathcal{A}_{0}
+ \frac{1}{\zeta} \mathcal{A}_{1}
+ \mathcal{A}_{0}, \quad
\mathcal{B}^{\zeta}
= \frac{1}{\zeta} \mathcal{B}_{0}
+ \mathcal{B}_{1}}
\]</span> 式中, <span class="math display">\[
\begin{aligned}
\mathcal{A}_{0} \square &amp;\triangleq - (\mathbb{L} : \nabla_{y}^{s}
\square) \cdot \nabla_{y} \\
\mathcal{A}_{1} \square  &amp;\triangleq - (\mathbb{L} : \nabla_{y}^{s}
\square) \cdot \nabla_{x}
-  (\mathbb{L} : \nabla_{x}^{s} \square) \cdot \nabla_{y}\\
\mathcal{A}_{2} \square  &amp;\triangleq - (\mathbb{L} : \nabla_{x}^{s}
\square) \cdot \nabla_{y} \\
\mathcal{B}_{0} \square  &amp;\triangleq - (\mathbb{L} : \square) \cdot
\nabla_{y} \\
\mathcal{B}_{1} \square  &amp;\triangleq - (\mathbb{L} : \square) \cdot
\nabla_{x}
\end{aligned}
\]</span></p>
<p>将渐进展开式代入到微分方程中得到 <span class="math display">\[
\begin{aligned}
\mathcal{O}(\zeta^{-2}) &amp;: \mathcal{A}_{0} \boldsymbol{u}^{(0)} =
\boldsymbol{0} \\
\mathcal{O}(\zeta^{-1}) &amp;: \mathcal{A}_{0} \boldsymbol{u}^{(1)}
= -\mathcal{A}_{1} \boldsymbol{u}^{(0)} + \mathcal{B}_{0}
\boldsymbol{\mu}^{(0)} \\
\mathcal{O}(1) &amp;: \mathcal{A}_{0} \boldsymbol{u}^{(2)}
= -\mathcal{A}_{2} \boldsymbol{u}^{(0)} -\mathcal{A}_{1}
\boldsymbol{u}^{(1)}
+ \mathcal{B}_{1} \boldsymbol{\mu}^{(0)}
+ \mathcal{B}_{0} \boldsymbol{\mu}^{(1)}
+ \boldsymbol{f}
\end{aligned}
\]</span></p>
<h2 id="不同阶次的控制方程求解">不同阶次的控制方程求解</h2>
<h3 id="mathcalozeta-2-阶方程"><span
class="math inline">\(\mathcal{O}(\zeta^{-2})\)</span> 阶方程</h3>
<p><span class="math display">\[
\mathcal{A}_{0} \boldsymbol{u}^{(0)} = \boldsymbol{0}
\]</span></p>
<p><strong>方程解的唯一性</strong></p>
<p>方程右端项积分等于 0, 因此方程有唯一解.</p>
<p><strong>方程求解</strong></p>
<p>观察到与细观尺度 <span class="math inline">\(y\)</span>
无关的常数是方程的一个解, 所以 <span class="math display">\[
\boxed{\boldsymbol{u}^{(0)}(\boldsymbol{x},\boldsymbol{y}) =
\boldsymbol{u}^{(0)}(\boldsymbol{x})}
\tag{3}
\]</span> ### <span
class="math inline">\(\mathcal{O}(\zeta^{-1})\)</span> 阶方程</p>
<p><span class="math display">\[
\mathcal{A}_{0} \boldsymbol{u}^{(1)}
= -\mathcal{A}_{1} \boldsymbol{u}^{(0)} + \mathcal{B}_{0}
\boldsymbol{\mu}^{(0)}
\]</span></p>
<p><strong>方程解的唯一性</strong></p>
<p>根据定理 (1), 保证该方程有唯一解的充要条件是: <span
class="math display">\[
\int_{\Theta} -\mathcal{A}_{1} \boldsymbol{u}^{(0)} + \mathcal{B}_{0}
\boldsymbol{\mu}^{(0)} \ \mathrm{d}y = 0, \quad \forall x
\]</span></p>
<p>也即 <span class="math display">\[
\int_{\Theta} (\mathbb{L} : \nabla_{x}^{s} \boldsymbol{u}^{(0)}) \cdot
\nabla_{y} \ \mathrm{d}y
- \int_{\Theta} (\mathbb{L} : \boldsymbol{\mu}^{(0)})  \cdot \nabla_{y}
\ \mathrm{d}y = 0
\]</span></p>
<p>将 <span class="math inline">\(x\)</span> 视作参数, 又因为 <span
class="math inline">\(\nabla_{x}^{s} \boldsymbol{u}^{(0)}\)</span> 与
<span class="math inline">\(y\)</span> 无关, 而 <span
class="math inline">\(\boldsymbol{\mu}^{(0)}(\cdot,y)\)</span> 是 <span
class="math inline">\(\Theta\)</span>​-周期函数, 根据定理 (2), 上式恒等于
0, 所以方程有唯一解的条件满足.</p>
<p><strong>方程求解</strong></p>
<p>定义宏观应变 <span class="math inline">\(\boldsymbol{\varepsilon}^{c}
\in \mathbb{S}\)</span>: <span class="math display">\[
\boldsymbol{\varepsilon}^{c} \triangleq \nabla_{x}^{s}
\boldsymbol{u}^{(0)}
\]</span> 假设方程解 <span
class="math inline">\(\boldsymbol{u}^{(1)}\)</span> 具有如下形式: <span
class="math display">\[
\boxed{\boldsymbol{u}^{(1)}(x,y)
= \mathsf{H} : \boldsymbol{\varepsilon}^{c}
+ \int_{\Theta} \mathsf{h} : \boldsymbol{\mu}^{(0)} \ \mathrm{d} y}
\]</span> 式中, <span class="math inline">\(\mathsf{H}: \Theta \mapsto
\mathbb{T}^3\)</span> , <span class="math inline">\(\mathsf{h}: \Theta
\times \Theta \mapsto \mathbb{T}^3\)</span>. 张量 <span
class="math inline">\(\mathsf{H}\)</span> 和 <span
class="math inline">\(\mathsf{h}\)</span> 具有如下对称性 <span
class="math display">\[
H_{imn} = H_{inm}, \quad
h_{imn} = h_{inm}
\]</span> 单胞上的本征应变采用分片常值形函数进行插值近似: <span
class="math display">\[
\boldsymbol{\mu}^{(0)}(x,y)
\approx \sum_{\alpha=1}^{N} \mathbb{I}^{(\alpha)}(y) :
\boldsymbol{\mu}^{(0,\alpha)}(x)
\]</span> 所以 <span class="math display">\[
\boxed{\boldsymbol{u}^{(1)}(x,y)
\approx \mathsf{H} : \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N} \int_{\Theta^{(\alpha)}} \mathsf{h}\ \mathrm{d} y
: \boldsymbol{\mu}^{(0,\alpha)}
}
\]</span> 代入方程中有 <span class="math display">\[
\mathcal{A}_{0} \left(
\mathsf{H} : \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N} \int_{\Theta^{(\alpha)}} \mathsf{h}\ \mathrm{d} y
: \boldsymbol{\mu}^{(0,\alpha)}
\right)
= -\mathcal{A}_{1} \boldsymbol{u}^{(0)}
+ \mathcal{B}_{0} \boldsymbol{\mu}^{(0)}
\]</span> 整理得到 <span class="math display">\[
\mathcal{A}_{0} \mathsf{H} : \boldsymbol{\varepsilon}^{c}
+ \mathcal{A}_{1} \boldsymbol{u}^{(0)}
+ \sum_{\alpha=1}^{N} \left(
\mathcal{A}_{0} \int_{\Theta^{(\alpha)}} \mathsf{h}\ \mathrm{d} y
- \mathcal{B}_{0} \mathbb{I}^{(\alpha)}
\right) :  \boldsymbol{\mu}^{(0,\alpha)}
= 0
\]</span> 由 <span
class="math inline">\(\boldsymbol{\varepsilon}^{c}\)</span> 的任意性,
得到一组关于 <span class="math inline">\(\mathsf{H}\)</span> 的线性方程
<span class="math display">\[
(\mathbb{L} : \nabla_{y}^{s} \mathsf{H} : \boldsymbol{\lambda}) \cdot
\nabla_{y}
+ (\mathbb{L} : \boldsymbol{\lambda})  \cdot \nabla_{y}  =
\boldsymbol{0}, \quad
\forall \boldsymbol{\lambda} \in \mathbb{S}
\]</span> 以及 <span
class="math inline">\(\boldsymbol{\mu}^{(0,\alpha)}\)</span> 的任意性,
得到关于 <span class="math inline">\(\int_{\Theta^{(\alpha)}}
\mathsf{h}\ \mathrm{d} y\)</span> 的线性方程 <span
class="math display">\[
\left\{ \mathbb{L} : \nabla_{y}^{s} \left( \int_{\Theta^{(\alpha)}}
\mathsf{h}\ \mathrm{d} y \right)
: \boldsymbol{\lambda}
- \mathbb{L} : \mathbb{I}^{(\alpha)} : \boldsymbol{\lambda}
\right\} \cdot \nabla_{y}
= \boldsymbol{0}, \quad \forall \boldsymbol{\lambda} \in \mathbb{S}
\]</span> 定义 <span class="math inline">\(\boldsymbol{H}_{\lambda},
\boldsymbol{h}_{\lambda}^{(\alpha)}: \Theta \mapsto
\mathbb{T}^1\)</span> <span class="math display">\[
\boldsymbol{H}_{\lambda} \triangleq \mathsf{H} : \boldsymbol{\lambda},
\quad
\boldsymbol{h}_{\lambda}^{(\alpha)} \triangleq \int_{\Theta^{(\alpha)}}
\mathsf{h}\ \mathrm{d} y : \boldsymbol{\lambda}
\]</span> 又因为方程是线性的, 所以若选取空间 <span
class="math inline">\(\mathbb{S}\)</span> 的一组规范正交基 <span
class="math inline">\(\boldsymbol{e}_{i}\)</span>, 并定义 <span
class="math display">\[
\boldsymbol{H}_{i} \triangleq \mathsf{H} : \boldsymbol{e}_{i}, \quad
\boldsymbol{h}_{i}^{(\alpha)} \triangleq \int_{\Theta^{(\alpha)}}
\mathsf{h}\ \mathrm{d} y : \boldsymbol{e}_{i}, \quad
i = 1,2, \ldots , \mathrm{dim}\ \mathbb{S}
\]</span> 那么对任意的 <span class="math inline">\(\boldsymbol{\lambda}
= \lambda_{i} \boldsymbol{e}_{i} \in \mathbb{S}\)</span> <span
class="math display">\[
\boldsymbol{H}_{\lambda} = \lambda_{i} \boldsymbol{H}_{i}, \quad
\boldsymbol{h}_{\lambda}^{(\alpha)} = \lambda_{i}
\boldsymbol{h}_{i}^{(\alpha)}
\]</span> ### <span class="math inline">\(\mathcal{O}(1)\)</span>
阶方程</p>
<p><span class="math display">\[
\mathcal{A}_{0} \boldsymbol{u}^{(2)}
= -\mathcal{A}_{2} \boldsymbol{u}^{(0)} -\mathcal{A}_{1}
\boldsymbol{u}^{(1)}
+ \mathcal{B}_{1} \boldsymbol{\mu}^{(0)}
+ \mathcal{B}_{0} \boldsymbol{\mu}^{(1)}
+ \boldsymbol{f}
\]</span></p>
<p><strong>方程解的唯一性</strong></p>
<p>方程有唯一解的条件为 <span class="math display">\[
\langle -\mathcal{A}_{2} \boldsymbol{u}^{(0)} -\mathcal{A}_{1}
\boldsymbol{u}^{(1)}
+ \mathcal{B}_{1} \boldsymbol{\mu}^{(0)}
+ \mathcal{B}_{0} \boldsymbol{\mu}^{(1)}
+ \boldsymbol{f} \rangle = 0
\]</span> 而 <span class="math display">\[
\begin{aligned}
\langle -\mathcal{A}_{2} \boldsymbol{u}^{(0)} \rangle
&amp;= (\mathbb{L} : \boldsymbol{\varepsilon}^{c}) \cdot \nabla_{x}  \\
\langle -\mathcal{A}_{1} \boldsymbol{u}^{(1)} \rangle
&amp;= \langle \mathbb{L} : \nabla_{y}^{s} \boldsymbol{u}^{(1)} \rangle
\cdot \nabla_{x} , \\
&amp;\langle \mathbb{L} : \nabla_{y} \boldsymbol{u}^{(1)} \rangle
= \langle \mathbb{L} : \nabla_{y}^{s} \mathsf{H} \rangle :
\boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N}
\langle \mathbb{L} : \nabla_{y}^{s} \int_{\Theta^{(\alpha)}} \mathsf{h}\
\mathrm{d} y  \rangle
:\boldsymbol{\mu}^{(0,\alpha)} \\
\langle \mathcal{B}_{1} \boldsymbol{\mu}^{(0)} \rangle
&amp;= - \left(  \sum_{\alpha=1}^{N} \langle \mathbb{L}
:  \mathbb{I}^{(\alpha)} \rangle  : \boldsymbol{\mu}^{(0,\alpha)}
\right) \cdot \nabla_{x} \\
\langle \mathcal{B}_{0} \boldsymbol{\mu}^{(1)} \rangle  &amp;=
\boldsymbol{0} \\
\langle \boldsymbol{f} \rangle &amp;= \boldsymbol{f}
\end{aligned}
\]</span> 得到宏观尺度上, 考虑本征应变的控制方程. <span
class="math display">\[
\left\{
\left[ \mathbb{L} + \langle \mathbb{L} : \nabla_{y}^{s} \mathsf{H}
\rangle \right]
: \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N}
\left\langle \mathbb{L} :
\left( \nabla_{y}^{s} \int_{\Theta^{(\alpha)}} \mathsf{h}\ \mathrm{d} y
- \mathbb{I}^{(\alpha)} \right)
\right\rangle
:\boldsymbol{\mu}^{(0,\alpha)}
\right\} \cdot \nabla_{x} + \boldsymbol{f} = \boldsymbol{0}
\]</span> 定义 <span class="math display">\[
\mathbb{E} \triangleq \nabla_{y}^{s} \mathsf{H} + \mathbb{I}, \quad
\mathbb{P}^{(\alpha)} \triangleq \nabla_{y}^{s} \int_{\Theta^{(\alpha)}}
\mathsf{h}\ \mathrm{d} y, \quad
\mathbb{A}^{(\alpha)} \triangleq \mathbb{L} : (\mathbb{P}^{(\alpha)} -
\mathbb{I}^{(\alpha)})
\]</span> 就得到 <span class="math display">\[
\left(
\langle \mathbb{L} : \mathbb{E} \rangle
: \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N} \langle \mathbb{A}^{(\alpha)} \rangle :
\boldsymbol{\mu}^{(0,\alpha)}
\right) \cdot \nabla_{x} + \boldsymbol{f} = 0
\]</span></p>
<p>所以, 方程有唯一解的条件为在宏观尺度下满足上述控制方程.</p>
<p><strong>方程求解</strong></p>
<p>整理方程右端项 <span class="math display">\[
\begin{aligned}
-\mathcal{A}_{2} \boldsymbol{u}^{(0)}
&amp;= \mathbb{L} \therefore \nabla_{x} \boldsymbol{\varepsilon}^{c}\\
-\mathcal{A}_{1} \boldsymbol{u}^{(1)}
&amp;= \left( \mathbb{L} : \nabla_{y}^{s} \mathsf{H} \right) \therefore
\nabla_{x} \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N} \left(
\mathbb{L} : \nabla_{y}^{s} \int_{\Theta^{(\alpha)}} \mathsf{h}\
\mathrm{d} y  
\right)
\therefore \nabla_{x} \boldsymbol{\mu}^{(0,\alpha)} \\
&amp;+ \nabla_{y} \cdot ( \mathbb{L} \cdot \mathsf{H} ) \therefore
\nabla_{x} \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N} \nabla_{y} \cdot \left( \mathbb{L} \cdot
\int_{\Theta^{(\alpha)}} \mathsf{h}\ \mathrm{d} y  
\right)
\therefore \nabla_{x} \boldsymbol{\mu}^{(0,\alpha)}\\
\mathcal{B}_{1} \boldsymbol{\mu}^{(0)}
&amp;= - \sum_{\alpha=1}^{N} \left( \mathbb{L} : \mathbb{I}^{(\alpha)}
\right)
\therefore \nabla_{x} \boldsymbol{\mu}^{(0,\alpha)} \\
\mathcal{B}_{0} \boldsymbol{\mu}^{(1)}
&amp;= - \left( \mathbb{L} : \boldsymbol{\mu}^{(1)} \right) \cdot
\nabla_{y} \\
\boldsymbol{f}
&amp;= - \mathbb{L}^{c} \therefore \nabla_{x}
\boldsymbol{\varepsilon}^{c}
- \sum_{\alpha=1}^{N} \langle \mathbb{A}^{(\alpha)} \rangle
\therefore \nabla_{x} \boldsymbol{\mu}^{(0,\alpha)}
\end{aligned}
\]</span> 由此得到 <span class="math display">\[
\begin{aligned}
\mathcal{A}_{0} \boldsymbol{u}^{(2)}
&amp;= \mathbb{L} \therefore \nabla_{x} \boldsymbol{\varepsilon}^{c}\\
&amp;+ \left( \mathbb{L} : \nabla_{y}^{s} \mathsf{H} \right) \therefore
\nabla_{x} \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N} \left(
\mathbb{L} : \nabla_{y}^{s} \int_{\Theta^{(\alpha)}} \mathsf{h}\
\mathrm{d} y  
\right)
\therefore \nabla_{x} \boldsymbol{\mu}^{(0,\alpha)} \\
&amp; + \nabla_{y} \cdot ( \mathbb{L} \cdot \mathsf{H} ) \therefore
\nabla_{x} \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N} \nabla_{y} \cdot \left( \mathbb{L} \cdot
\int_{\Theta^{(\alpha)}} \mathsf{h}\ \mathrm{d} y  
\right)
\therefore \nabla_{x} \boldsymbol{\mu}^{(0,\alpha)} \\
&amp;- \sum_{\alpha=1}^{N} \left( \mathbb{L} : \mathbb{I}^{(\alpha)}
\right)
\therefore \nabla_{x} \boldsymbol{\mu}^{(0,\alpha)} \\
&amp;- \left( \mathbb{L} : \boldsymbol{\mu}^{(1)} \right) \cdot
\nabla_{y} \\
&amp;- \mathbb{L}^{c} \therefore \nabla_{x} \boldsymbol{\varepsilon}^{c}
- \sum_{\alpha=1}^{N} \langle \mathbb{A}^{(\alpha)} \rangle
\therefore \nabla_{x} \boldsymbol{\mu}^{(0,\alpha)}
\end{aligned}
\]</span> 或者 <span class="math display">\[
\boxed{
\begin{aligned}
\mathcal{A}_{0} \boldsymbol{u}^{(2)}
&amp;= \left\{
( \mathbb{L} : \mathbb{E} - \langle \mathbb{L} : \mathbb{E} \rangle )
+  \nabla_{y} \cdot ( \mathbb{L} \cdot \mathsf{H} )\right\}
\therefore \boxed{\nabla_{x} \boldsymbol{\varepsilon}^{c}} \\
&amp;+ \sum_{\alpha=1}^{N} \left\{ \left(
\mathbb{A}^{(\alpha)} - \langle \mathbb{A}^{(\alpha)} \rangle
\right)
+ \nabla_{y} \cdot \left( \mathbb{L} \cdot \int_{\Theta^{(\alpha)}}
\mathsf{h}\ \mathrm{d} y  
\right) \right\}
\therefore \boxed{\nabla_{x} \boldsymbol{\mu}^{(0,\alpha)}} \\
&amp;- \left( \mathbb{L} : \boldsymbol{\mu}^{(1)} \right) \cdot
\nabla_{y}
\end{aligned}
}
\]</span></p>
<p>假设位移的表达式为 <span class="math display">\[
\boldsymbol{u}^{(2)}(x,y)
= \mathbb{W} \therefore \nabla_{x} \boldsymbol{\varepsilon}^{c}
+ \int_{\Theta} \mathbb{w} \therefore \nabla_{x} \boldsymbol{\mu}^{(0)}
\ \mathrm{d} y
+ \int_{\Theta} \mathsf{h} : \boldsymbol{\mu}^{(1)} \ \mathrm{d} y
\]</span></p>
<p>式中, <span class="math inline">\(\mathbb{W}\)</span> 和 <span
class="math inline">\(\mathbb{w}\)</span> 是四阶张量, 并且 3,4
指标具有对称性. 对本征应变梯度和一阶本征应变使用相同的分片常值插值函数
<span class="math display">\[
\boldsymbol{u}^{(2)}(x,y)
\approx \mathbb{W} \therefore \nabla_{x} \boldsymbol{\varepsilon}^{c}
+ \sum_{\alpha=1}^{N} \int_{\Theta^{(\alpha)}} \mathbb{w} \ \mathrm{d} y
\therefore \nabla_{x} \boldsymbol{\mu}^{(0, \alpha)}
+ \sum_{\alpha=1}^{N} \int_{\Theta^{(\alpha)}} \mathsf{h} \ \mathrm{d} y
: \boldsymbol{\mu}^{(1, \alpha)}
\]</span> 代入到方程中, 再根据 <span class="math inline">\(\nabla_{x}
\boldsymbol{\varepsilon}^{c}\)</span> 和 <span
class="math inline">\(\nabla_{x} \boldsymbol{\mu}^{(0,\alpha)}\)</span>
的任意性, 得到方程组 <span class="math display">\[
- \nabla_{y} \cdot (\mathbb{L} : \nabla_{y}^{s} \mathbb{W} \therefore
\mathsf{e})
= ( \mathbb{L} : \mathbb{E} - \langle \mathbb{L} : \mathbb{E} \rangle)
\therefore \mathsf{e}
+  \nabla_{y} \cdot ( \mathbb{L} \cdot \mathsf{H} ) \therefore
\mathsf{e}, \quad
\forall \mathsf{e} \in \mathbb{T}^{3}
\]</span></p>
<p><span class="math display">\[
- \nabla_{y} \cdot \left( \mathbb{L} : \nabla_{y}^{s}
\int_{\Theta^{(\alpha)}} \mathbb{w} \ \mathrm{d} y \therefore \mathsf{e}
\right)
= \left( \mathbb{A}^{(\alpha)} - \langle \mathbb{A}^{(\alpha)} \rangle
\right) \therefore \mathsf{e}
+  \nabla_{y} \cdot \left(  \mathbb{L} \cdot \int_{\Theta^{(\alpha)}}
\mathsf{h} \ \mathrm{d} y  \right) \therefore \mathsf{e}, \quad
\forall \mathsf{e} \in \mathbb{T}^{3}
\]</span></p>
<h2 id="有限元离散化">有限元离散化</h2>
<p><span class="math display">\[
\left[ L_{ijkl}
\left( W_{(k,{l})}^{mnp}
+ \delta_{lp} H_{k}^{mn} \right) \right]_{,{j}}
= \overline{L}_{ijkl} I_{kl}^{mn} \delta_{jp}
- L_{ijkl} E_{kl}^{mn} \delta_{jp},
\quad \boldsymbol{y} \in \Theta
\]</span></p>
<p>推导该方程的弱形式, 方程两边乘函数 <span class="math inline">\(\delta
v_{i}\)</span>, 然后再单胞上进行积分得到 <span class="math display">\[
\int_{\Theta} \delta v_{i} \left[ L_{ijkl}
\left( W_{(k,{l})}^{mnp}
+ \delta_{lp} H_{k}^{mn}\right) \right]_{,{j}}
\mathrm{d} \boldsymbol{y}\\
= \int_{\Theta} \delta v_{i} \overline{L}_{ijkl} I_{kl}^{mn} \delta_{jp}
- \delta v_{i} L_{ijkl} E_{kl}^{mn} \delta_{jp}
\mathrm{d} \boldsymbol{y}
\]</span> 方程的左端项使用分部积分公式得到 <span class="math display">\[
\mathrm{LHS} = - \int_{\Theta} \delta v_{i,j}  L_{ijkl} \left(
W_{(k,{l})}^{mnp}
+ \delta_{lp} H_{k}^{mn}\right) \mathrm{d} \boldsymbol{y} \\
+ \int_{\partial \Theta} \delta v_{i} n_{j} L_{ijkl} \left(
W_{(k,{l})}^{mnp}
+ \delta_{lp} H_{k}^{mn}\right)
\mathrm{d} \boldsymbol{y}
\]</span> 在边界上的积分项可以根据周期性边界条件消去, 这就得到 <span
class="math display">\[
\int_{\Theta} \delta v_{i,j}  L_{ijkl}  W_{(k,{l})}^{mnp} \mathrm{d}
\boldsymbol{y}
= - \int_{\Theta} \delta v_{i,j}  L_{ijkl} \delta_{lp} H_{k}^{mn}
\mathrm{d} \boldsymbol{y} \\
+ \int_{\Theta} \delta v_{i} \left(
L_{ijkl} E_{kl}^{mn} - \overline{L}_{ijkl} I_{kl}^{mn} \right)
\delta_{jp}
\mathrm{d} \boldsymbol{y}
\]</span></p>
<p><span class="math display">\[
\mathrm{find} \ \boldsymbol{H}_{i} \in
\mathcal{W}_{\mathrm{per}}(\Theta) \quad \mathrm{s.t.} \\
\int_{\Theta} \nabla_{y} \boldsymbol{v} : \mathbb{L} : \nabla_{y}
\boldsymbol{H}_{i} \ \mathrm{d} y
= - \int_{\Theta} \nabla_{y} \boldsymbol{v} : \mathbb{L} :
\boldsymbol{e}_{i} \ \mathrm{d}y, \quad
\forall \boldsymbol{v} \in \mathcal{W}_{\mathrm{per}}(\Theta)
\]</span></p>
<p><span class="math display">\[
\mathrm{find} \ \boldsymbol{h}_{i}^{(\alpha)} \in
\mathcal{W}_{\mathrm{per}}(\Theta) \quad \mathrm{s.t.} \\
\int_{\Theta} \nabla_{y} \boldsymbol{v} : \mathbb{L} : \nabla_{y}
\boldsymbol{h}_{i}^{(\alpha)} \ \mathrm{d} y
= \int_{\Theta} \nabla_{y} \boldsymbol{v} : \mathbb{L} :
\mathbb{I}^{(\alpha)} : \boldsymbol{e}_{i} \ \mathrm{d}y, \quad
\forall \boldsymbol{v} \in \mathcal{W}_{\mathrm{per}}(\Theta)
\]</span></p>
<p>考虑待求解的影响函数 <span class="math inline">\(W_{k}^{mnp}\)</span>
可以被离散为 <span class="math display">\[
\boldsymbol{W}^{mnp}(\boldsymbol{y}) = \mathbf{N}(\boldsymbol{y})
\mathbf{d}^{mnp}, \quad
\delta \boldsymbol{v}(\boldsymbol{y}) = \mathbf{N}(\boldsymbol{y})
\delta \mathbf{d}
\]</span> 函数 <span class="math inline">\(H_{k}^{mn}\)</span>, <span
class="math inline">\(E_{kl}^{mn}\)</span>
是一阶多尺度方法求解得到的影响函数, 可以被形函数离散为: <span
class="math display">\[
H_{k}^{mn}(\boldsymbol{y}) = \mathbf{N}(\boldsymbol{y}) \mathbf{d}^{mn},
\quad
E_{kl}^{mn} = \mathbf{B}(\boldsymbol{y}) \mathbf{d}^{mn} +
\mathbf{I}_{6\times 6}
\]</span> 式中, <span class="math inline">\(\mathbf{d}^{mn}\)</span> 是
<code>3nen x 6</code> 的已知矩阵, <span
class="math inline">\(\mathbf{N}(\boldsymbol{y})\)</span> 是
<code>3 x 3nen</code> 形函数矩阵, <span
class="math inline">\(\mathbf{B}(\boldsymbol{y})\)</span> 是
<code>6 x 3nen</code> 形函数关于坐标偏导数的矩阵.</p>
]]></content>
      <categories>
        <category>多尺度</category>
      </categories>
      <tags>
        <tag>渐进展开</tag>
        <tag>二阶多尺度</tag>
      </tags>
  </entry>
</search>
